<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Cui Lanqing">
  <!-- Open Graph Data -->
  <meta property="og:title" content="GCD源码分析（二）——Dispatch Queue和Thread Pool"/>
  <meta property="og:description" content="一枚有梦想的程序猿" />
  <meta property="og:site_name" content="崔岚清的个人博客"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="崔岚清的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>崔岚清的个人博客</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-light.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">GCD源码分析（二）——Dispatch Queue和Thread Pool</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Cui Lanqing</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-11-29</span>
            <span class="time">16:17:53</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/iOS开发/">iOS开发</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Objective-C-libdispatch/">#Objective-C, libdispatch</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>大部分的GCD操作都离不开队列（queue）：使用<code>dispatch_get_main_queue</code>获取主队列，使用<code>dispatch_queue_create</code>创建一个自定义的队列，使用<code>dispatch_get_global_queue</code>获取一个全局的并发队列等等。那么GCD是如何通过这些队列实现多线程的呢？它又是如何管理这些队列的呢？<code>dispatch_async/dispatch_sync</code>是如何工作的呢？带着这些问题，我们从源码中寻找答案。</p>
<h3 id="二、队列与线程"><a href="#二、队列与线程" class="headerlink" title="二、队列与线程"></a>二、队列与线程</h3><p>首先，借用一张网上的图片直观地描述GCD队列和线程的关系。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/gcd_queues_thread.png" alt="GCD队列和线程"></p>
<p>通过GCD，我们可以很方便地实现多线程，而不需要过多地关注线程的实现和创建等，GCD内部维护了一个线程池，由系统根据任务的数量和优先级动态地创建和分配线程执行。</p>
<p>我们提交的任务由GCD内部的manager queue管理一层层地分发到target queue中，最终汇聚到root queue中并由线程池管理线程来执行任务。</p>
<p>线程和队列并不是一对一的关系，一个线程中可能有多个串行或并行队列，这些队列按照同步或异步的方式工作。</p>
<p>注：为方便阅读，文中的所有代码均为宏展开后的代码。</p>
<h4 id="GCD中队列的种类"><a href="#GCD中队列的种类" class="headerlink" title="GCD中队列的种类"></a>GCD中队列的种类</h4><p>从libdispatch源码中可以看到，GCD中一共有如下几种队列：</p>
<ul>
<li>主队列，使用<code>dispatch_get_main_queue()</code>获得的队列，与主线程绑定</li>
<li>全局队列，使用<code>dispatch_get_global_queue()</code>获得的队列，是并行队列，由GCD创建并管理，也是libdispatch内部使用的root-queue</li>
<li>自定义队列，使用<code>dispatch_queue_create()</code>创建的队列，为串行或并行队列</li>
<li>管理队列，libdispatch内部使用的队列，不暴露给开发者，作为队列的调度管理者使用</li>
<li>Runloop队列，用于与线程绑定的<code>dispatch_queue</code>，比如：提交到main-queue上的任务是由runloop-queue进行管理并最终调度到main thread的runloop中处理。</li>
</ul>
<h5 id="主队列main-queue"><a href="#主队列main-queue" class="headerlink" title="主队列main queue"></a>主队列main queue</h5><p>在<code>dispatch_get_main_queue()</code>的函数声明处有如下内容：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @function dispatch_get_main_queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @abstract</span></span><br><span class="line"><span class="comment"> * Returns the default queue that is bound to the main thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @discussion</span></span><br><span class="line"><span class="comment"> * In order to invoke blocks submitted to the main queue, the application must</span></span><br><span class="line"><span class="comment"> * call dispatch_main(), NSApplicationMain(), or use a CFRunLoop on the main</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @result</span></span><br><span class="line"><span class="comment"> * Returns the main queue. This queue is created automatically on behalf of</span></span><br><span class="line"><span class="comment"> * the main thread before main() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>可以看出主队列在<code>main()</code>函数调用之前被创建，同时也说明了libdispatch库的初始化工作在main函数之前就完成了。</p>
<p>调用<code>dispatch_get_main_queue()</code>返回的是<code>_dispatch_main_q</code>这样一个<code>dispatch_queue_t</code>类型的结构体。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_main_queue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (__bridge <span class="built_in">dispatch_queue_t</span>)&amp;(_dispatch_main_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_main_q</code>的结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_main_q = &#123;</span><br><span class="line">	.do_vtable = OS_dispatch_queue_main_class,</span><br><span class="line">	._objc_isa = OS_dispatch_queue_main_class</span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT</span><br><span class="line"><span class="meta">#if !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT],</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_CANNOT_TRYSYNC | DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到<code>_dispatch_main_q</code>包含以下属性：</p>
<h5 id="1、-do-vtable、-objc-isa"><a href="#1、-do-vtable、-objc-isa" class="headerlink" title="1、.do_vtable、._objc_isa"></a>1、.do_vtable、._objc_isa</h5><ul>
<li>do_vtable 包含了队列的类型、dispose、invoke、push、wakeup和debug等信息，这些信息与队列和任务的调度有关</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"main-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_main_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>_objc_isa main_queue的isa指针指向OS_dispatch_queue_main_class</li>
</ul>
<h5 id="2、-do-ref-cnt、-do-xref-cnt"><a href="#2、-do-ref-cnt、-do-xref-cnt" class="headerlink" title="2、.do_ref_cnt、.do_xref_cnt"></a>2、.do_ref_cnt、.do_xref_cnt</h5><p>队列的内部、外部引用计数都赋值为<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>，而<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>的实际定义为<code>INT_MAX</code>，说明了主队列的生命周期与App的生命周期一致，开发者无需对主队列进行retain/release操作，其生命周期由GCD管理。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_OBJECT_GLOBAL_REFCNT		_OS_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"><span class="meta">#define _OS_OBJECT_GLOBAL_REFCNT INT_MAX</span></span><br></pre></td></tr></table></figure>
<h5 id="3、-do-targetq"><a href="#3、-do-targetq" class="headerlink" title="3、.do_targetq"></a>3、.do_targetq</h5><p>主队列的target queue为<code>&amp;_dispatch_root_queues[
            DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT],</code>，实际上就是serialnum=11的”com.apple.root.default-qos.overcommit”这个全局队列，注意这里虽然有个条件编译命令：<code>#if !DISPATCH_USE_RESOLVERS</code>，但是实际上在<code>libdispatch_init()</code>函数中又一次设置了main_queue的do_targetq：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DISPATCH_USE_RESOLVERS // rdar://problem/8541707</span></span><br><span class="line">	_dispatch_main_q.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>所以无论条件编译是否命中，主队列的target queue都被设置为”com.apple.root.default-qos.overcommit”这个root queue。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/2.png" alt="dispatch_main_queue的target_queue"></p>
<blockquote>
<p>GCD中所有的非全局队列（自定义队列及内部的管理队列）的任务最终都是要提交到全局队列（即：root queue）中处理，主队列除外，主队列与主线程绑定，提交到主队列中的任务由runloop queue管理并提交到主线程的runloop执行。</p>
</blockquote>
<h5 id="全局队列global-queue"><a href="#全局队列global-queue" class="headerlink" title="全局队列global queue"></a>全局队列global queue</h5><p>GCD内部维护12个全局队列，对应上述的四个优先级：High/Default/Low/Background。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_root_queues[] = &#123;</span><br><span class="line"><span class="meta">#define _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">	((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_<span class="meta">##n##_QOS_OVERCOMMIT : \</span></span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_<span class="meta">##n##_QOS)</span></span><br><span class="line"><span class="meta">#define _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT_HEADER(queue_root), \</span><br><span class="line">		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[ \</span><br><span class="line">				_DISPATCH_ROOT_QUEUE_IDX(n, flags)], \</span><br><span class="line">		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">		.dq_priority = _dispatch_priority_make(DISPATCH_QOS_<span class="meta">##n, 0) | flags | \</span></span><br><span class="line">				DISPATCH_PRIORITY_FLAG_ROOTQUEUE | \</span><br><span class="line">				((flags &amp; DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE) ? <span class="number">0</span> : \</span><br><span class="line">				DISPATCH_QOS_<span class="meta">##n <span class="meta-string">&lt;&lt; DISPATCH_PRIORITY_OVERRIDE_SHIFT), \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		__VA_ARGS__ \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.maintenance-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 4,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.maintenance-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 5,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.background-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 6,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.background-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 7,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.utility-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 8,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.utility-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 9,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.default-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 10,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">			DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.default-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 11,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-initiated-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 12,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-initiated-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 13,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-interactive-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 14,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-interactive-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 15,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>dq_serialnum为队列号，全局队列的队列号从4开始，前面三个分别为：</p>
<ul>
<li>主队列，dq_serialnum = 1</li>
<li>管理队列（_dispatch_mgr_q），dq_serialnum = 2</li>
<li>dispatch_mgr_root_queue（_dispatch_mgr_q的目标队列），dq_serialnum = 3</li>
</ul>
<h5 id="管理队列manager-queue"><a href="#管理队列manager-queue" class="headerlink" title="管理队列manager queue"></a>管理队列manager queue</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_mgr_q = &#123;</span><br><span class="line">	.do_vtable = DISPATCH_VTABLE(queue_mgr), </span><br><span class="line">	._objc_isa = DISPATCH_OBJC_CLASS(queue_mgr), </span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.do_targetq = &amp;_dispatch_mgr_root_queue,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.libdispatch-manager"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |</span><br><span class="line">			DISPATCH_PRIORITY_SATURATED_OVERRIDE,</span><br><span class="line">	.dq_serialnum = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> dispatch_queue_s _dispatch_mgr_root_queue = &#123;</span><br><span class="line">	DISPATCH_GLOBAL_OBJECT_HEADER(queue_root),</span><br><span class="line">	.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">	.do_ctxt = &amp;_dispatch_mgr_root_queue_context,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.root.libdispatch-manager"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |</span><br><span class="line">			DISPATCH_PRIORITY_SATURATED_OVERRIDE,</span><br><span class="line">	.dq_serialnum = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line"><span class="comment">// 6618342 Contact the team that owns the Instrument DTrace probe before</span></span><br><span class="line"><span class="comment">//         renaming this symbol</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_dispatch_worker_thread(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line"><span class="meta">#if DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">bool</span> overcommit = (qc-&gt;dgq_wq_options &amp; WORKQ_ADDTHREADS_OPTION_OVERCOMMIT);</span><br><span class="line">	<span class="keyword">bool</span> manager = (dq == &amp;_dispatch_mgr_root_queue);</span><br><span class="line">	<span class="keyword">bool</span> monitored = !(overcommit || manager);</span><br><span class="line">	<span class="keyword">if</span> (monitored) &#123;</span><br><span class="line">		_dispatch_workq_worker_register(dq, qc-&gt;dgq_qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> int64_t timeout = <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">	pthread_priority_t old_pri = _dispatch_get_priority();</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_root_queue_drain(dq, old_pri);</span><br><span class="line">		_dispatch_reset_priority_and_voucher(old_pri, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dispatch_semaphore_wait(&amp;pqc-&gt;dpq_thread_mediator,</span><br><span class="line">			dispatch_time(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (monitored) &#123;</span><br><span class="line">		_dispatch_workq_worker_unregister(dq, qc-&gt;dgq_qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	(<span class="keyword">void</span>)os_atomic_inc2o(qc, dgq_thread_pool_size, release);</span><br><span class="line">	_dispatch_global_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	_dispatch_release(dq); <span class="comment">// retained in _dispatch_global_queue_poke_slow</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif // DISPATCH_USE_PTHREAD_POOL</span></span><br></pre></td></tr></table></figure>
<p>从代码可以看出，manager queue是作为root queue与线程池之间的调度和管理者的，如：GCD Timer的实现就用到了管理队列</p>
<h5 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a>自定义队列</h5><p>使用<code>dispatch_queue_create</code>创建自定义队列，为方便阅读，只保留主要流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span></span><br><span class="line">_dispatch_queue_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t dqa,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(dqa)) &#123;</span><br><span class="line">		<span class="comment">// 如果没有传入dispatch_queue_attr_t，将其设置为默认参数</span></span><br><span class="line">		dqa = _dispatch_get_default_queue_attr();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;do_vtable != DISPATCH_VTABLE(queue_attr)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 获取要创建的队列的优先级</span></span><br><span class="line">	dispatch_qos_t qos = _dispatch_priority_qos(dqa-&gt;dqa_qos_and_relpri);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		<span class="comment">// 如果没有指定target queue, 将dispatch_root_queue赋值给tq</span></span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">		<span class="keyword">if</span> (slowpath(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqa-&gt;dqa_inactive || dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建dispatch_queue的vtable参数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	dispatch_queue_flags_t dqf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;dqa_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">	<span class="comment">// 根据上文的参数初始化队列</span></span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqa-&gt;dqa_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqa-&gt;dqa_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置label</span></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	<span class="comment">// 设置优先级</span></span><br><span class="line">	dq-&gt;dq_priority = dqa-&gt;dqa_qos_and_relpri;</span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_priority) &#123;</span><br><span class="line">		<span class="comment">// legacy way of inherithing the QoS from the target</span></span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqa-&gt;dqa_inactive) &#123;</span><br><span class="line">		_dispatch_queue_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// retain target queue，防止其提前释放</span></span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	<span class="comment">// 设置target queue</span></span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="comment">// 自省函数</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据传入的参数调用<code>_dispatch_queue_init</code>创建相应的串行或并行队列，然后设置label、队列优先级，并设置target queue为dispatch_root_queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">dq-&gt;do_targetq = tq;</span><br></pre></td></tr></table></figure>
<p>targetq的作用就是将push到queue中的任务（可能是任务也可能是queue）层层向上push，最终push到全局队列中，由全局队列调度线程池来执行任务（或者pop queue）。</p>
<blockquote>
<p>While custom queues are a powerful abstraction, all blocks you schedule on them will ultimately trickle down to one of the system’s global queues and its thread pool(s).</p>
</blockquote>
<blockquote>
<p>虽然自定义队列是一个强大的抽象，但你在队列上安排的所有Block最终都会渗透到系统的某一个全局队列及其线程池。</p>
</blockquote>
<h5 id="Runloop队列"><a href="#Runloop队列" class="headerlink" title="Runloop队列"></a>Runloop队列</h5><p>Runloop队列用于与线程绑定的队列的任务调度，比如主队列，看下main queue的wake up函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_main_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_is_thread_bound(dq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_queue_is_thread_bound</code>函数判断当前队列是否是与线程绑定的，由于主队列是绑定在主线程上的，这里就调用了<code>_dispatch_runloop_queue_wakeup</code>函数，由runloop queue将任务调度到主线程的runloop上，最终由主线程runloop在合适的时机执行。</p>
<h4 id="GCD-dispatch流程分析"><a href="#GCD-dispatch流程分析" class="headerlink" title="GCD dispatch流程分析"></a>GCD dispatch流程分析</h4><p>上一篇文章说过，<code>dispatch_queue_s</code>结构体中有<code>do_vtable</code>元素，这个<code>do_vtable</code>中包含了队列的push/wakeup/invoke/dispose等与dispatch相关的信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"main-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_main_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其它队列，如：manager queue、runloop queue、root queue等也有类似的vtable结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// manager queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_mgr, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_MGR_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"mgr-queue"</span>,</span><br><span class="line">	.do_push = _dispatch_mgr_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_mgr_thread,</span><br><span class="line">	.do_wakeup = _dispatch_mgr_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// runloop queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_runloop, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_RUNLOOP_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"runloop-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_runloop_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_runloop_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// root queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_root, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_GLOBAL_ROOT_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_pthread_root_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_root_queue_push,</span><br><span class="line">	.do_invoke = <span class="literal">NULL</span>,</span><br><span class="line">	.do_wakeup = _dispatch_root_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_push: 调用push操作将任务提交到queue上</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_continuation_push(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">   dx_vtable(dq)-&gt;do_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_wakeup: 当push任务到队列中时，会调用do_wakeup唤醒队列</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_queue_push_inline(<span class="built_in">dispatch_queue_t</span> dq, dispatch_object_t _tail,</span><br><span class="line">		dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *tail = _tail._do;</span><br><span class="line">	dispatch_wakeup_flags_t flags = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> dx_vtable(dq)-&gt;do_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_invoke: 在libdispatch中，do_invoke只在以下3种情况执行：1、任务出队；2、runloop queue出队；3、如果queue重写了invoke，则当queue元素出队时，调用<code>_dispatch_queue_override_invoke</code>，在<code>_dispatch_queue_override_invoke</code>函数中调用do_invoke。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 1.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(dispatch_object_t dou,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_pthread_root_queue_observer_hooks_t observer_hooks =</span><br><span class="line">			_dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">	_dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">	flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">	   <span class="comment">/// 调用invoke，执行任务</span></span><br><span class="line">		dx_invoke(dou._do, dic, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_root_queue_drain_deferred_wlh(dispatch_deferred_items_t ddi</span><br><span class="line">		DISPATCH_PERF_MON_ARGS_PROTO)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">retry:</span><br><span class="line">	dispatch_assert(ddi-&gt;ddi_wlh_needs_delete);</span><br><span class="line">	<span class="comment">// 出队一个任务块</span></span><br><span class="line">	_dispatch_trace_continuation_pop(rq, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_drain_try_lock_wlh(dq, &amp;dq_state)) &#123;</span><br><span class="line">	   <span class="comment">/// runloop queue出队一个元素，调用其invoke函数</span></span><br><span class="line">		dx_invoke(dq, &amp;dic, flags);</span><br><span class="line">		...</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3.</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(dispatch_continuation_t dc,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">	dispatch_priority_t old_dp;</span><br><span class="line">	voucher_t ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">	dispatch_object_t dou;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	_dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">		<span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">			dx_invoke(dou._do, dic, flags);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	_dispatch_reset_basepri(old_dp);</span><br><span class="line">	_dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了主队列，其他所有队列中提交的任务最终都要通过层层的target queue提交到root queue中（把queue整体提交到target queue中），从线程池中取出或新建一个线程执行：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_queue_class_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">		_dispatch_retain_2(dq);</span><br><span class="line">		flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">			<span class="built_in">dispatch_queue_t</span> tq;</span><br><span class="line">			<span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">				os_atomic_thread_fence();dependency</span><br><span class="line">				tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">						(<span class="keyword">long</span>)new_state);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tq = target;</span><br><span class="line">			&#125;</span><br><span class="line">			dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">			<span class="comment">// 将queue提交到它的target queue中</span></span><br><span class="line">			<span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">		&#125;</span><br><span class="line">      ...</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么队列的dispatch的大致流程如下所示：</p>
<p>提交任务到queue -&gt; 调用push将任务入队 -&gt; 调用wakeup唤醒队列 -&gt; 如果有target queue，往上提交，直到root queue为止 -&gt; 由root queue从线程池中取出或创建一个新线程执行任务。</p>
<p>主队列的dispatch流程与上述略有不同，提交到主队列的任务由GCD内部的runloop queue管理并最终由主线程的runloop执行。</p>
<h5 id="dispatch-async分析"><a href="#dispatch-async分析" class="headerlink" title="dispatch_async分析"></a>dispatch_async分析</h5><p>先看下主队列上的异步任务。</p>
<h6 id="主队列的dispatch-async"><a href="#主队列的dispatch-async" class="headerlink" title="主队列的dispatch_async"></a>主队列的dispatch_async</h6><p>如果我们想在主线程中执行一个异步操作，通常的做法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch async in main queue"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述这段代码在libdispatch内部的流程如下：</p>
<p>1、将传入的block任务转换成一个<code>dispatch_continuation_t</code>类型的结构体对象，然后调用<code>_dispatch_continuation_async</code>将continuation push到main queue中。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 分配空间</span></span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line">   <span class="comment">// block转换成dispatch_continuation对象</span></span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">	   <span class="comment">// 将任务push到main queue中</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在libdispatch源码中能经常见到fastpath、slowpath、likely、unlikely等宏，编写这些宏的目的是告诉编译器来对我们的代码进行优化，通常：</p>
<ul>
<li>fastpath/likely 表示条件更可能成立</li>
<li>slowpath/unlikely 表示条件更不可能成立</li>
</ul>
<p>2、唤醒main queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_continuation_push(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">   dx_vtable(dq)-&gt;do_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上文说过main queue的vtable存储了push/wakeup/invoke等信息，上述代码实际上是调用了_dispatch_queue_push</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_queue_push_inline(<span class="built_in">dispatch_queue_t</span> dq, dispatch_object_t _tail,</span><br><span class="line">		dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这里调用queue的wakeup函数</span></span><br><span class="line">	<span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、wakeup runloop queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_main_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_is_thread_bound(dq)) &#123;</span><br><span class="line">	   <span class="comment">// 这里是判断queue是否与与线程绑定，main queue的wake up命中判断，唤醒runloop queue.</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_runloop_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">	   <span class="comment">// 判断队列中是否有任务，如果有，执行runloop queue poke操作</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_poke(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、唤醒主线程，并注册回调函数，由mach内核在合适的时机执行<code>_dispatch_main_queue_drain</code>操作</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_class_poke(<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_runloop_handle_t handle = _dispatch_runloop_queue_get_handle(dq);</span><br><span class="line">	<span class="keyword">if</span> (!_dispatch_runloop_handle_is_valid(handle)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if HAVE_MACH</span></span><br><span class="line">	mach_port_t mp = handle;</span><br><span class="line">	kern_return_t kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">switch</span> (kr) &#123;</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		(<span class="keyword">void</span>)dispatch_assume_zero(kr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#error <span class="meta-string">"runloop support not implemented on this platform"</span></span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_main_queue_callback_4CF(</span><br><span class="line">		<span class="keyword">void</span> *ignored DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (main_q_is_draining) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">true</span>);</span><br><span class="line">	_dispatch_main_queue_drain();</span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、执行<code>_dispatch_continuation_pop_inline</code>函数，如果主队列中有未完成的任务，将任务出队并执行。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_main_queue_drain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);</span><br><span class="line">		_dispatch_continuation_pop_inline(dc, &amp;dic, DISPATCH_INVOKE_NONE, dq);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(dispatch_object_t dou,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">		dx_invoke(dou._do, dic, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，主队列的dispatch_async流程执行完毕，其实我们在xcode断点时的堆栈信息也能窥探一二。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/3.png" alt="dispatch_async(dispatch_main_queue)的调用栈"></p>
<h6 id="自定义队列-全局队列上的dispatch-async"><a href="#自定义队列-全局队列上的dispatch-async" class="headerlink" title="自定义队列/全局队列上的dispatch_async"></a>自定义队列/全局队列上的dispatch_async</h6><p>示例代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、自定义串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> customSerialQueue = dispatch_queue_create(<span class="string">"com.gcd.queue.custom"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(customSerialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customSerialQueue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、自定义并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> customConcurrentQueue = dispatch_queue_create(<span class="string">"com.gcd.queue.custom"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(customConcurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customConcurrentQueue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3、全局队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customGlobalQueue task"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>自定义创建的并行队列比其他队列（串行队列和全局队列）多了一个redirection流程</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 判断是否需要redirection，如果不需要，将任务入队</span></span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行redirection流程</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>DISPATCH_QUEUE_USES_REDIRECTION</code>这个宏是用来判断queue是否需要redirection，如果<code>dq_width</code>满足<code>width &gt; 1 &amp;&amp; width &lt; 0xfff</code>条件，则队列需要热direction。串行队列(<code>dq_width</code> = 1)和全局队列(<code>dq_width</code> = 0xfff)都不满足上述条件，无需direction。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/4.png" alt="queue width"></p>
<p>redirection：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f_redirect(<span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_object_t dou, dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(_dispatch_object_is_redirection(dou))) &#123;</span><br><span class="line">		dou._dc = _dispatch_async_redirect_wrap(dq, dou);</span><br><span class="line">	&#125;</span><br><span class="line">	dq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the queue to redirect to</span></span><br><span class="line">	<span class="keyword">while</span> (slowpath(DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!fastpath(_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		dq = dq-&gt;do_targetq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>redirection操作的目的就是要将任务最终push到root queue中。</p>
<p>对于无需redirection的队列，调用其push函数，将任务push到队列中，分两种情况：</p>
<ul>
<li>普通的自定义队列：如果queue有target_queue，调用<code>_dispatch_queue_push_queue</code>，将queue层层向上push到target_queue中，最终push到root queue中。</li>
<li>全局队列：由于全局队列(root queue)没有target_queue，调用<code>_dispatch_root_queue_push</code>直接把任务push到root queue中。</li>
</ul>
<p>最终，所有提交到非主队列的任务都push到了root queue中，由root queue调度线程池并分配线程执行。 </p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// root queue线程池管理相关</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_global_queue_poke_slow(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> floor)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_root_queue_context_t qc = dq-&gt;do_ctxt;</span><br><span class="line">	<span class="keyword">int</span> remaining = n;</span><br><span class="line">	<span class="keyword">int</span> r = ENOSYS;</span><br><span class="line"></span><br><span class="line">	_dispatch_root_queues_init();</span><br><span class="line">	_dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">...</span><br><span class="line"><span class="meta">#if DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">	dispatch_pthread_root_queue_context_t pqc = qc-&gt;dgq_ctxt;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(pqc-&gt;dpq_thread_mediator.do_vtable)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (dispatch_semaphore_signal(&amp;pqc-&gt;dpq_thread_mediator)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"signaled sleeping worker for "</span></span><br><span class="line">					<span class="string">"global queue: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">if</span> (!--remaining) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> overcommit = dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	<span class="keyword">if</span> (overcommit) &#123;</span><br><span class="line">		os_atomic_add2o(qc, dgq_pending, remaining, relaxed);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!os_atomic_cmpxchg2o(qc, dgq_pending, <span class="number">0</span>, remaining, relaxed)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"worker thread request still pending for "</span></span><br><span class="line">					<span class="string">"global queue: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int32_t can_request, t_count;</span><br><span class="line">	<span class="comment">// seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt;</span></span><br><span class="line">	t_count = os_atomic_load2o(qc, dgq_thread_pool_size, ordered);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		can_request = t_count &lt; floor ? <span class="number">0</span> : t_count - floor;</span><br><span class="line">		<span class="keyword">if</span> (remaining &gt; can_request) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"pthread pool reducing request from %d to %d"</span>,</span><br><span class="line">					remaining, can_request);</span><br><span class="line">			os_atomic_sub2o(qc, dgq_pending, remaining - can_request, relaxed);</span><br><span class="line">			remaining = can_request;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"pthread pool is full for root queue: "</span></span><br><span class="line">					<span class="string">"%p"</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!os_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">			t_count - remaining, &amp;t_count, acquire));</span><br><span class="line"></span><br><span class="line">	pthread_attr_t *attr = &amp;pqc-&gt;dpq_thread_attr;</span><br><span class="line">	pthread_t tid, *pthr = &amp;tid;</span><br><span class="line"><span class="meta">#if DISPATCH_USE_MGR_THREAD &amp;&amp; DISPATCH_ENABLE_PTHREAD_ROOT_QUEUES</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq == &amp;_dispatch_mgr_root_queue)) &#123;</span><br><span class="line">		pthr = _dispatch_mgr_root_queue_init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_retain(dq); <span class="comment">// released in _dispatch_worker_thread</span></span><br><span class="line">		<span class="keyword">while</span> ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">				(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_temporary_resource_shortage();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (--remaining);</span><br><span class="line"><span class="meta">#endif // DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么root queue是如何出队的呢？上述代码的do-while循环中调用了<code>pthread_create</code>创建新的线程，并将线程运行函数起始地址指向<code>_dispatch_worker_thread</code>，那么线程创建后会执行<code>_dispatch_worker_thread</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_dispatch_worker_thread(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_root_queue_drain(dq, old_pri);</span><br><span class="line">		_dispatch_reset_priority_and_voucher(old_pri, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dispatch_semaphore_wait(&amp;pqc-&gt;dpq_thread_mediator,</span><br><span class="line">			dispatch_time(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">	_dispatch_global_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="built_in">dispatch_queue_t</span> dq, pthread_priority_t pp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">		_dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">		reset = _dispatch_reset_basepri_override();</span><br><span class="line">		<span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	_dispatch_last_resort_autorelease_pool_pop(&amp;dic);</span><br><span class="line"><span class="meta">#endif // DISPATCH_COCOA_COMPAT</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_dispatch_worker_thread</code>中进行drain root queue，将root queue中的元素一个个出队，元素出队时调用<code>_dispatch_continuation_pop_inline</code>，触发队元素的<code>.do_invoke</code>，执行任务。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>整理一下dispatch_async的流程：</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/5.png" alt="dispatch_async流程"></p>
<h4 id="dispatch-sync分析"><a href="#dispatch-sync分析" class="headerlink" title="dispatch_sync分析"></a>dispatch_sync分析</h4><p>dispatch_sync的流程与上文分析的大同小异，一般来说同步任务是在当前线程中执行，同时它会阻塞当前线程直到任务执行完毕。</p>
<ul>
<li>当queue时串行队列时，当前线程会获取lock，如果成功则执行任务，否则出发crash，比如</li>
</ul>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/6.png" alt="dispatch_sync死锁"></p>
<ul>
<li>当queue是并行队列时，会直接执行任务。</li>
</ul>
<p>关于dispatch_sync的流程不详细分析了，这里重点关注一下lock机制以及引起死锁的情形。</p>
<p><code>dispatch_sync_f</code>函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">	   <span class="comment">// 串行队列</span></span><br><span class="line">		<span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dq))) &#123;</span><br><span class="line">	   <span class="comment">// 全局队列</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">	   <span class="comment">// 多重队列，寻找最终的targetq，最终还是会回到该函数中</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行队列中的任务</span></span><br><span class="line">	_dispatch_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取队列的lock"><a href="#获取队列的lock" class="headerlink" title="获取队列的lock"></a>获取队列的lock</h5><p><code>dispatch_sync_f</code>函数中，如果是串行队列，执行<code>dispatch_barrier_sync_f</code>，一步步往下执行，会看到lock相关的函数：<code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code>。</p>
<p>使用宏替换后的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync_and_suspend(<span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		uint32_t tid, uint64_t suspend_count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 根据queue的width初始化init</span></span><br><span class="line">	uint64_t init  = DISPATCH_QUEUE_STATE_INIT_VALUE(dq-&gt;dq_width);</span><br><span class="line">	<span class="comment">// _dispatch_lock_value_from_tid获取传入tid的第3到32位，mask为0xfffffffc</span></span><br><span class="line">	uint64_t value = DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |</span><br><span class="line">			_dispatch_lock_value_from_tid(tid) |</span><br><span class="line">			(suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL);</span><br><span class="line">	uint64_t old_state, new_state;</span><br><span class="line">	<span class="keyword">bool</span> _result = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">typeof</span>(&amp;(dq)-&gt;dq_state) _p = &amp;(dq)-&gt;dq_state;</span><br><span class="line">	<span class="comment">// 原子操作，获取queue的dq_state并赋值给old_state</span></span><br><span class="line">	old_state = os_atomic_load(_p, relaxed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		uint64_t role = old_state &amp; DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">		<span class="keyword">if</span> (old_state != (init | role)) &#123;</span><br><span class="line">			<span class="comment">// 如果old_state与(init | role)值不相等，说明queue的dq_state被改变，当前有thread持有该queue,</span></span><br><span class="line">			<span class="comment">// 终止循环并直接返回false</span></span><br><span class="line">			os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		new_state = value | role;</span><br><span class="line"></span><br><span class="line">		_os_atomic_basetypeof(_p) _r = old_state; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断old_state是否等于new_state, </span></span><br><span class="line">		<span class="comment">// 如果相等，获取lock成功，置db.dq_state为new_state，并返回true</span></span><br><span class="line">		<span class="comment">// 否则，获取lock失败，结束循环，返回false</span></span><br><span class="line">		_Bool _b = atomic_compare_exchange_weak_explicit(_os_atomic_c11_atomic(_p), &amp;_r, new_state, memory_order_acquire, memory_order_relaxed); </span><br><span class="line">		old_state = _r;</span><br><span class="line">		_result = _b;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (os_unlikely(!_result));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，libdispatch通过一些原子操作来比较queue.dq_state的值来实现lock操作：</p>
<p>1、如果dq_state为初始值(<code>init | role</code>)，说明当前queue没有被任何线程lock，则lock成功并设置dq_state为(<code>value | role</code>)；<br>2、否则lock失败，返回false。</p>
<p>线程获取到queue的lock后，queue.dq_state中同时也记录了当前持有lock的线程的tid信息。</p>
<p>再返回到上一级函数<code>dispatch_barrier_sync_f</code>中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_barrier_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fastpath, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fastpath, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dq, tid))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_queue_barrier_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当lock失败后，进入到<code>_dispatch_sync_f_slow</code>等待上一个任务执行完成：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_wait(<span class="built_in">dispatch_queue_t</span> top_dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t top_dc_flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_priority_t pp = _dispatch_get_priority();</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line">	dispatch_qos_t qos;</span><br><span class="line">	uint64_t dq_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 死锁检测部分</span></span><br><span class="line">	<span class="comment">// 获取当前queue的dq_state</span></span><br><span class="line">	dq_state = _dispatch_sync_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, tid))) &#123;</span><br><span class="line">		<span class="comment">// 如果当前queue已经被当前thread持有，引起死锁，触发crash</span></span><br><span class="line">		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> dispatch_sync_context_s dsc = &#123;</span><br><span class="line">		.dc_flags    = dc_flags | DISPATCH_OBJ_SYNC_WAITER_BIT,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = DISPATCH_NO_VOUCHER,</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = tid,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将任务入队</span></span><br><span class="line">	_dispatch_queue_push_sync_waiter(dq, &amp;dsc, qos);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待之前的任务执行完毕</span></span><br><span class="line">	<span class="keyword">if</span> (dsc.dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">		<span class="comment">// 信号量等待，semaphore_wait(dsc.dsc_event-&gt;dte_sema)</span></span><br><span class="line">		_dispatch_thread_event_wait(&amp;dsc.dsc_event); <span class="comment">// acquire</span></span><br><span class="line">		<span class="comment">// 销毁信号量，结束等待，semaphore_destroy(mach_task_self(), dsc.dsc_event-&gt;dte_sema)</span></span><br><span class="line">		_dispatch_thread_event_destroy(&amp;dsc.dsc_event);</span><br><span class="line">		<span class="comment">// If _dispatch_sync_waiter_wake() gave this thread an override,</span></span><br><span class="line">		<span class="comment">// ensure that the root queue sees it.</span></span><br><span class="line">		<span class="keyword">if</span> (dsc.dsc_override_qos &gt; dsc.dsc_override_qos_floor) &#123;</span><br><span class="line">			_dispatch_set_basepri_override_qos(dsc.dsc_override_qos);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 等待owner释放</span></span><br><span class="line">		_dispatch_event_loop_wait_for_ownership(&amp;dsc);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终调用_dispatch_sync_function_invoke_inline，执行任务</span></span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h5><p>死锁的产生必须满足四个必要条件：</p>
<ul>
<li>资源互斥访问</li>
<li>请求与保持</li>
<li>不剥夺</li>
<li>循环等待</li>
</ul>
<p>libdispatch中创建并分配线程来执行任务块的过程中，线程/队列对资源的操作满足上述前三个条件，那么如果再满足第四个条件，必然会发生死锁。</p>
<p>在GCD中满足两个条件即会形成循环等待的情形：</p>
<ul>
<li><strong>串行队列</strong>正在执行任务Task 1（无论是sync还是async方式提交的）</li>
<li>Task 1未执行完成，又向队列中同步提交Task 2（<strong>dispatch_sync</strong>方式提交）</li>
</ul>
<p>死锁的示例代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQ = dispatch_queue_create(<span class="string">"com.testqueue.serial"</span>, DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 2."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQ, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 2."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 两种情况输出一样：</span></span><br><span class="line">Task <span class="number">1</span> begin.</span><br><span class="line"><span class="comment">// 并且发生crash, xcode提示：Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</span></span><br></pre></td></tr></table></figure>
<p>新版libdispatch中引入了死锁检测机制，发生死锁时，主动触发程序crash，并定位到引起死锁的代码，降低了调试难度。</p>
<p>死锁检测相关的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dq_state = _dispatch_sync_wait_prepare(dq);</span><br><span class="line"><span class="keyword">if</span> (unlikely(_dispatch_lock_is_locked_by(dq_state, tid))) &#123;</span><br><span class="line">    <span class="comment">// 如果当前queue已经被当前thread持有，引起死锁，触发crash</span></span><br><span class="line">	DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看到，libdispatch是通过<code>(dq_state ^ tid) &amp; DLOCK_OWNER_MASK</code>这句代码判断dq是否被某个线程持有，而dq.dq_state中存有持有它的线程的tid信息，如果对应tid的线程持有了dq，则返回true，说明当前线程已持有dq，循环等待条件成立，产生死锁，否则返回false。</p>
<p>那么问题来了，如果在thread_A中提交Task1，在Task1还在执行时，在thread_B中同步提交Task2会发生什么情况呢，GCD能否检测出死锁呢？</p>
<p>测试代码中为了避开主线程死锁对测试的干扰，采用dispatch_async方式提交Task1。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.testqueue.serial"</span>, DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL);</span><br><span class="line">    <span class="comment">// 为了避免主线程的死锁，干扰测试结果，这里使用dispatch_async方式提交Task1.</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Task 2 begin."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main queue task complete."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test[<span class="number">73008</span>:<span class="number">2443797</span>] main queue complete.</span><br><span class="line">Test[<span class="number">73008</span>:<span class="number">2443854</span>] Task <span class="number">1</span> begin.</span><br></pre></td></tr></table></figure>
<p>此时程序卡住并没有crash，xcode也并未提示任何crash信息。</p>
<p>这说明了libdispatch死锁检测机制的问题：它只针对在同一个线程中向串行队列同步提交任务的情况。如果Task 2是在其它线程中同步提交的，它就无法检测出来了。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>本文只是粗略地分析了GCD的queue、dispatch过程以及queue和线程之间的调度关系，libdispatch源码的繁杂远远不止于此，细节之处还有如：mach_port通信、线程tsd、runloop callback、系统内核(libkern)交互等等，同时还有一些提升程序性能的编程技巧等（libdispatch为了最大限度地提升性能，大量使用了原子操作而非<code>pthread_mutex_lock</code>、<code>OSSpinLock/OSUnfairLock</code>等锁来实现同步）。感兴趣的同学可以把源码下载下来仔细阅读一下。</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>


<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Cui Lanqing">
  <!-- Open Graph Data -->
  <meta property="og:title" content="OC中Block内存结构以及copy/持有外部变量等操作的实现原理分析"/>
  <meta property="og:description" content="一枚有梦想的程序猿" />
  <meta property="og:site_name" content="崔岚清的个人博客"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="崔岚清的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>崔岚清的个人博客</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-light.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">OC中Block内存结构以及copy/持有外部变量等操作的实现原理分析</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Cui Lanqing</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-11-16</span>
            <span class="time">16:34:48</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/iOS开发/">iOS开发</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Objective-C-Runtime-Block/">#Objective-C, Runtime, Block</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近对App中的埋点代码进行了改造（随着项目的增大，散落在系统各处的埋点代码实在不好管理），利用AOP的方式将散布在各个页面中的埋点代码统一起来组成一个独立的模块，从而减少埋点行为对业务代码的侵入。</p>
<p>熟悉iOS AOP编程的同学肯定听过<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>这个框架，我们也使用这个框架实现Method Swizzle，通过Method Swizzle给指定的方法添加side-effect，在side-effect中做相应的埋点上报操作。</p>
<p>在学习Aspects源码的过程中，对Runtime以及OC的消息转发机制有了一个深入的了解，写几篇文章记录一下，文章中会穿插一些对于Aspect源码的分析内容，如有错误的地方，欢迎大家斧正。</p>
<h3 id="二、Block-Memory-Layout"><a href="#二、Block-Memory-Layout" class="headerlink" title="二、Block Memory Layout"></a>二、Block Memory Layout</h3><p>Everything hides in the source code: <a href="https://opensource.apple.com/source/libclosure/libclosure-67/" target="_blank" rel="noopener">libclosure-67</a></p>
<p>block的本质可以看做一个函数，这点从它的定义可以看出来（Block_private.h）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">    int32_t reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">    <span class="comment">// 捕获的外部变量，block将外部变量复制到结构体中，因此block内部可以访问到其外部的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_1 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_2 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_3 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>逐条分析： </p>
<ul>
<li><code>void *isa</code>: oc中的所有对象都有该指针，指向其所属的类。oc对象接收到消息后，根据isa指针找到其所属的类，然后获取存储在类中的property_list、method_list等信息，然后进行下一步的操作；</li>
<li><code>volatile int32_t flags</code>: 标识位，block内部操作时会用到，比如copy、dispose等，其中包含了block的reference count、是否heap block等信息；</li>
<li><code>int32_t reserved</code>: 保留变量</li>
<li><code>void (*invoke)(void *, ...)</code>: 函数指针，指向block的实现函数地址；</li>
<li><code>struct Block_descriptor_1 *descriptor</code>: 附加描述信息，存储了一些如block大小、copy/dispose函数指针、签名（用于构造方法签名）等信息。</li>
</ul>
<p><strong>Aspects源码截取：构造blockMethodSignature</strong></p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化desc指针，指向block的descriptor结构体起始地址</span></span><br><span class="line"><span class="keyword">void</span> *desc = layout-&gt;descriptor;</span><br><span class="line"><span class="comment">// 2. 移动指针，跳过reserved、size变量</span></span><br><span class="line">desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 3. 判断是否有copy/dispose信息，如果有，移动desc指针，跳过copy/dispose指针变量</span></span><br><span class="line"><span class="keyword">if</span> (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">	desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 移动后的指针应该指向block的signature信息，判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't has a type signature."</span>, block];</span><br><span class="line">    AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 指针不为空，取出signature指针，构造methodSignature</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br></pre></td></tr></table></figure>
<p>在Block_private.h中还能看到如下信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block_private.h</span></span><br><span class="line"><span class="comment">// the raw data space for runtime classes for blocks</span></span><br><span class="line"><span class="comment">// class+meta used for stack, malloc, and collectable based blocks</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteMallocBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteAutoBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteFinalizingBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteWeakBlockVariable[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"><span class="comment">// declared in Block.h</span></span><br><span class="line"><span class="comment">// BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];</span></span><br><span class="line"><span class="comment">// BLOCK_EXPORT void * _NSConcreteStackBlock[32];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block.h</span></span><br><span class="line"><span class="comment">// Used by the compiler. Do not use these variables yourself.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteGlobalBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteStackBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>
<p>从其命名方式：Global/Stack(栈)/Malloc(堆)可以推测出Block的类型：NSGlobalBlock（全局Block）、NSStackBlock（栈区Block）、NSMallocBlock（堆区Block）。下面结合代码分别分析一下这三种block。</p>
<h4 id="2-1-NSGlobalBlock"><a href="#2-1-NSGlobalBlock" class="headerlink" title="2.1 NSGlobalBlock"></a>2.1 NSGlobalBlock</h4><p>我们知道，程序中的全局变量存储在内存中的数据区（.data区），这块内存中的内容在编译期就已经完全确定了。因此，这种Block无法捕捉任何变量，也无需任何运行时状态来参与运行。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^TestBlock)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *str = <span class="string">@"static test str"</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    TestBlock block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"innner block"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block address:%@"</span>, block);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"static string address:%p"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">innner block</span><br><span class="line">block address:&lt;__NSGlobalBlock__: <span class="number">0x10428a080</span>&gt;</span><br><span class="line"><span class="keyword">static</span> string address:<span class="number">0x104290908</span></span><br></pre></td></tr></table></figure>
<p>可以看出，NSGlobalBlock的存储区域与静态变量的地址相近，二者都存储于全局数据区。</p>
<h4 id="2-2-NSStackBlock和NSMallocBlock"><a href="#2-2-NSStackBlock和NSMallocBlock" class="headerlink" title="2.2 NSStackBlock和NSMallocBlock"></a>2.2 NSStackBlock和NSMallocBlock</h4><ul>
<li>MRC下，无论是对于作为函数临时变量的block和对象属性的block，都默认存储在栈区，其生命周期随着变量作用域结束而结束，如果想要保留block，可以显示调用copy方法将block拷贝到堆中。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    TestBlock stackBlock = ^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line">    stackBlock();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"stack block address: %@"</span>, stackBlock);</span><br><span class="line">    </span><br><span class="line">    TestBlock heapBlock = [^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line">    heapBlock();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"heap block address: %@"</span>, heapBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">stack block address: &lt;__NSStackBlock__: <span class="number">0x7ffeeeeeb970</span>&gt;</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">heap block address: &lt;__NSMallocBlock__: <span class="number">0x6000017bbfc0</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>ARC下，由于编译期会隐式地为非全局block添加copy操作，因此所有的非全局block都存储于堆区。这个copy操作属于深拷贝，将block拷贝到堆中，这个拷贝的block对象强引用它捕获的变量，因此ARC下要注意block的隐式copy引起的retain cycle问题。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"heap block address: %@"</span>, block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">heap block address: &lt;__NSMallocBlock__: <span class="number">0x60000221eb50</span>&gt;</span><br></pre></td></tr></table></figure>
<p>因此，MRC下block有三种：NSGlobalBlock、NSStackBlock、NSMallocBlock，<br>而ARC下由于编译器隐式添加copy操作，只有两种block：NSGlobalBlock、NSMallocBlock。</p>
<h3 id="三、Block持有外部变量分析"><a href="#三、Block持有外部变量分析" class="headerlink" title="三、Block持有外部变量分析"></a>三、Block持有外部变量分析</h3><p>上一节中说过block结构体中有专门存放捕获的变量的区域，那么block是如何捕获到外部变量的呢？分几种情况分析。</p>
<h4 id="3-1-block持有非-block修饰的基本类型变量"><a href="#3-1-block持有非-block修饰的基本类型变量" class="headerlink" title="3.1 block持有非__block修饰的基本类型变量"></a>3.1 block持有非__block修饰的基本类型变量</h4><p>先看代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, j address: %p"</span>, &amp;j);</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, j address: %p"</span>, &amp;j);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, j address: %p"</span>, &amp;j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">before block, j address: <span class="number">0x7ffee08849bc</span></span><br><span class="line">inner block, j address: <span class="number">0x600000dac080</span></span><br><span class="line">after block, j address: <span class="number">0x7ffee08849bc</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看出，打印变量j的地址，before block和after block的地址相同，且二者与block内部的地址不同。（ARC和MRC下，输出的结果一样）</p>
<h5 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h5><p>使用<code>clang -rewrite-objc</code>命令重写.m文件，只选取关键代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, <span class="keyword">int</span> _j, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> j = __cself-&gt;j; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_1, &amp;j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_0, &amp;j);</span><br><span class="line"></span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, j));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_2, &amp;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>__TestObject__testBlock_block_impl_0</code>是testBlock的实现，包含了一个isa指针（本例中它指向NSConcreteStackBlock, 说明这个block是分配在栈上的）、一个impl函数指针（本例中它指向<code>__TestObject__testBlock_block_func_0</code>）、一个Desc结构体指针，从block的实现来看，捕获到的外部变量会追加到Desc指针后面，使得<code>__TestObject__testBlock_block_impl_0</code>结构体变大。</p>
<p>从<code>__TestObject__testBlock_block_func_0</code>中可以看到：<code>int j = __cself-&gt;j; // bound by copy</code>这样一句代码，block将捕获的外部变量复制一份到其内部，这也说明了为什么block内部打印的变量j的地址与外部不一致。</p>
<h4 id="3-2-block持有-block修饰的基本类型变量"><a href="#3-2-block持有-block修饰的基本类型变量" class="headerlink" title="3.2 block持有__block修饰的基本类型变量"></a>3.2 block持有__block修饰的基本类型变量</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, j address: %p"</span>, &amp;j);</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, j address: %p"</span>, &amp;j);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, j address: %p"</span>, &amp;j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line">before block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line">inner block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line">after block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line">before block, j address: <span class="number">0x7ffeeea309a8</span></span><br><span class="line">inner block, j address: <span class="number">0x600000c54558</span></span><br><span class="line">after block, j address: <span class="number">0x600000c54558</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看到，MRC下，block前后和block内部打印的变量j的地址都相同，而且都是存在于栈中；ARC下，由于block的隐式copy操作，block内部和block执行后打印变量j的地址是在堆中，而block之前的地址是在栈中。</p>
<h6 id="分析原因-1"><a href="#分析原因-1" class="headerlink" title="分析原因"></a>分析原因</h6><p>使用clang重写oc代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_j_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_j_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_j_0 *j; <span class="comment">// by ref</span></span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, __Block_byref_j_0 *_j, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_j_0 *j = __cself-&gt;j; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_1, &amp;(j-&gt;__forwarding-&gt;j));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;j, (<span class="keyword">void</span>*)src-&gt;j, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;j, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_j_0 j = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_j_0 *)&amp;j, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_j_0), <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_0, &amp;(j.__forwarding-&gt;j));</span><br><span class="line"></span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, (__Block_byref_j_0 *)&amp;j, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_2, &amp;(j.__forwarding-&gt;j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，block内部除了<code>isa</code>指针、<code>impl</code>函数指针、<code>Desc</code>指针外，增加了一个<code>__Block_byref_j_0</code>类型的结构体指针，block捕获的外部变量由该结构体管理，block通过持有该结构体指针实现了对外部变量修改的目的。而且<code>__TestObject__testBlock_block_desc_0</code>中新增了copy和dispose两个函数指针，用于实现对<code>__Block_byref_j_0</code>结构体的内存管理。</p>
<p><code>__Block_byref_j_0</code>结构体中包含了：</p>
<ul>
<li>isa指针: 指向该__block变量的类型，本例中是基本数据类型，因此，isa指针为<code>(void *)0</code>；</li>
<li>forwarding指针: 指向该结构体，用于取值；</li>
<li>flags: 标识位，对于基本数据类型该值为0，对于对象类型该值为3554432；</li>
<li>size: 该结构体的大小；</li>
<li>j: 不同的捕获变量，该值命名类型不同，本例中用于储存捕获的整型变量的值；</li>
</ul>
<p>在block内部和block前后读写变量j的值，都是读取或修改<code>j-&gt;__forwarding-&gt;j</code>或者<code>j.__forwarding-&gt;j</code>的值，由于block内外获取到的<code>__forwarding</code>指针指向同一结构体地址，因此使得block内部修改变量影响到了block外部。</p>
<h4 id="3-3-block持有-block修饰的对象"><a href="#3-3-block持有-block修饰的对象" class="headerlink" title="3.3 block持有__block修饰的对象"></a>3.3 block持有__block修饰的对象</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block ObjectA *blockObj = [[ObjectA alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, blockObj address: %p, obj pointer address: %p"</span>, blockObj,  &amp;blockObj);</span><br><span class="line">    TestBlock block = ^ &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, blockObj address: %p, obj pointer address: %p"</span>, blockObj, &amp;blockObj);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, blockObj address: %p, obj pointer address: %p"</span>, blockObj, &amp;blockObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line">before block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line">inner block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line">after block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line">before block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x7ffee4d8e9a8</span></span><br><span class="line">inner block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x600002431318</span></span><br><span class="line">after block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x600002431318</span></span><br></pre></td></tr></table></figure>
<p>可以看到，无论是MRC或者ARC下，blockObj对象的地址都不变，在堆中；MRC下，blockObj对象的指针地址不变，在栈中；而ARC下，blockObj对象的指针地址在copy之后发生了变化，指针从栈中拷贝到了堆中。</p>
<p><strong>这也说明了block对其持有的对象的copy操作只是浅拷贝，拷贝的是指针，而指针指向的对象始终存在于堆中的某个区域</strong></p>
<h5 id="分析原因-2"><a href="#分析原因-2" class="headerlink" title="分析原因"></a>分析原因</h5><p>使用clang重写</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_blockObj_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockObj_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> ObjectA *blockObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_blockObj_0 *blockObj; <span class="comment">// by ref</span></span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, __Block_byref_blockObj_0 *_blockObj, <span class="keyword">int</span> flags=<span class="number">0</span>) : blockObj(_blockObj-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_blockObj_0 *blockObj = __cself-&gt;blockObj; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_1, &amp;(blockObj-&gt;__forwarding-&gt;blockObj));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;blockObj, (<span class="keyword">void</span>*)src-&gt;blockObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;blockObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_blockObj_0 blockObj = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_blockObj_0 *)&amp;blockObj, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_blockObj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((ObjectA *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((ObjectA *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"ObjectA"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_0, &amp;(blockObj.__forwarding-&gt;blockObj));</span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, (__Block_byref_blockObj_0 *)&amp;blockObj, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_2, &amp;(blockObj.__forwarding-&gt;blockObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上例的结构基本相同，不同的是<code>__Block_byref_blockObj_0</code>结构体中增加了copy、dispose两个函数指针用于实现block持有对象的内存管理，<code>__Block_byref_blockObj_0</code>持有的是捕获对象的指针。</p>
<h4 id="3-4-block持有类的属性"><a href="#3-4-block持有类的属性" class="headerlink" title="3.4 block持有类的属性"></a>3.4 block持有类的属性</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, str value: %@"</span>, _str);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, str address: %p"</span>, &amp;_str);</span><br><span class="line">    TestBlock block = ^ &#123;</span><br><span class="line">        _str = <span class="string">@"block str"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, str value: %@"</span>, _str);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, str address: %p"</span>, &amp;_str);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, str value: %@"</span>, _str);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, str address: %p"</span>, &amp;_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC和ARC</span></span><br><span class="line">before block, str value: init string.</span><br><span class="line">before block, str address: <span class="number">0x6000004c23b8</span></span><br><span class="line">inner block, str value: block str</span><br><span class="line">inner block, str address: <span class="number">0x6000004c23b8</span></span><br><span class="line">after block, str value: block str</span><br><span class="line">after block, str address: <span class="number">0x6000004c23b8</span></span><br></pre></td></tr></table></figure>
<p>MRC和ARC下，block内外打印的对象地址相同，且不需要<code>__block</code>修饰，block也能捕获并修改类的属性。</p>
<h5 id="分析原因-3"><a href="#分析原因-3" class="headerlink" title="分析原因"></a>分析原因</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  TestObject *<span class="keyword">self</span>;</span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, TestObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  TestObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)) = (<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_3;</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_4, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_5, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_1, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_2, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_6, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_7, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，构建block结构体时，其内部持有的是该类的实例对象：<code>TestObject *self</code>。而在创建block时，传入的是类的当前的实例对象self：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>
<p>因此，block内部持有的实际上是self，在读取和修改类的属性时，使用的实际上是</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str))</span><br></pre></td></tr></table></figure>
<p>所以，无需<code>__block</code>修饰，block也能修改类的属性，而且无论在MRC还是ARC下，打印的属性地址都是堆中的某个区域（基本类型的属性不同，是在栈中）。</p>
<h3 id="四、Block-copy过程以及导致retain-cycle的原因分析"><a href="#四、Block-copy过程以及导致retain-cycle的原因分析" class="headerlink" title="四、Block copy过程以及导致retain cycle的原因分析"></a>四、Block copy过程以及导致retain cycle的原因分析</h3><p>ARC下，为了延长分配在栈中block的生命周期，编译期会对非全局block默认加copy操作，将其copy到堆中。对于基本数据类型，copy一份到堆中，对于对象类型变量，copy其指针到堆中。而我们常说的block的循环引用就是这个copy操作导致的，那么为什么block的copy操作会导致某些情况下的循环引用呢？下面通过源码分析一下。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libclosure-67/Block_private.h</span></span><br><span class="line"><span class="comment">// Values for Block_layout-&gt;flags to describe block objects</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libclosure-67/runtime.c</span></span><br><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_layout *aBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            int32_t old_value = aBlock-&gt;flags;</span><br><span class="line">            <span class="keyword">if</span> ((old_value &amp; BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OSAtomicCompareAndSwapInt(old_value, old_value+<span class="number">2</span>, &amp;aBlock-&gt;flags)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="keyword">struct</span> Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);</span><br><span class="line">        <span class="keyword">if</span> (!desc) <span class="keyword">return</span>;</span><br><span class="line">        (*desc-&gt;<span class="keyword">copy</span>)(result, aBlock); <span class="comment">// do fixup</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是在Block_private.h头文件中的一些枚举值，包含了用于描述block对象的一些flags；<br>核心方法是<code>_Block_copy</code>函数，这个函数的流程如下：</p>
<ol>
<li>声明一个<code>Block_layout</code>结构体类型的指针aBlock;</li>
<li>检查传入的参数arg是否为空，为空则return NULL；</li>
<li>将aBlock指针指向arg；</li>
<li>判断block的flags是否包含BLOCK_NEEDS_FREE，如果包含，说明这是一个堆block，将其引用计数+1；</li>
<li>判断是否global block，如果是，直接返回相同的block；</li>
<li>如果是一个栈block，执行以下操作：根据传入的block中的size信息创建一块同样大小的内存空间，并使用result指针指向其起始地址；判断result是否为空，如果为空返回NULL；将aBlock按位拷贝（memmove）到result指向的内存空间中；更新块标识，初始化引用计数为0；设置拷贝的block引用计数为1；如果有辅助copy函数，调用辅助函数；设置result的isa指针指向<code>_NSConcreteMallocBlock</code>，即说明这是一个堆block。</li>
</ol>
<h4 id="block辅助copy-dispose函数"><a href="#block辅助copy-dispose函数" class="headerlink" title="block辅助copy/dispose函数"></a>block辅助copy/dispose函数</h4><p>在上一节的3.2、3.3、3.4例子中可以看到，编译期自动生成了copy、dispose函数并添加到<code>Block_layout</code>中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点关注copy函数，<code>__TestObject__testBlock_block_copy_0</code>函数调用了<code>_Block_object_assign</code>函数进行辅助的拷贝操作（主要是对block持有的变量的copy、内存管理等）。<br>源码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block_private.h</span></span><br><span class="line"><span class="comment">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// see function implementation for a more complete description of these fields and combinations</span></span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  <span class="comment">// id, NSObject, __attribute__((NSObject)), block, ...</span></span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  <span class="comment">// a block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>,  <span class="comment">// the on stack structure holding the __block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>,  <span class="comment">// declared __weak, only used in byref copy helpers</span></span><br><span class="line">    BLOCK_BYREF_CALLER      = <span class="number">128</span>, <span class="comment">// called from __block (byref) copy/dispose support routines.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime.c</span></span><br><span class="line"><span class="comment">// When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point</span></span><br><span class="line"><span class="comment">// to do the assignment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destArg, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **dest = (<span class="keyword">const</span> <span class="keyword">void</span> **)destArg;</span><br><span class="line">    <span class="keyword">switch</span> (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        id object = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        _Block_retain_object(object);</span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        void (^object)(void) = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the onstack __block container to the heap</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block ... x;</span></span><br><span class="line"><span class="comment">         __weak __block ... x;</span></span><br><span class="line"><span class="comment">         [^&#123; x; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_byref_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this is MRC unretained __block only. </span></span><br><span class="line"><span class="comment">         // ARC retained __block is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block id object;</span></span><br><span class="line"><span class="comment">         __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __weak __block id object;</span></span><br><span class="line"><span class="comment">         __weak __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程分析：</p>
<ol>
<li>首先是block field有关的一些枚举值，列举了要copy的变量的类型：object/block/byref/caller等；</li>
<li>判断block field，如果是object类型，调用<code>_Block_retain_object</code>函数对object进行一次retain操作；</li>
<li>如果是<code>_Block_byref_copy</code>类型，调用<code>_Block_byref_copy</code>函数进行<code>__Block_byref_</code>结构体的copy操作</li>
<li>其他case，比如<code>__weak __block</code>、<code>__weak __block id</code>或者<code>__weak __block void (^object)(void)</code>类型，不进行copy和retain操作，只是进行指针赋值。</li>
</ol>
<p>看到这里，应该就明白block中循环引用是怎么造成的了吧。<br>结合第三节的<strong>例子3.4</strong>和上述<strong>流程2</strong>可以看出，block持有实例对象的属性（无论是self.xxx或_xxx）时，实际上持有的是当前的实例对象self，而这种情况下在进行copy操作时，调用block的辅助copy函数时，会对self进行一次retain操作，使self的引用计数+1，如果此时实例对象再强引用block的话，就会出现retain cycle，导致对象和block相互引用而无法释放。</p>
<h3 id="五、总结及参考"><a href="#五、总结及参考" class="headerlink" title="五、总结及参考"></a>五、总结及参考</h3><p>通过上述分析，对于block的内存结构和MRC、ARC下block的行为以及block如何持有外部变量、如何copy等有了一个大致的了解。如果对于block的dispose等操作感兴趣的同学，可以去下载官方完整源码阅读：</p>
<p><a href="https://opensource.apple.com/source/libclosure/libclosure-67/" target="_blank" rel="noopener">libclosure-67</a></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>


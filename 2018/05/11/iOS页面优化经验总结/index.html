<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Cui Lanqing">
  <!-- Open Graph Data -->
  <meta property="og:title" content="iOS页面优化经验总结"/>
  <meta property="og:description" content="一枚有梦想的程序猿" />
  <meta property="og:site_name" content="崔岚清的个人博客"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="崔岚清的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>崔岚清的个人博客</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-light.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">iOS页面优化经验总结</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Cui Lanqing</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-05-11</span>
            <span class="time">16:17:53</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/iOS开发/">iOS开发</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Objective-C-UIKit-性能优化/">#Objective-C, UIKit, 性能优化</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><hr>
<p>前段时间接到了一个页面优化任务，一个选座的页面，要求峰值支持100*100个座位，并提高页面滑动的流畅度、内存占用率和加载速度等指标<br><img src="/2018/05/11/iOS页面优化经验总结/1.png" alt="页面样式"><br>前前后后做了一个月左右的时间，这里总结一下优化经验以供参考。</p>
<h3 id="二、分析问题"><a href="#二、分析问题" class="headerlink" title="二、分析问题"></a>二、分析问题</h3><hr>
<h5 id="1、该页面的问题所在"><a href="#1、该页面的问题所在" class="headerlink" title="1、该页面的问题所在"></a>1、该页面的问题所在</h5><p>之前该页面的是由一系列UIButton结合drawRect实现，在从服务器拉取到数据后，计算出每个座位的frame并在相应的位置创建一个button代表该座位，所有座位加载完成后在左上角显示整体座位的缩略图。</p>
<p>这个过程有以下问题：</p>
<ol>
<li>所有的操作都是在主线程进行，当座位较少时用户体验还好，但是当座位数增加到100*100个后，用户进入该页面后要卡住3~4s才能进行操作（在iPhone 5s上测试），用户体验较差；</li>
<li>大量的UIButton对象的创建，加重了CPU的负担并增加了内存消耗，当内存紧张时App容易被系统杀掉；而且大量的纹理渲染和视图混合等也加重了GPU的负担，造成滑动时掉帧。</li>
<li>使用snapshotViewAfterScreenUpdates创建缩略图，当座位图足够大时，很有可能超过GPU的最大纹理尺寸（参考：<a href="http://iosres.com/" target="_blank" rel="noopener">各机型的最大纹理尺寸</a>），此时使用snapshotViewAfterScreenUpdates只能获取到一个空白的视图（具体原因待深究）。</li>
</ol>
<h5 id="2、着手解决问题"><a href="#2、着手解决问题" class="headerlink" title="2、着手解决问题"></a>2、着手解决问题</h5><p>分析了问题之后，可以从以下几个方面对页面进行优化：</p>
<ol>
<li>减少视图层级和对象的创建</li>
<li>尽量将绘制任务放到后台线程中执行</li>
<li>如果必须在主线程中执行，将任务分散到主线程RunLoop的各个空闲状态中执行，以保证页面的流畅</li>
</ol>
<h3 id="三、准备知识"><a href="#三、准备知识" class="headerlink" title="三、准备知识"></a>三、准备知识</h3><hr>
<h5 id="1、如何将像素显示到屏幕上"><a href="#1、如何将像素显示到屏幕上" class="headerlink" title="1、如何将像素显示到屏幕上"></a>1、如何将像素显示到屏幕上</h5><p>首先看一张图片<br><img src="/2018/05/11/iOS页面优化经验总结/2.png" alt=""><br>这张图片简单描述了CPU与GPU的协同工作流程：CPU将计算并绘制好的内容通过总线提交给GPU，GPU对这些内容进行渲染（GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)）并由视频控制器将渲染结果显示到屏幕上。虽然GPU的浮点运算非常高效，但是在1/60s（大约16.7ms）时间内能执行的操作也很有限，因此为了保证60FPS的帧率，尽量不要将复杂的渲染任务提交给GPU。</p>
<h5 id="2、CPU参与的任务"><a href="#2、CPU参与的任务" class="headerlink" title="2、CPU参与的任务"></a>2、CPU参与的任务</h5><ul>
<li><p><strong>对象的创建、销毁和属性调整</strong><br>优化时尽量使用轻量级的对象，比如用CALyer代替UIView；如果对象的创建不涉及UI操作，尽量放到后台线程中执行；使用懒加载，推迟对象的创建时间；使用Storyboard创建视图对象时，消耗的资源比通过代码直接创建视图要大的多，因此，尽量使用代码创建视图对象。</p>
</li>
<li><p><strong>AutoLayout</strong><br>大部分情况下AutoLayout能很好的提升开发效率，但是对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，AutoLayout 带来的 CPU 消耗会呈指数级上升（<a href="http://pilky.me/36/" target="_blank" rel="noopener">http://pilky.me/36/</a>）。如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
</li>
<li><p><strong>视图的布局计算</strong><br>可以在后台线程中计算视图的布局并进行缓存。所有视图的调整最终会落到UIView.bounds/frame/center等属性上面，上文说过，对象的属性调整会消耗大量的CPU资源，因此尽量一次性地调整好视图的布局，避免频繁地调整这些属性。</p>
</li>
<li><p><strong>文本计算、文本渲染</strong><br>文本的宽、高计算会占用大量的CPU资源，并且是不可避免的，通常的文本显示控件（如：UILabel、UITextView等）其排版和绘制都是在主线程中进行的，当文本量较大时，会占用较大的CPU资源。优化的方法只有一个：自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
</li>
<li><p><strong>图片解码</strong><br>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码，这一步是发生在主线程的，并且不可避免。可以参考的优化方法：在后台线程中将图片绘制到CGBitmapContext中，并直接从Bitmap中创建图片。</p>
</li>
<li><p><strong>图像绘制</strong><br>这里通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示的过程，如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢。由于CoreGraphic的方法通常是线程安全的，因此可以把绘制任务放到后台线程中进行，绘制完成后再在主线程中更新UI。</p>
</li>
</ul>
<h5 id="3、GPU参与的任务"><a href="#3、GPU参与的任务" class="headerlink" title="3、GPU参与的任务"></a>3、GPU参与的任务</h5><ul>
<li><p><strong>纹理的渲染</strong><br>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。</p>
</li>
<li><p><strong>视图的混合 (Composing)</strong><br>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
</li>
<li><p><strong>图形的生成</strong><br>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
</li>
</ul>
<h5 id="4、RunLoop"><a href="#4、RunLoop" class="headerlink" title="4、RunLoop"></a>4、RunLoop</h5><p>前面说过尽量把非UI相关的操作放到后台线程中执行，但是如果遇到UI相关的操作怎么办呢？苹果规定UI相关的操作必须放到主线程中执行。我曾经尝试过将CALayer的renderInContext方法放到后台线程中并发执行，虽然使用了@autoreleasepool{}，但是多次进出页面后，内存消耗始终有增无减，而且偶尔还会出现EXEC_BAD_ACCESS的异常。<br>那么对于这类只能在主线程中执行的耗时UI操作应该怎么优化呢？</p>
<blockquote>
<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。<br>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
</blockquote>
<p>在AppDelegate中的didFinishLaunchingWithOptions方法中，使用CFRunLoopGetCurrent()获取主线程的RunLoop可以得到如下输出（只截取相关部分，输出的内容中还可以看到有关AutoreleasePool的创建释放机制、用户事件的响应等，感兴趣的可以自己研究一下）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">CFRunLoopObserver</span> <span class="number">0x6000001256e0</span> [<span class="number">0x10f578c80</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xa0</span>, repeats = Yes, order = <span class="number">1999000</span>, callout = _beforeCACommitHandler (<span class="number">0x10c33fe01</span>), context = &lt;<span class="built_in">CFRunLoopObserver</span> context <span class="number">0x7fc6d9402b30</span>&gt;&#125;</span><br><span class="line">&lt;<span class="built_in">CFRunLoopObserver</span> <span class="number">0x6000001258c0</span> [<span class="number">0x10f578c80</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xa0</span>, repeats = Yes, order = <span class="number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="number">0x10be96672</span>), context = &lt;<span class="built_in">CFRunLoopObserver</span> context <span class="number">0x0</span>&gt;&#125;</span><br><span class="line">&lt;<span class="built_in">CFRunLoopObserver</span> <span class="number">0x600000125780</span> [<span class="number">0x10f578c80</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xa0</span>, repeats = Yes, order = <span class="number">2001000</span>, callout = _afterCACommitHandler (<span class="number">0x10c33fe7c</span>), context = &lt;<span class="built_in">CFRunLoopObserver</span> context <span class="number">0x7fc6d9402b30</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到App启动后，UIApplicationMain函数创建了主线程RunLoop并在其中添加了一个优先级为2000000（order = 2000000）的<br>observer，该优先级低于常见的其他observer，该observer监听RunLoop的kCFRunLoopBeforeWaiting和kCFRunLoopExit事件（activities = 0xa0）。这样，当RunLoop 即将进入休眠（或者退出）时，关注该observer会得到通知，然后将通过CATransaction提交的中间状态合并到GPU中处理并显示到屏幕上。该机制能很好地保证CA的流畅度。</p>
<p>我们可以模拟Core Animation的这个机制，在合适的时机把异步、并发的操作放到主线程中执行，以保证尽量不阻塞主线程。</p>
<h3 id="四、开始优化"><a href="#四、开始优化" class="headerlink" title="四、开始优化"></a>四、开始优化</h3><p>Talk is cheap, show me the code!</p>
<h6 id="1、异步计算并缓存布局"><a href="#1、异步计算并缓存布局" class="headerlink" title="1、异步计算并缓存布局"></a>1、异步计算并缓存布局</h6><p>这一步比较简单，使用GCD异步队列实现即可</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">                <span class="comment">// 计算布局</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<h6 id="2、减少视图层级、使用轻量级视图，异步绘制"><a href="#2、减少视图层级、使用轻量级视图，异步绘制" class="headerlink" title="2、减少视图层级、使用轻量级视图，异步绘制"></a>2、减少视图层级、使用轻量级视图，异步绘制</h6><p>之前的视图中每个座位用一个UIButton表示，对于100*100个座位就有1万个UIButton，视图数量过大。这里考虑以行为单位创建视图，并且每行使用Core Graphic框架异步绘制</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RowLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RowLayer</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setSeatFrames:(<span class="built_in">NSArray</span> *)seatFrames &#123;</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">self</span> drawLayerContentAsync];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)drawLayerContentAsync &#123;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.bounds.size.width, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> rgb = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, size.width, size.height, <span class="number">8</span>, <span class="number">0</span>, rgb, kCGImageAlphaPremultipliedLast);</span><br><span class="line">    dispatch_group_t drawGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(drawGroup, dispatch_get_global_queue(QOS_CLASS_UTILITY, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// draw contents</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(drawGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">CGImageRef</span> contentImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">UIImage</span> *contentImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:contentImageRef];</span><br><span class="line">        <span class="built_in">CGColorSpaceRelease</span>(rgb);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(contentImageRef);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)contentImage.CGImage;</span><br><span class="line">            <span class="comment">// other operations</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="3、RunLoop优化"><a href="#3、RunLoop优化" class="headerlink" title="3、RunLoop优化"></a>3、RunLoop优化</h6><p>对于较少的视图，获取其缩略图可以直接用snapshotViewAfterScreenUpdates方法，但是对于很大的视图，snapshotViewAfterScreenUpdates貌似不太好使。这里使用逐行截图，然后拼接的方法。</p>
<p>首先，创建RunLoopObserver和RunLoopSource并将其添加到主线程的RunLoop上</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">CFRunLoopSourceRef</span>)runLoopSource &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_runLoopSource) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext</span> sourceContext = &#123;&#125;;</span><br><span class="line">        _runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;sourceContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _runLoopSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">CFRunLoopObserverRef</span>)runLoopObserver &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_runLoopObserver) &#123;</span><br><span class="line">        @weakify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">void</span> (^handlerBlock) (<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) = ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>);</span><br><span class="line">            <span class="comment">// 绘制每行的缩略图</span></span><br><span class="line">            [<span class="keyword">self</span> executeRender];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// observer监听RunLoop的BeforeWaiting和Exit状态</span></span><br><span class="line">        _runLoopObserver = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="literal">NULL</span>, kCFRunLoopBeforeWaiting | kCFRunLoopExit, <span class="literal">true</span>, <span class="number">0</span>, handlerBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _runLoopObserver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到主线程RunLoop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="keyword">self</span>.runLoop, <span class="keyword">self</span>.runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="keyword">self</span>.runLoop, <span class="keyword">self</span>.runLoopSource, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<p>将每行的绘制操作封装并添加到队列中，每当self.runLoopObserver被回调时，从队列中取出一个绘制任务并执行</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">RenderBlock renderBlock = ^(__<span class="keyword">unsafe_unretained</span> <span class="built_in">CALayer</span> *layer, <span class="built_in">CGContextRef</span> thumnailCtx, <span class="built_in">CGContextRef</span> rowCtx) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">CGContextClearRect</span>(rowCtx, layer.bounds);</span><br><span class="line">            <span class="comment">// 获取行截图</span></span><br><span class="line">            [layer renderInContext:rowCtx];</span><br><span class="line">            <span class="built_in">CGImageRef</span> outputImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(rowCtx);</span><br><span class="line">            <span class="built_in">UIImage</span> *rowImage = [<span class="built_in">UIImage</span> imageWithCGImage:outputImageRef];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(outputImageRef);</span><br><span class="line">            <span class="comment">// 将行截图绘制到缩略图的context中</span></span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(thumnailCtx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, layer.frame.origin.y, layer.frame.size.width, layer.frame.size.height), rowImage.CGImage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 绘制任务加入队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">CALayer</span> *layer <span class="keyword">in</span> view.layer.sublayers) &#123;</span><br><span class="line">        [_renderQueue addObject:renderBlock];</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="comment">// self.runLoopObserver被回调时执行的方法</span></span><br><span class="line">-(<span class="keyword">void</span>)executeRender &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.renderQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.renderQueue.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列中所有任务执行完成，</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> fullImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(<span class="keyword">self</span>.thumnailDrawContext);</span><br><span class="line">        <span class="built_in">UIImage</span> *fullImage = [<span class="built_in">UIImage</span> imageWithCGImage:fullImageRef];</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(fullImageRef);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(<span class="keyword">self</span>.rowDrawContext);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(<span class="keyword">self</span>.thumnailDrawContext);</span><br><span class="line">        <span class="keyword">self</span>.rowDrawContext = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.thumnailDrawContext = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.renderQueue = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置缩略图</span></span><br><span class="line">        _thumnailLayer.backgroundColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">        _thumnailLayer.contents = (__bridge <span class="keyword">id</span>)fullImage.CGImage;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CALayer</span> *layer = <span class="keyword">self</span>.scrollView.subviews[<span class="number">0</span>].layer.sublayers[<span class="keyword">self</span>.renderOperationIndex];</span><br><span class="line">        <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RenderBlock renderBlock = [<span class="keyword">self</span>.renderQueue objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        renderBlock(layer, <span class="keyword">self</span>.thumnailDrawContext, <span class="keyword">self</span>.rowDrawContext);</span><br><span class="line">        [<span class="keyword">self</span>.renderQueue removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">self</span>.renderOperationIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、优化前后性能对比"><a href="#五、优化前后性能对比" class="headerlink" title="五、优化前后性能对比"></a>五、优化前后性能对比</h3><p>优化后能很好地支持1万个座位了，以下均为1万个座位时的性能对比</p>
<h5 id="1、支持的座位数量"><a href="#1、支持的座位数量" class="headerlink" title="1、支持的座位数量"></a>1、支持的座位数量</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">5000个座位（正常显示）</td>
<td style="text-align:center">5000个座位（正常显示）</td>
</tr>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">10000个座位（页面空白）</td>
<td style="text-align:center">10000个座位（正常显示）</td>
</tr>
</tbody>
</table>
<p>优化后1万个座位可以正常显示了，由于后台最多只能创建1万个座位，更多的座位数目无法测试。经过优化后理论上可以支持10万+的座位数。</p>
<h5 id="2、帧率"><a href="#2、帧率" class="headerlink" title="2、帧率"></a>2、帧率</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">40~45</td>
<td style="text-align:center">55~60</td>
</tr>
</tbody>
</table>
<h5 id="3、内存"><a href="#3、内存" class="headerlink" title="3、内存"></a>3、内存</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">230MB左右</td>
<td style="text-align:center">120MB左右</td>
</tr>
</tbody>
</table>
<p>优化前，重复进入、退出选座页面若干次后，App因内存消耗过大被系统kill；<br>优化后，重复上述操作若干次后，内存消耗比较稳定且没有出现闪退现象。</p>
<h5 id="4、页面卡顿时间"><a href="#4、页面卡顿时间" class="headerlink" title="4、页面卡顿时间"></a>4、页面卡顿时间</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">3s左右</td>
<td style="text-align:center">0s</td>
</tr>
</tbody>
</table>
<p>优化前，进入选座页面后，数据加载完后要等待3s左右才能进行操作，在此期间App卡住且不响应任何用户操作；<br>优化后，进入选座页面后，数据加载完后可以立即响应用户操作，不存在卡顿时间。</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>


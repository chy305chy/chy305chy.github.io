<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="一枚有梦想的程序猿">
<meta name="keywords" content="iOS、前端">
<meta property="og:type" content="website">
<meta property="og:title" content="崔岚清的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="崔岚清的个人博客">
<meta property="og:description" content="一枚有梦想的程序猿">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="崔岚清的个人博客">
<meta name="twitter:description" content="一枚有梦想的程序猿">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>崔岚清的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">崔岚清的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">集跬步至千里，积小流成江海</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/" itemprop="url">GCD源码分析（二）——Dispatch Queue和Thread Pool</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T19:21:37+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>大部分的GCD操作都离不开队列（queue）：使用<code>dispatch_get_main_queue</code>获取主队列，使用<code>dispatch_queue_create</code>创建一个自定义的队列，使用<code>dispatch_get_global_queue</code>获取一个全局的并发队列等等。那么GCD是如何通过这些队列实现多线程的呢？它又是如何管理这些队列的呢？<code>dispatch_async/dispatch_sync</code>是如何工作的呢？带着这些问题，我们从源码中寻找答案。</p>
<h3 id="二、队列与线程"><a href="#二、队列与线程" class="headerlink" title="二、队列与线程"></a>二、队列与线程</h3><p>首先，借用一张网上的图片直观地描述GCD队列和线程的关系。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/gcd_queues_thread.png" alt="GCD队列和线程"></p>
<p>通过GCD，我们可以很方便地实现多线程，而不需要过多地关注线程的实现和创建等，GCD内部维护了一个线程池，由系统根据任务的数量和优先级动态地创建和分配线程执行。</p>
<p>我们提交的任务由GCD内部的manager queue管理一层层地分发到target queue中，最终汇聚到root queue中并由线程池管理线程来执行任务。</p>
<p>线程和队列并不是一对一的关系，一个线程中可能有多个串行或并行队列，这些队列按照同步或异步的方式工作。</p>
<p>注：为方便阅读，文中的所有代码均为宏展开后的代码。</p>
<h4 id="GCD中队列的种类"><a href="#GCD中队列的种类" class="headerlink" title="GCD中队列的种类"></a>GCD中队列的种类</h4><p>从libdispatch源码中可以看到，GCD中一共有如下几种队列：</p>
<ul>
<li>主队列，使用<code>dispatch_get_main_queue()</code>获得的队列，与主线程绑定</li>
<li>全局队列，使用<code>dispatch_get_global_queue()</code>获得的队列，是并行队列，由GCD创建并管理，也是libdispatch内部使用的root-queue</li>
<li>自定义队列，使用<code>dispatch_queue_create()</code>创建的队列，为串行或并行队列</li>
<li>管理队列，libdispatch内部使用的队列，不暴露给开发者，作为队列的调度管理者使用</li>
<li>Runloop队列，用于与线程绑定的<code>dispatch_queue</code>，比如：提交到main-queue上的任务是由runloop-queue进行管理并最终调度到main thread的runloop中处理。</li>
</ul>
<h5 id="主队列main-queue"><a href="#主队列main-queue" class="headerlink" title="主队列main queue"></a>主队列main queue</h5><p>在<code>dispatch_get_main_queue()</code>的函数声明处有如下内容：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @function dispatch_get_main_queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @abstract</span></span><br><span class="line"><span class="comment"> * Returns the default queue that is bound to the main thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @discussion</span></span><br><span class="line"><span class="comment"> * In order to invoke blocks submitted to the main queue, the application must</span></span><br><span class="line"><span class="comment"> * call dispatch_main(), NSApplicationMain(), or use a CFRunLoop on the main</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @result</span></span><br><span class="line"><span class="comment"> * Returns the main queue. This queue is created automatically on behalf of</span></span><br><span class="line"><span class="comment"> * the main thread before main() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>可以看出主队列在<code>main()</code>函数调用之前被创建，同时也说明了libdispatch库的初始化工作在main函数之前就完成了。</p>
<p>调用<code>dispatch_get_main_queue()</code>返回的是<code>_dispatch_main_q</code>这样一个<code>dispatch_queue_t</code>类型的结构体。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_main_queue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (__bridge <span class="built_in">dispatch_queue_t</span>)&amp;(_dispatch_main_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_main_q</code>的结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_main_q = &#123;</span><br><span class="line">	.do_vtable = OS_dispatch_queue_main_class,</span><br><span class="line">	._objc_isa = OS_dispatch_queue_main_class</span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT</span><br><span class="line"><span class="meta">#if !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT],</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_CANNOT_TRYSYNC | DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到<code>_dispatch_main_q</code>包含以下属性：</p>
<h5 id="1、-do-vtable、-objc-isa"><a href="#1、-do-vtable、-objc-isa" class="headerlink" title="1、.do_vtable、._objc_isa"></a>1、.do_vtable、._objc_isa</h5><ul>
<li>do_vtable 包含了队列的类型、dispose、invoke、push、wakeup和debug等信息，这些信息与队列和任务的调度有关</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"main-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_main_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>_objc_isa main_queue的isa指针指向OS_dispatch_queue_main_class</li>
</ul>
<h5 id="2、-do-ref-cnt、-do-xref-cnt"><a href="#2、-do-ref-cnt、-do-xref-cnt" class="headerlink" title="2、.do_ref_cnt、.do_xref_cnt"></a>2、.do_ref_cnt、.do_xref_cnt</h5><p>队列的内部、外部引用计数都赋值为<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>，而<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>的实际定义为<code>INT_MAX</code>，说明了主队列的生命周期与App的生命周期一致，开发者无需对主队列进行retain/release操作，其生命周期由GCD管理。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_OBJECT_GLOBAL_REFCNT		_OS_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"><span class="meta">#define _OS_OBJECT_GLOBAL_REFCNT INT_MAX</span></span><br></pre></td></tr></table></figure>
<h5 id="3、-do-targetq"><a href="#3、-do-targetq" class="headerlink" title="3、.do_targetq"></a>3、.do_targetq</h5><p>主队列的target queue为<code>&amp;_dispatch_root_queues[
            DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT],</code>，实际上就是serialnum=11的”com.apple.root.default-qos.overcommit”这个全局队列，注意这里虽然有个条件编译命令：<code>#if !DISPATCH_USE_RESOLVERS</code>，但是实际上在<code>libdispatch_init()</code>函数中又一次设置了main_queue的do_targetq：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DISPATCH_USE_RESOLVERS // rdar://problem/8541707</span></span><br><span class="line">	_dispatch_main_q.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>所以无论条件编译是否命中，主队列的target queue都被设置为”com.apple.root.default-qos.overcommit”这个root queue。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/2.png" alt="dispatch_main_queue的target_queue"></p>
<blockquote>
<p>GCD中所有的非全局队列（自定义队列及内部的管理队列）的任务最终都是要提交到全局队列（即：root queue）中处理，主队列除外，主队列与主线程绑定，提交到主队列中的任务由runloop queue管理并提交到主线程的runloop执行。</p>
</blockquote>
<h5 id="全局队列global-queue"><a href="#全局队列global-queue" class="headerlink" title="全局队列global queue"></a>全局队列global queue</h5><p>GCD内部维护12个全局队列，对应上述的四个优先级：High/Default/Low/Background。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_root_queues[] = &#123;</span><br><span class="line"><span class="meta">#define _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">	((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_<span class="meta">##n##_QOS_OVERCOMMIT : \</span></span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_<span class="meta">##n##_QOS)</span></span><br><span class="line"><span class="meta">#define _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT_HEADER(queue_root), \</span><br><span class="line">		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[ \</span><br><span class="line">				_DISPATCH_ROOT_QUEUE_IDX(n, flags)], \</span><br><span class="line">		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">		.dq_priority = _dispatch_priority_make(DISPATCH_QOS_<span class="meta">##n, 0) | flags | \</span></span><br><span class="line">				DISPATCH_PRIORITY_FLAG_ROOTQUEUE | \</span><br><span class="line">				((flags &amp; DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE) ? <span class="number">0</span> : \</span><br><span class="line">				DISPATCH_QOS_<span class="meta">##n <span class="meta-string">&lt;&lt; DISPATCH_PRIORITY_OVERRIDE_SHIFT), \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		__VA_ARGS__ \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.maintenance-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 4,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.maintenance-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 5,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.background-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 6,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.background-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 7,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.utility-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 8,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.utility-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 9,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.default-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 10,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">			DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.default-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 11,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-initiated-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 12,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-initiated-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 13,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-interactive-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 14,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-interactive-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 15,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>dq_serialnum为队列号，全局队列的队列号从4开始，前面三个分别为：</p>
<ul>
<li>主队列，dq_serialnum = 1</li>
<li>管理队列（_dispatch_mgr_q），dq_serialnum = 2</li>
<li>dispatch_mgr_root_queue（_dispatch_mgr_q的目标队列），dq_serialnum = 3</li>
</ul>
<h5 id="管理队列manager-queue"><a href="#管理队列manager-queue" class="headerlink" title="管理队列manager queue"></a>管理队列manager queue</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_mgr_q = &#123;</span><br><span class="line">	.do_vtable = DISPATCH_VTABLE(queue_mgr), </span><br><span class="line">	._objc_isa = DISPATCH_OBJC_CLASS(queue_mgr), </span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.do_targetq = &amp;_dispatch_mgr_root_queue,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.libdispatch-manager"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |</span><br><span class="line">			DISPATCH_PRIORITY_SATURATED_OVERRIDE,</span><br><span class="line">	.dq_serialnum = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> dispatch_queue_s _dispatch_mgr_root_queue = &#123;</span><br><span class="line">	DISPATCH_GLOBAL_OBJECT_HEADER(queue_root),</span><br><span class="line">	.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">	.do_ctxt = &amp;_dispatch_mgr_root_queue_context,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.root.libdispatch-manager"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |</span><br><span class="line">			DISPATCH_PRIORITY_SATURATED_OVERRIDE,</span><br><span class="line">	.dq_serialnum = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line"><span class="comment">// 6618342 Contact the team that owns the Instrument DTrace probe before</span></span><br><span class="line"><span class="comment">//         renaming this symbol</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_dispatch_worker_thread(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line"><span class="meta">#if DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">bool</span> overcommit = (qc-&gt;dgq_wq_options &amp; WORKQ_ADDTHREADS_OPTION_OVERCOMMIT);</span><br><span class="line">	<span class="keyword">bool</span> manager = (dq == &amp;_dispatch_mgr_root_queue);</span><br><span class="line">	<span class="keyword">bool</span> monitored = !(overcommit || manager);</span><br><span class="line">	<span class="keyword">if</span> (monitored) &#123;</span><br><span class="line">		_dispatch_workq_worker_register(dq, qc-&gt;dgq_qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> int64_t timeout = <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">	pthread_priority_t old_pri = _dispatch_get_priority();</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_root_queue_drain(dq, old_pri);</span><br><span class="line">		_dispatch_reset_priority_and_voucher(old_pri, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dispatch_semaphore_wait(&amp;pqc-&gt;dpq_thread_mediator,</span><br><span class="line">			dispatch_time(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (monitored) &#123;</span><br><span class="line">		_dispatch_workq_worker_unregister(dq, qc-&gt;dgq_qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	(<span class="keyword">void</span>)os_atomic_inc2o(qc, dgq_thread_pool_size, release);</span><br><span class="line">	_dispatch_global_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	_dispatch_release(dq); <span class="comment">// retained in _dispatch_global_queue_poke_slow</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif // DISPATCH_USE_PTHREAD_POOL</span></span><br></pre></td></tr></table></figure>
<p>从代码可以看出，manager queue是作为root queue与线程池之间的调度和管理者的，如：GCD Timer的实现就用到了管理队列</p>
<h5 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a>自定义队列</h5><p>使用<code>dispatch_queue_create</code>创建自定义队列，为方便阅读，只保留主要流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span></span><br><span class="line">_dispatch_queue_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t dqa,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(dqa)) &#123;</span><br><span class="line">		<span class="comment">// 如果没有传入dispatch_queue_attr_t，将其设置为默认参数</span></span><br><span class="line">		dqa = _dispatch_get_default_queue_attr();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;do_vtable != DISPATCH_VTABLE(queue_attr)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 获取要创建的队列的优先级</span></span><br><span class="line">	dispatch_qos_t qos = _dispatch_priority_qos(dqa-&gt;dqa_qos_and_relpri);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		<span class="comment">// 如果没有指定target queue, 将dispatch_root_queue赋值给tq</span></span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">		<span class="keyword">if</span> (slowpath(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqa-&gt;dqa_inactive || dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建dispatch_queue的vtable参数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	dispatch_queue_flags_t dqf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;dqa_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">	<span class="comment">// 根据上文的参数初始化队列</span></span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqa-&gt;dqa_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqa-&gt;dqa_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置label</span></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	<span class="comment">// 设置优先级</span></span><br><span class="line">	dq-&gt;dq_priority = dqa-&gt;dqa_qos_and_relpri;</span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_priority) &#123;</span><br><span class="line">		<span class="comment">// legacy way of inherithing the QoS from the target</span></span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqa-&gt;dqa_inactive) &#123;</span><br><span class="line">		_dispatch_queue_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// retain target queue，防止其提前释放</span></span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	<span class="comment">// 设置target queue</span></span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="comment">// 自省函数</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据传入的参数调用<code>_dispatch_queue_init</code>创建相应的串行或并行队列，然后设置label、队列优先级，并设置target queue为dispatch_root_queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">dq-&gt;do_targetq = tq;</span><br></pre></td></tr></table></figure>
<p>targetq的作用就是将push到queue中的任务（可能是任务也可能是queue）层层向上push，最终push到全局队列中，由全局队列调度线程池来执行任务（或者pop queue）。</p>
<blockquote>
<p>While custom queues are a powerful abstraction, all blocks you schedule on them will ultimately trickle down to one of the system’s global queues and its thread pool(s).</p>
</blockquote>
<blockquote>
<p>虽然自定义队列是一个强大的抽象，但你在队列上安排的所有Block最终都会渗透到系统的某一个全局队列及其线程池。</p>
</blockquote>
<h5 id="Runloop队列"><a href="#Runloop队列" class="headerlink" title="Runloop队列"></a>Runloop队列</h5><p>Runloop队列用于与线程绑定的队列的任务调度，比如主队列，看下main queue的wake up函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_main_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_is_thread_bound(dq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_queue_is_thread_bound</code>函数判断当前队列是否是与线程绑定的，由于主队列是绑定在主线程上的，这里就调用了<code>_dispatch_runloop_queue_wakeup</code>函数，由runloop queue将任务调度到主线程的runloop上，最终由主线程runloop在合适的时机执行。</p>
<h4 id="GCD-dispatch流程分析"><a href="#GCD-dispatch流程分析" class="headerlink" title="GCD dispatch流程分析"></a>GCD dispatch流程分析</h4><p>上一篇文章说过，<code>dispatch_queue_s</code>结构体中有<code>do_vtable</code>元素，这个<code>do_vtable</code>中包含了队列的push/wakeup/invoke/dispose等与dispatch相关的信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"main-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_main_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其它队列，如：manager queue、runloop queue、root queue等也有类似的vtable结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// manager queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_mgr, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_MGR_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"mgr-queue"</span>,</span><br><span class="line">	.do_push = _dispatch_mgr_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_mgr_thread,</span><br><span class="line">	.do_wakeup = _dispatch_mgr_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// runloop queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_runloop, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_RUNLOOP_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"runloop-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_runloop_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_runloop_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// root queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_root, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_GLOBAL_ROOT_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_pthread_root_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_root_queue_push,</span><br><span class="line">	.do_invoke = <span class="literal">NULL</span>,</span><br><span class="line">	.do_wakeup = _dispatch_root_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_push: 调用push操作将任务提交到queue上</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_continuation_push(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">   dx_vtable(dq)-&gt;do_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_wakeup: 当push任务到队列中时，会调用do_wakeup唤醒队列</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_queue_push_inline(<span class="built_in">dispatch_queue_t</span> dq, dispatch_object_t _tail,</span><br><span class="line">		dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *tail = _tail._do;</span><br><span class="line">	dispatch_wakeup_flags_t flags = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> dx_vtable(dq)-&gt;do_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_invoke: 在libdispatch中，do_invoke只在以下3种情况执行：1、任务出队；2、runloop queue出队；3、如果queue重写了invoke，则当queue元素出队时，调用<code>_dispatch_queue_override_invoke</code>，在<code>_dispatch_queue_override_invoke</code>函数中调用do_invoke。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 1.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(dispatch_object_t dou,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_pthread_root_queue_observer_hooks_t observer_hooks =</span><br><span class="line">			_dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">	_dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">	flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">	   <span class="comment">/// 调用invoke，执行任务</span></span><br><span class="line">		dx_invoke(dou._do, dic, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_root_queue_drain_deferred_wlh(dispatch_deferred_items_t ddi</span><br><span class="line">		DISPATCH_PERF_MON_ARGS_PROTO)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">retry:</span><br><span class="line">	dispatch_assert(ddi-&gt;ddi_wlh_needs_delete);</span><br><span class="line">	<span class="comment">// 出队一个任务块</span></span><br><span class="line">	_dispatch_trace_continuation_pop(rq, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_drain_try_lock_wlh(dq, &amp;dq_state)) &#123;</span><br><span class="line">	   <span class="comment">/// runloop queue出队一个元素，调用其invoke函数</span></span><br><span class="line">		dx_invoke(dq, &amp;dic, flags);</span><br><span class="line">		...</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3.</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(dispatch_continuation_t dc,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">	dispatch_priority_t old_dp;</span><br><span class="line">	voucher_t ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">	dispatch_object_t dou;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	_dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">		<span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">			dx_invoke(dou._do, dic, flags);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	_dispatch_reset_basepri(old_dp);</span><br><span class="line">	_dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了主队列，其他所有队列中提交的任务最终都要通过层层的target queue提交到root queue中（把queue整体提交到target queue中），从线程池中取出或新建一个线程执行：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_queue_class_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">		_dispatch_retain_2(dq);</span><br><span class="line">		flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">			<span class="built_in">dispatch_queue_t</span> tq;</span><br><span class="line">			<span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">				os_atomic_thread_fence();dependency</span><br><span class="line">				tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">						(<span class="keyword">long</span>)new_state);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tq = target;</span><br><span class="line">			&#125;</span><br><span class="line">			dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">			<span class="comment">// 将queue提交到它的target queue中</span></span><br><span class="line">			<span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">		&#125;</span><br><span class="line">      ...</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么队列的dispatch的大致流程如下所示：</p>
<p>提交任务到queue -&gt; 调用push将任务入队 -&gt; 调用wakeup唤醒队列 -&gt; 如果有target queue，往上提交，直到root queue为止 -&gt; 由root queue从线程池中取出或创建一个新线程执行任务。</p>
<p>主队列的dispatch流程与上述略有不同，提交到主队列的任务由GCD内部的runloop queue管理并最终由主线程的runloop执行。</p>
<h5 id="dispatch-async分析"><a href="#dispatch-async分析" class="headerlink" title="dispatch_async分析"></a>dispatch_async分析</h5><p>先看下主队列上的异步任务。</p>
<h6 id="主队列的dispatch-async"><a href="#主队列的dispatch-async" class="headerlink" title="主队列的dispatch_async"></a>主队列的dispatch_async</h6><p>如果我们想在主线程中执行一个异步操作，通常的做法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch async in main queue"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述这段代码在libdispatch内部的流程如下：</p>
<p>1、将传入的block任务转换成一个<code>dispatch_continuation_t</code>类型的结构体对象，然后调用<code>_dispatch_continuation_async</code>将continuation push到main queue中。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 分配空间</span></span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line">   <span class="comment">// block转换成dispatch_continuation对象</span></span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">	   <span class="comment">// 将任务push到main queue中</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在libdispatch源码中能经常见到fastpath、slowpath、likely、unlikely等宏，编写这些宏的目的是告诉编译器来对我们的代码进行优化，通常：</p>
<ul>
<li>fastpath/likely 表示条件更可能成立</li>
<li>slowpath/unlikely 表示条件更不可能成立</li>
</ul>
<p>2、唤醒main queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_continuation_push(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">   dx_vtable(dq)-&gt;do_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上文说过main queue的vtable存储了push/wakeup/invoke等信息，上述代码实际上是调用了_dispatch_queue_push</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_queue_push_inline(<span class="built_in">dispatch_queue_t</span> dq, dispatch_object_t _tail,</span><br><span class="line">		dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这里调用queue的wakeup函数</span></span><br><span class="line">	<span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、wakeup runloop queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_main_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_is_thread_bound(dq)) &#123;</span><br><span class="line">	   <span class="comment">// 这里是判断queue是否与与线程绑定，main queue的wake up命中判断，唤醒runloop queue.</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_runloop_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">	   <span class="comment">// 判断队列中是否有任务，如果有，执行runloop queue poke操作</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_poke(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、唤醒主线程，并注册回调函数，由mach内核在合适的时机执行<code>_dispatch_main_queue_drain</code>操作</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_class_poke(<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_runloop_handle_t handle = _dispatch_runloop_queue_get_handle(dq);</span><br><span class="line">	<span class="keyword">if</span> (!_dispatch_runloop_handle_is_valid(handle)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if HAVE_MACH</span></span><br><span class="line">	mach_port_t mp = handle;</span><br><span class="line">	kern_return_t kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">switch</span> (kr) &#123;</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		(<span class="keyword">void</span>)dispatch_assume_zero(kr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#error <span class="meta-string">"runloop support not implemented on this platform"</span></span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_main_queue_callback_4CF(</span><br><span class="line">		<span class="keyword">void</span> *ignored DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (main_q_is_draining) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">true</span>);</span><br><span class="line">	_dispatch_main_queue_drain();</span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、执行<code>_dispatch_continuation_pop_inline</code>函数，如果主队列中有未完成的任务，将任务出队并执行。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_main_queue_drain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);</span><br><span class="line">		_dispatch_continuation_pop_inline(dc, &amp;dic, DISPATCH_INVOKE_NONE, dq);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(dispatch_object_t dou,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">		dx_invoke(dou._do, dic, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，主队列的dispatch_async流程执行完毕，其实我们在xcode断点时的堆栈信息也能窥探一二。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/3.png" alt="dispatch_async(dispatch_main_queue)的调用栈"></p>
<h6 id="自定义队列-全局队列上的dispatch-async"><a href="#自定义队列-全局队列上的dispatch-async" class="headerlink" title="自定义队列/全局队列上的dispatch_async"></a>自定义队列/全局队列上的dispatch_async</h6><p>示例代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、自定义串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> customSerialQueue = dispatch_queue_create(<span class="string">"com.gcd.queue.custom"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(customSerialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customSerialQueue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、自定义并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> customConcurrentQueue = dispatch_queue_create(<span class="string">"com.gcd.queue.custom"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(customConcurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customConcurrentQueue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3、全局队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customGlobalQueue task"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>自定义创建的并行队列比其他队列（串行队列和全局队列）多了一个redirection流程</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 判断是否需要redirection，如果不需要，将任务入队</span></span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行redirection流程</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>DISPATCH_QUEUE_USES_REDIRECTION</code>这个宏是用来判断queue是否需要redirection，如果<code>dq_width</code>满足<code>width &gt; 1 &amp;&amp; width &lt; 0xfff</code>条件，则队列需要热direction。串行队列(<code>dq_width</code> = 1)和全局队列(<code>dq_width</code> = 0xfff)都不满足上述条件，无需direction。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/4.png" alt="queue width"></p>
<p>redirection：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f_redirect(<span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_object_t dou, dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(_dispatch_object_is_redirection(dou))) &#123;</span><br><span class="line">		dou._dc = _dispatch_async_redirect_wrap(dq, dou);</span><br><span class="line">	&#125;</span><br><span class="line">	dq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the queue to redirect to</span></span><br><span class="line">	<span class="keyword">while</span> (slowpath(DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!fastpath(_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		dq = dq-&gt;do_targetq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>redirection操作的目的就是要将任务最终push到root queue中。</p>
<p>对于无需redirection的队列，调用其push函数，将任务push到队列中，分两种情况：</p>
<ul>
<li>普通的自定义队列：如果queue有target_queue，调用<code>_dispatch_queue_push_queue</code>，将queue层层向上push到target_queue中，最终push到root queue中。</li>
<li>全局队列：由于全局队列(root queue)没有target_queue，调用<code>_dispatch_root_queue_push</code>直接把任务push到root queue中。</li>
</ul>
<p>最终，所有提交到非主队列的任务都push到了root queue中，由root queue调度线程池并分配线程执行。 </p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// root queue线程池管理相关</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_global_queue_poke_slow(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> floor)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_root_queue_context_t qc = dq-&gt;do_ctxt;</span><br><span class="line">	<span class="keyword">int</span> remaining = n;</span><br><span class="line">	<span class="keyword">int</span> r = ENOSYS;</span><br><span class="line"></span><br><span class="line">	_dispatch_root_queues_init();</span><br><span class="line">	_dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">...</span><br><span class="line"><span class="meta">#if DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">	dispatch_pthread_root_queue_context_t pqc = qc-&gt;dgq_ctxt;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(pqc-&gt;dpq_thread_mediator.do_vtable)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (dispatch_semaphore_signal(&amp;pqc-&gt;dpq_thread_mediator)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"signaled sleeping worker for "</span></span><br><span class="line">					<span class="string">"global queue: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">if</span> (!--remaining) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> overcommit = dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	<span class="keyword">if</span> (overcommit) &#123;</span><br><span class="line">		os_atomic_add2o(qc, dgq_pending, remaining, relaxed);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!os_atomic_cmpxchg2o(qc, dgq_pending, <span class="number">0</span>, remaining, relaxed)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"worker thread request still pending for "</span></span><br><span class="line">					<span class="string">"global queue: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int32_t can_request, t_count;</span><br><span class="line">	<span class="comment">// seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt;</span></span><br><span class="line">	t_count = os_atomic_load2o(qc, dgq_thread_pool_size, ordered);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		can_request = t_count &lt; floor ? <span class="number">0</span> : t_count - floor;</span><br><span class="line">		<span class="keyword">if</span> (remaining &gt; can_request) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"pthread pool reducing request from %d to %d"</span>,</span><br><span class="line">					remaining, can_request);</span><br><span class="line">			os_atomic_sub2o(qc, dgq_pending, remaining - can_request, relaxed);</span><br><span class="line">			remaining = can_request;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"pthread pool is full for root queue: "</span></span><br><span class="line">					<span class="string">"%p"</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!os_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">			t_count - remaining, &amp;t_count, acquire));</span><br><span class="line"></span><br><span class="line">	pthread_attr_t *attr = &amp;pqc-&gt;dpq_thread_attr;</span><br><span class="line">	pthread_t tid, *pthr = &amp;tid;</span><br><span class="line"><span class="meta">#if DISPATCH_USE_MGR_THREAD &amp;&amp; DISPATCH_ENABLE_PTHREAD_ROOT_QUEUES</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq == &amp;_dispatch_mgr_root_queue)) &#123;</span><br><span class="line">		pthr = _dispatch_mgr_root_queue_init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_retain(dq); <span class="comment">// released in _dispatch_worker_thread</span></span><br><span class="line">		<span class="keyword">while</span> ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">				(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_temporary_resource_shortage();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (--remaining);</span><br><span class="line"><span class="meta">#endif // DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么root queue是如何出队的呢？上述代码的do-while循环中调用了<code>pthread_create</code>创建新的线程，并将线程运行函数起始地址指向<code>_dispatch_worker_thread</code>，那么线程创建后会执行<code>_dispatch_worker_thread</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_dispatch_worker_thread(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_root_queue_drain(dq, old_pri);</span><br><span class="line">		_dispatch_reset_priority_and_voucher(old_pri, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dispatch_semaphore_wait(&amp;pqc-&gt;dpq_thread_mediator,</span><br><span class="line">			dispatch_time(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">	_dispatch_global_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="built_in">dispatch_queue_t</span> dq, pthread_priority_t pp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">		_dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">		reset = _dispatch_reset_basepri_override();</span><br><span class="line">		<span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	_dispatch_last_resort_autorelease_pool_pop(&amp;dic);</span><br><span class="line"><span class="meta">#endif // DISPATCH_COCOA_COMPAT</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_dispatch_worker_thread</code>中进行drain root queue，将root queue中的元素一个个出队，元素出队时调用<code>_dispatch_continuation_pop_inline</code>，触发队元素的<code>.do_invoke</code>，执行任务。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>整理一下dispatch_async的流程：</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/5.png" alt="dispatch_async流程"></p>
<h4 id="dispatch-sync分析"><a href="#dispatch-sync分析" class="headerlink" title="dispatch_sync分析"></a>dispatch_sync分析</h4><p>dispatch_sync的流程与上文分析的大同小异，一般来说同步任务是在当前线程中执行，同时它会阻塞当前线程直到任务执行完毕。</p>
<ul>
<li>当queue时串行队列时，当前线程会获取lock，如果成功则执行任务，否则出发crash，比如</li>
</ul>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/6.png" alt="dispatch_sync死锁"></p>
<ul>
<li>当queue是并行队列时，会直接执行任务。</li>
</ul>
<p>关于dispatch_sync的流程不详细分析了，这里重点关注一下lock机制以及引起死锁的情形。</p>
<p><code>dispatch_sync_f</code>函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">	   <span class="comment">// 串行队列</span></span><br><span class="line">		<span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dq))) &#123;</span><br><span class="line">	   <span class="comment">// 全局队列</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">	   <span class="comment">// 多重队列，寻找最终的targetq，最终还是会回到该函数中</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行队列中的任务</span></span><br><span class="line">	_dispatch_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取队列的lock"><a href="#获取队列的lock" class="headerlink" title="获取队列的lock"></a>获取队列的lock</h5><p><code>dispatch_sync_f</code>函数中，如果是串行队列，执行<code>dispatch_barrier_sync_f</code>，一步步往下执行，会看到lock相关的函数：<code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code>。</p>
<p>使用宏替换后的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync_and_suspend(<span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		uint32_t tid, uint64_t suspend_count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 根据queue的width初始化init</span></span><br><span class="line">	uint64_t init  = DISPATCH_QUEUE_STATE_INIT_VALUE(dq-&gt;dq_width);</span><br><span class="line">	<span class="comment">// _dispatch_lock_value_from_tid获取传入tid的第3到32位，mask为0xfffffffc</span></span><br><span class="line">	uint64_t value = DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |</span><br><span class="line">			_dispatch_lock_value_from_tid(tid) |</span><br><span class="line">			(suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL);</span><br><span class="line">	uint64_t old_state, new_state;</span><br><span class="line">	<span class="keyword">bool</span> _result = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">typeof</span>(&amp;(dq)-&gt;dq_state) _p = &amp;(dq)-&gt;dq_state;</span><br><span class="line">	<span class="comment">// 原子操作，获取queue的dq_state并赋值给old_state</span></span><br><span class="line">	old_state = os_atomic_load(_p, relaxed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		uint64_t role = old_state &amp; DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">		<span class="keyword">if</span> (old_state != (init | role)) &#123;</span><br><span class="line">			<span class="comment">// 如果old_state与(init | role)值不相等，说明queue的dq_state被改变，当前有thread持有该queue,</span></span><br><span class="line">			<span class="comment">// 终止循环并直接返回false</span></span><br><span class="line">			os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		new_state = value | role;</span><br><span class="line"></span><br><span class="line">		_os_atomic_basetypeof(_p) _r = old_state; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断old_state是否等于new_state, </span></span><br><span class="line">		<span class="comment">// 如果相等，获取lock成功，置db.dq_state为new_state，并返回true</span></span><br><span class="line">		<span class="comment">// 否则，获取lock失败，结束循环，返回false</span></span><br><span class="line">		_Bool _b = atomic_compare_exchange_weak_explicit(_os_atomic_c11_atomic(_p), &amp;_r, new_state, memory_order_acquire, memory_order_relaxed); </span><br><span class="line">		old_state = _r;</span><br><span class="line">		_result = _b;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (os_unlikely(!_result));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，libdispatch通过一些原子操作来比较queue.dq_state的值来实现lock操作：</p>
<p>1、如果dq_state为初始值(<code>init | role</code>)，说明当前queue没有被任何线程lock，则lock成功并设置dq_state为(<code>value | role</code>)；<br>2、否则lock失败，返回false。</p>
<p>线程获取到queue的lock后，queue.dq_state中同时也记录了当前持有lock的线程的tid信息。</p>
<p>再返回到上一级函数<code>dispatch_barrier_sync_f</code>中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_barrier_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fastpath, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fastpath, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dq, tid))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_queue_barrier_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当lock失败后，进入到<code>_dispatch_sync_f_slow</code>等待上一个任务执行完成：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_wait(<span class="built_in">dispatch_queue_t</span> top_dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t top_dc_flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_priority_t pp = _dispatch_get_priority();</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line">	dispatch_qos_t qos;</span><br><span class="line">	uint64_t dq_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 死锁检测部分</span></span><br><span class="line">	<span class="comment">// 获取当前queue的dq_state</span></span><br><span class="line">	dq_state = _dispatch_sync_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, tid))) &#123;</span><br><span class="line">		<span class="comment">// 如果当前queue已经被当前thread持有，引起死锁，触发crash</span></span><br><span class="line">		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> dispatch_sync_context_s dsc = &#123;</span><br><span class="line">		.dc_flags    = dc_flags | DISPATCH_OBJ_SYNC_WAITER_BIT,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = DISPATCH_NO_VOUCHER,</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = tid,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将任务入队</span></span><br><span class="line">	_dispatch_queue_push_sync_waiter(dq, &amp;dsc, qos);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待之前的任务执行完毕</span></span><br><span class="line">	<span class="keyword">if</span> (dsc.dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">		<span class="comment">// 信号量等待，semaphore_wait(dsc.dsc_event-&gt;dte_sema)</span></span><br><span class="line">		_dispatch_thread_event_wait(&amp;dsc.dsc_event); <span class="comment">// acquire</span></span><br><span class="line">		<span class="comment">// 销毁信号量，结束等待，semaphore_destroy(mach_task_self(), dsc.dsc_event-&gt;dte_sema)</span></span><br><span class="line">		_dispatch_thread_event_destroy(&amp;dsc.dsc_event);</span><br><span class="line">		<span class="comment">// If _dispatch_sync_waiter_wake() gave this thread an override,</span></span><br><span class="line">		<span class="comment">// ensure that the root queue sees it.</span></span><br><span class="line">		<span class="keyword">if</span> (dsc.dsc_override_qos &gt; dsc.dsc_override_qos_floor) &#123;</span><br><span class="line">			_dispatch_set_basepri_override_qos(dsc.dsc_override_qos);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 等待owner释放</span></span><br><span class="line">		_dispatch_event_loop_wait_for_ownership(&amp;dsc);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终调用_dispatch_sync_function_invoke_inline，执行任务</span></span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h5><p>死锁的产生必须满足四个必要条件：</p>
<ul>
<li>资源互斥访问</li>
<li>请求与保持</li>
<li>不剥夺</li>
<li>循环等待</li>
</ul>
<p>libdispatch中创建并分配线程来执行任务块的过程中，线程/队列对资源的操作满足上述前三个条件，那么如果再满足第四个条件，必然会发生死锁。</p>
<p>在GCD中满足两个条件即会形成循环等待的情形：</p>
<ul>
<li><strong>串行队列</strong>正在执行任务Task 1（无论是sync还是async方式提交的）</li>
<li>Task 1未执行完成，又向队列中同步提交Task 2（<strong>dispatch_sync</strong>方式提交）</li>
</ul>
<p>死锁的示例代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQ = dispatch_queue_create(<span class="string">"com.testqueue.serial"</span>, DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 2."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQ, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 2."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 两种情况输出一样：</span></span><br><span class="line">Task <span class="number">1</span> begin.</span><br><span class="line"><span class="comment">// 并且发生crash, xcode提示：Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</span></span><br></pre></td></tr></table></figure>
<p>新版libdispatch中引入了死锁检测机制，发生死锁时，主动触发程序crash，并定位到引起死锁的代码，降低了调试难度。</p>
<p>死锁检测相关的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dq_state = _dispatch_sync_wait_prepare(dq);</span><br><span class="line"><span class="keyword">if</span> (unlikely(_dispatch_lock_is_locked_by(dq_state, tid))) &#123;</span><br><span class="line">    <span class="comment">// 如果当前queue已经被当前thread持有，引起死锁，触发crash</span></span><br><span class="line">	DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看到，libdispatch是通过<code>(dq_state ^ tid) &amp; DLOCK_OWNER_MASK</code>这句代码判断dq是否被某个线程持有，而dq.dq_state中存有持有它的线程的tid信息，如果对应tid的线程持有了dq，则返回true，说明当前线程已持有dq，循环等待条件成立，产生死锁，否则返回false。</p>
<p>那么问题来了，如果在thread_A中提交Task1，在Task1还在执行时，在thread_B中同步提交Task2会发生什么情况呢，GCD能否检测出死锁呢？</p>
<p>测试代码中为了避开主线程死锁对测试的干扰，采用dispatch_async方式提交Task1。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.testqueue.serial"</span>, DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL);</span><br><span class="line">    <span class="comment">// 为了避免主线程的死锁，干扰测试结果，这里使用dispatch_async方式提交Task1.</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Task 2 begin."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main queue task complete."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test[<span class="number">73008</span>:<span class="number">2443797</span>] main queue complete.</span><br><span class="line">Test[<span class="number">73008</span>:<span class="number">2443854</span>] Task <span class="number">1</span> begin.</span><br></pre></td></tr></table></figure>
<p>此时程序卡住并没有crash，xcode也并未提示任何crash信息。</p>
<p>这说明了libdispatch死锁检测机制的问题：它只针对在同一个线程中向串行队列同步提交任务的情况。如果Task 2是在其它线程中同步提交的，它就无法检测出来了。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>本文只是粗略地分析了GCD的queue、dispatch过程以及queue和线程之间的调度关系，libdispatch源码的繁杂远远不止于此，细节之处还有如：mach_port通信、线程tsd、runloop callback、系统内核(libkern)交互等等，同时还有一些提升程序性能的编程技巧等（libdispatch为了最大限度地提升性能，大量使用了原子操作而非<code>pthread_mutex_lock</code>、<code>OSSpinLock/OSUnfairLock</code>等锁来实现同步）。感兴趣的同学可以把源码下载下来仔细阅读一下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/GCD源码分析（一）——“对象”和数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/" itemprop="url">GCD源码分析（一）——“对象”和数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T10:43:30+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Grand Central Dispatch(GCD)作为iOS和MacOS开发中不可或缺的工具，它的重要性不言而喻。作为一个喜欢刨根问底的猿，知其然更要知其所以然。网上关于GCD解析的文章不多，仅有的几篇使用的源码版本很老，<code>libdispatch</code>从187.10发展到913.60，其内部已经发生了很多变化。趁工作之余断断续续把GCD的源码<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch-913.60.2.tar.gz</a>看了一下，算是对它的底层原理有了一个大致的了解。</p>
<p>本篇作为系列文章的第一篇，先讲一下GCD中“对象”和数据结构。</p>
<h5 id="为什么“对象”加引号"><a href="#为什么“对象”加引号" class="headerlink" title="为什么“对象”加引号"></a>为什么“对象”加引号</h5><p><code>libdispatch</code>库是纯C语言编写的，并不存在类似面向对象语言中的类、对象之类的概念，它的所有对象（如：<code>dispatch_object_s</code>, <code>dispatch_queue_s</code>, <code>dispatch_semaphore_s</code>等）都是定义为struct（<code>dispatch_object_t</code>是union类型）。<br>为了实现类似面向对象中的“继承”效果，GCD使用了若干个<code>DISPATCH_XXX_HEADER</code>宏，将“基类”的内容在了“子类”结构体内存布局的起始处重写了一次，实现了类似“继承”的概念。注意，这里的继承与OOP中的继承不一样，看不到诸如extends/:之类的继承符号的。</p>
<h3 id="二、结构分析"><a href="#二、结构分析" class="headerlink" title="二、结构分析"></a>二、结构分析</h3><p>libdispatch中定义了很多结构体，这里只选取比较常用的几个，不想看过程的同学可以下面的代码分析。<br>先上图，GCD中的继承结构：</p>
<p><img src="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/dispatch_object_structure.png" alt="GCD中的继承结构"></p>
<h4 id="2-1-dispatch-object-t"><a href="#2-1-dispatch-object-t" class="headerlink" title="2.1 dispatch_object_t"></a>2.1 dispatch_object_t</h4><p>从上图可以看到，<code>dispatch_object_t</code>可以看做GCD中所有“类”的“基类”，看下其代码结构</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> _os_object_s *_os_obj;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *_<span class="keyword">do</span>;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *_dc;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *_dq;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_attr_s *_dqa;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_group_s *_dg;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_source_s *_ds;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_mach_s *_dm;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_mach_msg_s *_dmsg;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_source_attr_s *_dsa;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_semaphore_s *_dsema;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_data_s *_ddata;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_io_s *_dchannel;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_operation_s *_doperation;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_disk_s *_ddisk;</span><br><span class="line">&#125; dispatch_object_t DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_object_t</code>被定义为union，熟悉C语言的同学应该知道：union可以表示任意它里面定义的数据类型，union的大小为这些数据类型中最大的数据类型的大小。这里利用了union的特性将<code>dispatch_object_t</code>定义为所有子类：<code>dispatch_xxx_s</code>的基类。</p>
<h4 id="2-2-os-object-s"><a href="#2-2-os-object-s" class="headerlink" title="2.2 _os_object_s"></a>2.2 _os_object_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _os_object_s &#123;</span><br><span class="line">	<span class="keyword">const</span> _os_object_vtable_s *isa;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> os_obj_ref_cnt;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> os_obj_xref_cnt;</span><br><span class="line">&#125; _os_object_s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _os_object_vtable_s &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *_os_obj_objc_isa;</span><br><span class="line">&#125; _os_object_vtable_s;</span><br></pre></td></tr></table></figure>
<ul>
<li>isa指针，应该类似于OC对象中的isa指针，用于判断当前dispatch object的类型，从下面的代码中可以看出一二：</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *_dispatch_object_alloc(<span class="keyword">const</span> <span class="keyword">void</span> *vtable, size_t size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if OS_OBJECT_HAVE_OBJC1</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_object_vtable_s *_vtable = vtable;</span><br><span class="line">	dispatch_object_t dou;</span><br><span class="line">	dou._os_obj = _os_object_alloc_realized(_vtable-&gt;_os_obj_objc_isa, size);</span><br><span class="line">	dou._do-&gt;do_vtable = vtable;</span><br><span class="line">	<span class="keyword">return</span> dou._do;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">	<span class="keyword">return</span> _os_object_alloc_realized(vtable, size);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>os_obj_ref_cnt/os_obj_xref_cnt，从命名方式猜测，应该是引用计数，与GCD的内存管理相关。从代码中的备注发现，二者分别为object在GCD内部和外部使用的引用计数。</li>
</ul>
<h4 id="2-3-dispatch-object-s"><a href="#2-3-dispatch-object-s" class="headerlink" title="2.3 dispatch_object_s"></a>2.3 dispatch_object_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_object_s &#123;</span><br><span class="line">	<span class="keyword">struct</span> _os_object_s _as_os_obj[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/// 继承自_os_object_s结构体的内容，包含了isa指针和引用计数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *isa;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; </span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_object_vtable_s *do_vtable;</span><br><span class="line">	<span class="comment">// object链表中的下一个元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="comment">// 目标队列，指定当前object的执行队列</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *do_targetq;</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt;</span><br><span class="line">	<span class="keyword">void</span> *do_finalizer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述为宏替换后的代码，原始代码中<code>dispatch_object_s</code>只有<code>_DISPATCH_OBJECT_HEADER(object)</code>宏</p>
<h4 id="2-4-dispatch-queue-s"><a href="#2-4-dispatch-queue-s" class="headerlink" title="2.4 dispatch_queue_s"></a>2.4 dispatch_queue_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s &#123;</span><br><span class="line">	<span class="keyword">struct</span> os_mpsc_queue_s _as_oq[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s _as_do[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/// 继承自dispatch_object_s结构体的内容</span></span><br><span class="line">	<span class="keyword">struct</span> _os_object_s _as_os_obj[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *isa;</span><br><span class="line">	<span class="keyword">int</span> ref_cnt;</span><br><span class="line">	<span class="keyword">int</span> xref_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_queue_vtable_s *do_vtable;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *do_targetq;</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt;</span><br><span class="line">	<span class="keyword">void</span> *do_finalizer</span><br><span class="line"></span><br><span class="line">	DISPATCH_UNION_LE(uint64_t <span class="keyword">volatile</span> dq_state, </span><br><span class="line">			dispatch_lock dq_state_lock, </span><br><span class="line">			uint32_t dq_state_bits </span><br><span class="line">	) DISPATCH_ATOMIC64_ALIGN; </span><br><span class="line">	<span class="comment">// queue的首元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *<span class="keyword">volatile</span> dq_items_head; </span><br><span class="line">	<span class="comment">// queue编号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; </span><br><span class="line">	<span class="comment">// queue名称</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *dq_label; </span><br><span class="line">	<span class="comment">// queue的尾元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *<span class="keyword">volatile</span> dq_items_tail; </span><br><span class="line">	<span class="comment">// queue的优先级</span></span><br><span class="line">	dispatch_priority_t dq_priority; </span><br><span class="line">	<span class="comment">// queue的reference count</span></span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> dq_sref_cnt;</span><br><span class="line">	</span><br><span class="line">	uint32_t dq_side_suspend_cnt;</span><br><span class="line">	dispatch_unfair_lock_s dq_sidelock;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq_specific_q; </span><br><span class="line">		<span class="keyword">struct</span> dispatch_source_refs_s *ds_refs;</span><br><span class="line">		<span class="keyword">struct</span> dispatch_timer_source_refs_s *ds_timer_refs;</span><br><span class="line">		<span class="keyword">struct</span> dispatch_mach_recv_refs_s *dm_recv_refs;</span><br><span class="line">	&#125;;</span><br><span class="line">	DISPATCH_UNION_LE(uint32_t <span class="keyword">volatile</span> dq_atomic_flags,</span><br><span class="line">		<span class="keyword">const</span> uint16_t dq_width,  <span class="comment">// 应该是队列的并发数，当为1时表示串行队列</span></span><br><span class="line">		<span class="keyword">const</span> uint16_t __dq_opaque</span><br><span class="line">	);</span><br><span class="line">	DISPATCH_INTROSPECTION_QUEUE_HEADER</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; <span class="comment">// for static queues only</span></span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-dispatch-continuation-s"><a href="#2-5-dispatch-continuation-s" class="headerlink" title="2.5 dispatch_continuation_s"></a>2.5 dispatch_continuation_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dispatch_continuation_s &#123;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s _as_do[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 任务的函数地址</span></span><br><span class="line">	dispatch_function_t dc_func;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	   <span class="comment">// 优先级</span></span><br><span class="line">		pthread_priority_t dc_priority;</span><br><span class="line">		<span class="keyword">int</span> dc_cache_cnt;</span><br><span class="line">		uintptr_t dc_pad;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">struct</span> voucher_s *dc_voucher;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">void</span> *do_vtable;</span><br><span class="line">		uintptr_t dc_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 任务链表中的下一个元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="comment">// 上下文</span></span><br><span class="line">	<span class="keyword">void</span> *dc_ctxt;</span><br><span class="line">	<span class="keyword">void</span> *dc_data;</span><br><span class="line">	<span class="keyword">void</span> *dc_other</span><br><span class="line">&#125; *dispatch_continuation_t;</span><br></pre></td></tr></table></figure>
<p>从结构体中的<code>dispatch_function_t</code>类型，可以猜测<code>dispatch_continuation_s</code>与GCD的任务有关，我们向GCD中提交的任务，无论是Block或者函数形式，最终都转化成<code>dispatch_continuation_s</code></p>
<h4 id="2-6-dispatch-group-s"><a href="#2-6-dispatch-group-s" class="headerlink" title="2.6 dispatch_group_s"></a>2.6 dispatch_group_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_group_s &#123;</span><br><span class="line">   <span class="comment">/// 继承自dispatch_object_s的内容</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s _as_do[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">struct</span> _os_object_s _as_os_obj[<span class="number">0</span>]; </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *_objc_isa;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> do_ref_cnt;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> do_xref_cnt;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_group_vtable_s *do_vtable;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> dispatch_group_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="comment">// group执行的目标队列 </span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *do_targetq; </span><br><span class="line">	<span class="keyword">void</span> *do_ctxt; </span><br><span class="line">	<span class="keyword">void</span> *do_finalizer;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标识符或者当前group中执行的任务数，0：当前group未在执行，非0：当前group正在执行</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">volatile</span> dg_value; </span><br><span class="line">	_dispatch_sema4_t dg_sema;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> dg_waiters;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *<span class="keyword">volatile</span> dg_notify_head;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *<span class="keyword">volatile</span> dg_notify_tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与其他结构体内容大同小异，需要关注的是这两个参数:</p>
<ul>
<li><code>dg_notify_head</code></li>
<li><code>dg_notify_tail</code>。</li>
</ul>
<p>我们知道<code>dispatch_group_notify</code>可以用来做线程同步，那么猜测猜测这两个变量与实现<code>dispatch_group_notify</code>功能相关，当group中内容执行完毕后，通知<code>dg_notify</code>链表中的任务，<code>_head</code>和<code>_tail</code>用于定位这些需要接收通知的任务的位置。</p>
<p>在semaphore.c中找到相关源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_continuation_t dsn)</span><br><span class="line">&#123;</span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_update_tail(dg, dg_notify, dsn, do_next)) &#123;</span><br><span class="line">	   <span class="comment">// retain group</span></span><br><span class="line">		_dispatch_retain(dg);</span><br><span class="line">		<span class="comment">// 调用atomic_store_explicit函数将当前任务(dsn)替换为dg-&gt;dg_notify_head，</span></span><br><span class="line">		<span class="comment">// 该操作为原子操作</span></span><br><span class="line">		atomic_store_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_notify_head)) _Atomic *)(&amp;(dg)-&gt;dg_notify_head)), dsn, memory_order_ordered)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// seq_cst with atomic store to notify_head &lt;rdar://problem/11750916&gt;</span></span><br><span class="line">		<span class="comment">// 判断当前group中是否有正在执行的任务，如果没有，调用_dispatch_group_wake函数唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_load_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_value)) _Atomic *)(&amp;(dg)-&gt;dg_value)), memory_order_ordered)) == <span class="number">0</span>) &#123;</span><br><span class="line">		  <span class="comment">// 唤醒group</span></span><br><span class="line">			_dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">_dispatch_group_wake(dispatch_group_t dg, <span class="keyword">bool</span> needs_release)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t next, head, tail = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">long</span> rval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cannot use os_mpsc_capture_snapshot() because we can have concurrent</span></span><br><span class="line">	<span class="comment">// _dispatch_group_wake() calls</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将head设置成dg-&gt;dg_notify_head，然后清空dg-&gt;dg_notify_head的值</span></span><br><span class="line">	head = atomic_exchange_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_notify_head)) _Atomic *)(&amp;(dg)-&gt;dg_notify_head)), <span class="literal">NULL</span>, memory_order_relaxed);</span><br><span class="line">	<span class="keyword">if</span> (head) &#123;</span><br><span class="line">		<span class="comment">// snapshot before anything is notified/woken &lt;rdar://problem/8554546&gt;</span></span><br><span class="line">		<span class="comment">// 将tail设置成dg-&gt;dg_notify_tail，然后清空dg-&gt;dg_notify_tail的值</span></span><br><span class="line">		tail = atomic_exchange_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_notify_tail)) _Atomic *)(&amp;(dg)-&gt;dg_notify_tail)), <span class="literal">NULL</span>, memory_order_release);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rval = (<span class="keyword">long</span>)atomic_exchange_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_waiters)) _Atomic *)(&amp;(dg)-&gt;dg_waiters)), <span class="number">0</span>, memory_order_relaxed);</span><br><span class="line">	<span class="keyword">if</span> (rval) &#123;</span><br><span class="line">		<span class="comment">// wake group waiters</span></span><br><span class="line">		_dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">		<span class="comment">// 根据waiters的数量创建相应数量的信号量</span></span><br><span class="line">		_dispatch_sema4_signal(&amp;dg-&gt;dg_sema, rval);</span><br><span class="line">	&#125;</span><br><span class="line">	uint16_t refs = needs_release ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	<span class="keyword">if</span> (head) &#123;</span><br><span class="line">		<span class="comment">// async group notify blocks</span></span><br><span class="line">		<span class="comment">// 异步通知每一个任务</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			next = os_mpsc_pop_snapshot_head(head, tail, do_next);</span><br><span class="line">			<span class="built_in">dispatch_queue_t</span> dsn_queue = (<span class="built_in">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">			_dispatch_continuation_async(dsn_queue, head);</span><br><span class="line">			_dispatch_release(dsn_queue);</span><br><span class="line">		&#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">		refs++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (refs) _dispatch_release_n(dg, refs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-dispatch-source-s"><a href="#2-7-dispatch-source-s" class="headerlink" title="2.7 dispatch_source_s"></a>2.7 dispatch_source_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_source_s &#123;</span><br><span class="line">   <span class="keyword">struct</span> dispatch_queue_s _as_dq[<span class="number">0</span>];</span><br><span class="line">	_DISPATCH_QUEUE_HEADER(source) </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> </span><br><span class="line">		ds_is_installed:<span class="number">1</span>, </span><br><span class="line">		dm_needs_mgr:<span class="number">1</span>, </span><br><span class="line">		dm_connect_handler_called:<span class="number">1</span>, </span><br><span class="line">		dm_uninstalled:<span class="number">1</span>, </span><br><span class="line">		dm_cancel_handler_called:<span class="number">1</span>, </span><br><span class="line">		dm_is_xpc:<span class="number">1</span></span><br><span class="line">	uint64_t ds_data DISPATCH_ATOMIC64_ALIGN;</span><br><span class="line">	uint64_t ds_pending_data DISPATCH_ATOMIC64_ALIGN;</span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_source_s</code>继承自<code>dispatch_queue_s</code>，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。GCD提供了六大类调度源：</p>
<blockquote>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
</blockquote>
<p>可以监听12个类型的事件（可以在source.h文件中查看）:</p>
<ul>
<li>DISPATCH_SOURCE_TYPE_DATA_ADD，自定义事件，可以通过dispatch_source_get_data函数获取事件变量数据，在我们自定义的方法中可以调用dispatch_source_merge_data函数向调度源设置数据</li>
<li>DISPATCH_SOURCE_TYPE_DATA_OR，同上</li>
<li>DISPATCH_SOURCE_TYPE_DATA_REPLACE，同上</li>
<li>DISPATCH_SOURCE_TYPE_MACH_SEND，Mach内核端口发送事件</li>
<li>DISPATCH_SOURCE_TYPE_MACH_RECV，Mach内核端口监听事件</li>
<li>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE，内存压力事件，分为三个等级：NORMAL、WARN、CRITICAL</li>
<li>DISPATCH_SOURCE_TYPE_PROC，进程相关事件，如进程退出、创建子线程、收到UNIX信号等事件</li>
<li>DISPATCH_SOURCE_TYPE_READ，IO读操作事件，如文件或socket的读操作</li>
<li>DISPATCH_SOURCE_TYPE_WRITE，IO写操作事件</li>
<li>DISPATCH_SOURCE_TYPE_SIGNAL，进程接收Unix内核信号事件</li>
<li>DISPATCH_SOURCE_TYPE_TIMER，定时器事件</li>
<li>DISPATCH_SOURCE_TYPE_VNODE，文件状态改变事件，如文件移动、删除、重命名等</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/" itemprop="url">OC中Block内存结构以及copy/持有外部变量等操作的实现原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T16:41:54+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近对App中的埋点代码进行了改造（随着项目的增大，散落在系统各处的埋点代码实在不好管理），利用AOP的方式将散布在各个页面中的埋点代码统一起来组成一个独立的模块，从而减少埋点行为对业务代码的侵入。</p>
<p>熟悉iOS AOP编程的同学肯定听过<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>这个框架，我们也使用这个框架实现Method Swizzle，通过Method Swizzle给指定的方法添加side-effect，在side-effect中做相应的埋点上报操作。</p>
<p>在学习Aspects源码的过程中，对Runtime以及OC的消息转发机制有了一个深入的了解，写几篇文章记录一下，文章中会穿插一些对于Aspect源码的分析内容，如有错误的地方，欢迎大家斧正。</p>
<h3 id="二、Block-Memory-Layout"><a href="#二、Block-Memory-Layout" class="headerlink" title="二、Block Memory Layout"></a>二、Block Memory Layout</h3><p>Everything hides in the source code: <a href="https://opensource.apple.com/source/libclosure/libclosure-67/" target="_blank" rel="noopener">libclosure-67</a></p>
<p>block的本质可以看做一个函数，这点从它的定义可以看出来（Block_private.h）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">    int32_t reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">    <span class="comment">// 捕获的外部变量，block将外部变量复制到结构体中，因此block内部可以访问到其外部的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_1 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_2 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_3 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>逐条分析： </p>
<ul>
<li><code>void *isa</code>: oc中的所有对象都有该指针，指向其所属的类。oc对象接收到消息后，根据isa指针找到其所属的类，然后获取存储在类中的property_list、method_list等信息，然后进行下一步的操作；</li>
<li><code>volatile int32_t flags</code>: 标识位，block内部操作时会用到，比如copy、dispose等，其中包含了block的reference count、是否heap block等信息；</li>
<li><code>int32_t reserved</code>: 保留变量</li>
<li><code>void (*invoke)(void *, ...)</code>: 函数指针，指向block的实现函数地址；</li>
<li><code>struct Block_descriptor_1 *descriptor</code>: 附加描述信息，存储了一些如block大小、copy/dispose函数指针、签名（用于构造方法签名）等信息。</li>
</ul>
<p><strong>Aspects源码截取：构造blockMethodSignature</strong></p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化desc指针，指向block的descriptor结构体起始地址</span></span><br><span class="line"><span class="keyword">void</span> *desc = layout-&gt;descriptor;</span><br><span class="line"><span class="comment">// 2. 移动指针，跳过reserved、size变量</span></span><br><span class="line">desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 3. 判断是否有copy/dispose信息，如果有，移动desc指针，跳过copy/dispose指针变量</span></span><br><span class="line"><span class="keyword">if</span> (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">	desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 移动后的指针应该指向block的signature信息，判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't has a type signature."</span>, block];</span><br><span class="line">    AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 指针不为空，取出signature指针，构造methodSignature</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br></pre></td></tr></table></figure>
<p>在Block_private.h中还能看到如下信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block_private.h</span></span><br><span class="line"><span class="comment">// the raw data space for runtime classes for blocks</span></span><br><span class="line"><span class="comment">// class+meta used for stack, malloc, and collectable based blocks</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteMallocBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteAutoBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteFinalizingBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteWeakBlockVariable[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"><span class="comment">// declared in Block.h</span></span><br><span class="line"><span class="comment">// BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];</span></span><br><span class="line"><span class="comment">// BLOCK_EXPORT void * _NSConcreteStackBlock[32];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block.h</span></span><br><span class="line"><span class="comment">// Used by the compiler. Do not use these variables yourself.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteGlobalBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteStackBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>
<p>从其命名方式：Global/Stack(栈)/Malloc(堆)可以推测出Block的类型：NSGlobalBlock（全局Block）、NSStackBlock（栈区Block）、NSMallocBlock（堆区Block）。下面结合代码分别分析一下这三种block。</p>
<h4 id="2-1-NSGlobalBlock"><a href="#2-1-NSGlobalBlock" class="headerlink" title="2.1 NSGlobalBlock"></a>2.1 NSGlobalBlock</h4><p>我们知道，程序中的全局变量存储在内存中的数据区（.data区），这块内存中的内容在编译期就已经完全确定了。因此，这种Block无法捕捉任何变量，也无需任何运行时状态来参与运行。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^TestBlock)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *str = <span class="string">@"static test str"</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    TestBlock block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"innner block"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block address:%@"</span>, block);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"static string address:%p"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">innner block</span><br><span class="line">block address:&lt;__NSGlobalBlock__: <span class="number">0x10428a080</span>&gt;</span><br><span class="line"><span class="keyword">static</span> string address:<span class="number">0x104290908</span></span><br></pre></td></tr></table></figure>
<p>可以看出，NSGlobalBlock的存储区域与静态变量的地址相近，二者都存储于全局数据区。</p>
<h4 id="2-2-NSStackBlock和NSMallocBlock"><a href="#2-2-NSStackBlock和NSMallocBlock" class="headerlink" title="2.2 NSStackBlock和NSMallocBlock"></a>2.2 NSStackBlock和NSMallocBlock</h4><ul>
<li>MRC下，无论是对于作为函数临时变量的block和对象属性的block，都默认存储在栈区，其生命周期随着变量作用域结束而结束，如果想要保留block，可以显示调用copy方法将block拷贝到堆中。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    TestBlock stackBlock = ^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line">    stackBlock();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"stack block address: %@"</span>, stackBlock);</span><br><span class="line">    </span><br><span class="line">    TestBlock heapBlock = [^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line">    heapBlock();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"heap block address: %@"</span>, heapBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">stack block address: &lt;__NSStackBlock__: <span class="number">0x7ffeeeeeb970</span>&gt;</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">heap block address: &lt;__NSMallocBlock__: <span class="number">0x6000017bbfc0</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>ARC下，由于编译期会隐式地为非全局block添加copy操作，因此所有的非全局block都存储于堆区。这个copy操作属于深拷贝，将block拷贝到堆中，这个拷贝的block对象强引用它捕获的变量，因此ARC下要注意block的隐式copy引起的retain cycle问题。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"heap block address: %@"</span>, block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">heap block address: &lt;__NSMallocBlock__: <span class="number">0x60000221eb50</span>&gt;</span><br></pre></td></tr></table></figure>
<p>因此，MRC下block有三种：NSGlobalBlock、NSStackBlock、NSMallocBlock，<br>而ARC下由于编译器隐式添加copy操作，只有两种block：NSGlobalBlock、NSMallocBlock。</p>
<h3 id="三、Block持有外部变量分析"><a href="#三、Block持有外部变量分析" class="headerlink" title="三、Block持有外部变量分析"></a>三、Block持有外部变量分析</h3><p>上一节中说过block结构体中有专门存放捕获的变量的区域，那么block是如何捕获到外部变量的呢？分几种情况分析。</p>
<h4 id="3-1-block持有非-block修饰的基本类型变量"><a href="#3-1-block持有非-block修饰的基本类型变量" class="headerlink" title="3.1 block持有非__block修饰的基本类型变量"></a>3.1 block持有非__block修饰的基本类型变量</h4><p>先看代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, j address: %p"</span>, &amp;j);</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, j address: %p"</span>, &amp;j);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, j address: %p"</span>, &amp;j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">before block, j address: <span class="number">0x7ffee08849bc</span></span><br><span class="line">inner block, j address: <span class="number">0x600000dac080</span></span><br><span class="line">after block, j address: <span class="number">0x7ffee08849bc</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看出，打印变量j的地址，before block和after block的地址相同，且二者与block内部的地址不同。（ARC和MRC下，输出的结果一样）</p>
<h5 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h5><p>使用<code>clang -rewrite-objc</code>命令重写.m文件，只选取关键代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, <span class="keyword">int</span> _j, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> j = __cself-&gt;j; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_1, &amp;j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_0, &amp;j);</span><br><span class="line"></span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, j));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_2, &amp;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>__TestObject__testBlock_block_impl_0</code>是testBlock的实现，包含了一个isa指针（本例中它指向NSConcreteStackBlock, 说明这个block是分配在栈上的）、一个impl函数指针（本例中它指向<code>__TestObject__testBlock_block_func_0</code>）、一个Desc结构体指针，从block的实现来看，捕获到的外部变量会追加到Desc指针后面，使得<code>__TestObject__testBlock_block_impl_0</code>结构体变大。</p>
<p>从<code>__TestObject__testBlock_block_func_0</code>中可以看到：<code>int j = __cself-&gt;j; // bound by copy</code>这样一句代码，block将捕获的外部变量复制一份到其内部，这也说明了为什么block内部打印的变量j的地址与外部不一致。</p>
<h4 id="3-2-block持有-block修饰的基本类型变量"><a href="#3-2-block持有-block修饰的基本类型变量" class="headerlink" title="3.2 block持有__block修饰的基本类型变量"></a>3.2 block持有__block修饰的基本类型变量</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, j address: %p"</span>, &amp;j);</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, j address: %p"</span>, &amp;j);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, j address: %p"</span>, &amp;j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line">before block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line">inner block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line">after block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line">before block, j address: <span class="number">0x7ffeeea309a8</span></span><br><span class="line">inner block, j address: <span class="number">0x600000c54558</span></span><br><span class="line">after block, j address: <span class="number">0x600000c54558</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看到，MRC下，block前后和block内部打印的变量j的地址都相同，而且都是存在于栈中；ARC下，由于block的隐式copy操作，block内部和block执行后打印变量j的地址是在堆中，而block之前的地址是在栈中。</p>
<h6 id="分析原因-1"><a href="#分析原因-1" class="headerlink" title="分析原因"></a>分析原因</h6><p>使用clang重写oc代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_j_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_j_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_j_0 *j; <span class="comment">// by ref</span></span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, __Block_byref_j_0 *_j, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_j_0 *j = __cself-&gt;j; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_1, &amp;(j-&gt;__forwarding-&gt;j));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;j, (<span class="keyword">void</span>*)src-&gt;j, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;j, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_j_0 j = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_j_0 *)&amp;j, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_j_0), <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_0, &amp;(j.__forwarding-&gt;j));</span><br><span class="line"></span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, (__Block_byref_j_0 *)&amp;j, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_2, &amp;(j.__forwarding-&gt;j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，block内部除了<code>isa</code>指针、<code>impl</code>函数指针、<code>Desc</code>指针外，增加了一个<code>__Block_byref_j_0</code>类型的结构体指针，block捕获的外部变量由该结构体管理，block通过持有该结构体指针实现了对外部变量修改的目的。而且<code>__TestObject__testBlock_block_desc_0</code>中新增了copy和dispose两个函数指针，用于实现对<code>__Block_byref_j_0</code>结构体的内存管理。</p>
<p><code>__Block_byref_j_0</code>结构体中包含了：</p>
<ul>
<li>isa指针: 指向该__block变量的类型，本例中是基本数据类型，因此，isa指针为<code>(void *)0</code>；</li>
<li>forwarding指针: 指向该结构体，用于取值；</li>
<li>flags: 标识位，对于基本数据类型该值为0，对于对象类型该值为3554432；</li>
<li>size: 该结构体的大小；</li>
<li>j: 不同的捕获变量，该值命名类型不同，本例中用于储存捕获的整型变量的值；</li>
</ul>
<p>在block内部和block前后读写变量j的值，都是读取或修改<code>j-&gt;__forwarding-&gt;j</code>或者<code>j.__forwarding-&gt;j</code>的值，由于block内外获取到的<code>__forwarding</code>指针指向同一结构体地址，因此使得block内部修改变量影响到了block外部。</p>
<h4 id="3-3-block持有-block修饰的对象"><a href="#3-3-block持有-block修饰的对象" class="headerlink" title="3.3 block持有__block修饰的对象"></a>3.3 block持有__block修饰的对象</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block ObjectA *blockObj = [[ObjectA alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, blockObj address: %p, obj pointer address: %p"</span>, blockObj,  &amp;blockObj);</span><br><span class="line">    TestBlock block = ^ &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, blockObj address: %p, obj pointer address: %p"</span>, blockObj, &amp;blockObj);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, blockObj address: %p, obj pointer address: %p"</span>, blockObj, &amp;blockObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line">before block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line">inner block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line">after block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line">before block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x7ffee4d8e9a8</span></span><br><span class="line">inner block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x600002431318</span></span><br><span class="line">after block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x600002431318</span></span><br></pre></td></tr></table></figure>
<p>可以看到，无论是MRC或者ARC下，blockObj对象的地址都不变，在堆中；MRC下，blockObj对象的指针地址不变，在栈中；而ARC下，blockObj对象的指针地址在copy之后发生了变化，指针从栈中拷贝到了堆中。</p>
<p><strong>这也说明了block对其持有的对象的copy操作只是浅拷贝，拷贝的是指针，而指针指向的对象始终存在于堆中的某个区域</strong></p>
<h5 id="分析原因-2"><a href="#分析原因-2" class="headerlink" title="分析原因"></a>分析原因</h5><p>使用clang重写</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_blockObj_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockObj_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> ObjectA *blockObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_blockObj_0 *blockObj; <span class="comment">// by ref</span></span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, __Block_byref_blockObj_0 *_blockObj, <span class="keyword">int</span> flags=<span class="number">0</span>) : blockObj(_blockObj-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_blockObj_0 *blockObj = __cself-&gt;blockObj; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_1, &amp;(blockObj-&gt;__forwarding-&gt;blockObj));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;blockObj, (<span class="keyword">void</span>*)src-&gt;blockObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;blockObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_blockObj_0 blockObj = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_blockObj_0 *)&amp;blockObj, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_blockObj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((ObjectA *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((ObjectA *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"ObjectA"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_0, &amp;(blockObj.__forwarding-&gt;blockObj));</span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, (__Block_byref_blockObj_0 *)&amp;blockObj, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_2, &amp;(blockObj.__forwarding-&gt;blockObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上例的结构基本相同，不同的是<code>__Block_byref_blockObj_0</code>结构体中增加了copy、dispose两个函数指针用于实现block持有对象的内存管理，<code>__Block_byref_blockObj_0</code>持有的是捕获对象的指针。</p>
<h4 id="3-4-block持有类的属性"><a href="#3-4-block持有类的属性" class="headerlink" title="3.4 block持有类的属性"></a>3.4 block持有类的属性</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, str value: %@"</span>, _str);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, str address: %p"</span>, &amp;_str);</span><br><span class="line">    TestBlock block = ^ &#123;</span><br><span class="line">        _str = <span class="string">@"block str"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, str value: %@"</span>, _str);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, str address: %p"</span>, &amp;_str);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, str value: %@"</span>, _str);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, str address: %p"</span>, &amp;_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC和ARC</span></span><br><span class="line">before block, str value: init string.</span><br><span class="line">before block, str address: <span class="number">0x6000004c23b8</span></span><br><span class="line">inner block, str value: block str</span><br><span class="line">inner block, str address: <span class="number">0x6000004c23b8</span></span><br><span class="line">after block, str value: block str</span><br><span class="line">after block, str address: <span class="number">0x6000004c23b8</span></span><br></pre></td></tr></table></figure>
<p>MRC和ARC下，block内外打印的对象地址相同，且不需要<code>__block</code>修饰，block也能捕获并修改类的属性。</p>
<h5 id="分析原因-3"><a href="#分析原因-3" class="headerlink" title="分析原因"></a>分析原因</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  TestObject *<span class="keyword">self</span>;</span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, TestObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  TestObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)) = (<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_3;</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_4, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_5, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_1, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_2, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_6, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_7, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，构建block结构体时，其内部持有的是该类的实例对象：<code>TestObject *self</code>。而在创建block时，传入的是类的当前的实例对象self：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>
<p>因此，block内部持有的实际上是self，在读取和修改类的属性时，使用的实际上是</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str))</span><br></pre></td></tr></table></figure>
<p>所以，无需<code>__block</code>修饰，block也能修改类的属性，而且无论在MRC还是ARC下，打印的属性地址都是堆中的某个区域（基本类型的属性不同，是在栈中）。</p>
<h3 id="四、Block-copy过程以及导致retain-cycle的原因分析"><a href="#四、Block-copy过程以及导致retain-cycle的原因分析" class="headerlink" title="四、Block copy过程以及导致retain cycle的原因分析"></a>四、Block copy过程以及导致retain cycle的原因分析</h3><p>ARC下，为了延长分配在栈中block的生命周期，编译期会对非全局block默认加copy操作，将其copy到堆中。对于基本数据类型，copy一份到堆中，对于对象类型变量，copy其指针到堆中。而我们常说的block的循环引用就是这个copy操作导致的，那么为什么block的copy操作会导致某些情况下的循环引用呢？下面通过源码分析一下。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libclosure-67/Block_private.h</span></span><br><span class="line"><span class="comment">// Values for Block_layout-&gt;flags to describe block objects</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libclosure-67/runtime.c</span></span><br><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_layout *aBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            int32_t old_value = aBlock-&gt;flags;</span><br><span class="line">            <span class="keyword">if</span> ((old_value &amp; BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OSAtomicCompareAndSwapInt(old_value, old_value+<span class="number">2</span>, &amp;aBlock-&gt;flags)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="keyword">struct</span> Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);</span><br><span class="line">        <span class="keyword">if</span> (!desc) <span class="keyword">return</span>;</span><br><span class="line">        (*desc-&gt;<span class="keyword">copy</span>)(result, aBlock); <span class="comment">// do fixup</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是在Block_private.h头文件中的一些枚举值，包含了用于描述block对象的一些flags；<br>核心方法是<code>_Block_copy</code>函数，这个函数的流程如下：</p>
<ol>
<li>声明一个<code>Block_layout</code>结构体类型的指针aBlock;</li>
<li>检查传入的参数arg是否为空，为空则return NULL；</li>
<li>将aBlock指针指向arg；</li>
<li>判断block的flags是否包含BLOCK_NEEDS_FREE，如果包含，说明这是一个堆block，将其引用计数+1；</li>
<li>判断是否global block，如果是，直接返回相同的block；</li>
<li>如果是一个栈block，执行以下操作：根据传入的block中的size信息创建一块同样大小的内存空间，并使用result指针指向其起始地址；判断result是否为空，如果为空返回NULL；将aBlock按位拷贝（memmove）到result指向的内存空间中；更新块标识，初始化引用计数为0；设置拷贝的block引用计数为1；如果有辅助copy函数，调用辅助函数；设置result的isa指针指向<code>_NSConcreteMallocBlock</code>，即说明这是一个堆block。</li>
</ol>
<h4 id="block辅助copy-dispose函数"><a href="#block辅助copy-dispose函数" class="headerlink" title="block辅助copy/dispose函数"></a>block辅助copy/dispose函数</h4><p>在上一节的3.2、3.3、3.4例子中可以看到，编译期自动生成了copy、dispose函数并添加到<code>Block_layout</code>中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点关注copy函数，<code>__TestObject__testBlock_block_copy_0</code>函数调用了<code>_Block_object_assign</code>函数进行辅助的拷贝操作（主要是对block持有的变量的copy、内存管理等）。<br>源码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block_private.h</span></span><br><span class="line"><span class="comment">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// see function implementation for a more complete description of these fields and combinations</span></span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  <span class="comment">// id, NSObject, __attribute__((NSObject)), block, ...</span></span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  <span class="comment">// a block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>,  <span class="comment">// the on stack structure holding the __block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>,  <span class="comment">// declared __weak, only used in byref copy helpers</span></span><br><span class="line">    BLOCK_BYREF_CALLER      = <span class="number">128</span>, <span class="comment">// called from __block (byref) copy/dispose support routines.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime.c</span></span><br><span class="line"><span class="comment">// When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point</span></span><br><span class="line"><span class="comment">// to do the assignment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destArg, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **dest = (<span class="keyword">const</span> <span class="keyword">void</span> **)destArg;</span><br><span class="line">    <span class="keyword">switch</span> (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        id object = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        _Block_retain_object(object);</span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        void (^object)(void) = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the onstack __block container to the heap</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block ... x;</span></span><br><span class="line"><span class="comment">         __weak __block ... x;</span></span><br><span class="line"><span class="comment">         [^&#123; x; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_byref_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this is MRC unretained __block only. </span></span><br><span class="line"><span class="comment">         // ARC retained __block is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block id object;</span></span><br><span class="line"><span class="comment">         __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __weak __block id object;</span></span><br><span class="line"><span class="comment">         __weak __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程分析：</p>
<ol>
<li>首先是block field有关的一些枚举值，列举了要copy的变量的类型：object/block/byref/caller等；</li>
<li>判断block field，如果是object类型，调用<code>_Block_retain_object</code>函数对object进行一次retain操作；</li>
<li>如果是<code>_Block_byref_copy</code>类型，调用<code>_Block_byref_copy</code>函数进行<code>__Block_byref_</code>结构体的copy操作</li>
<li>其他case，比如<code>__weak __block</code>、<code>__weak __block id</code>或者<code>__weak __block void (^object)(void)</code>类型，不进行copy和retain操作，只是进行指针赋值。</li>
</ol>
<p>看到这里，应该就明白block中循环引用是怎么造成的了吧。<br>结合第三节的<strong>例子3.4</strong>和上述<strong>流程2</strong>可以看出，block持有实例对象的属性（无论是self.xxx或_xxx）时，实际上持有的是当前的实例对象self，而这种情况下在进行copy操作时，调用block的辅助copy函数时，会对self进行一次retain操作，使self的引用计数+1，如果此时实例对象再强引用block的话，就会出现retain cycle，导致对象和block相互引用而无法释放。</p>
<h3 id="五、总结及参考"><a href="#五、总结及参考" class="headerlink" title="五、总结及参考"></a>五、总结及参考</h3><p>通过上述分析，对于block的内存结构和MRC、ARC下block的行为以及block如何持有外部变量、如何copy等有了一个大致的了解。如果对于block的dispose等操作感兴趣的同学，可以去下载官方完整源码阅读：</p>
<p><a href="https://opensource.apple.com/source/libclosure/libclosure-67/" target="_blank" rel="noopener">libclosure-67</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/Swift内存模型与指针的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/Swift内存模型与指针的使用/" itemprop="url">Swift内存模型与指针的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T16:02:20+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/21/Swift内存模型与指针的使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/21/Swift内存模型与指针的使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>我们在编写Objective-C和C代码时经常会用到指针，切换到Swift语言中来，虽然其可以无缝使用C语言指针，但是在语法上与OC和C还是有很大区别的。</p>
<p>Swift本身是内存安全的，只要确保所有变量在使用前都被正确地初始化，我们不必担心内存问题，因此，Apple官方不建议开发者直接操作内存，但是Swift还是为开发者提供了使用指针直接操作内存的方法，Swift中所有的指针类型都带有“Unsafe”前缀，就是为了提示开发者使用指针的行为是危险且不安全的，要慎重。</p>
<p>先来看看Swift中的指针类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">C</th>
<th style="text-align:center">Swift</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">const Type *</td>
<td style="text-align:center">UnsafePointer<type></type></td>
<td style="text-align:center">指针可变，指针指向的内存值不可变</td>
</tr>
<tr>
<td style="text-align:center">Type *</td>
<td style="text-align:center">UnsafeMutablePointer<type></type></td>
<td style="text-align:center">指针可变，指针指向的内存值可变</td>
</tr>
<tr>
<td style="text-align:center">const void *</td>
<td style="text-align:center">UnsafeRawPointer</td>
<td style="text-align:center">指针可变，指针指向的内存区域类型不确定，且内存值不可变</td>
</tr>
<tr>
<td style="text-align:center">void *</td>
<td style="text-align:center">UnsafeMutableRawPointer</td>
<td style="text-align:center">指针可变，指针指向的内存区域类型不确定，且内存值可变</td>
</tr>
<tr>
<td style="text-align:center">StructType *</td>
<td style="text-align:center">OpaquePointer</td>
<td style="text-align:center">C中的一些自定义类型，Swift中无相应的类型，如：sqlite3_stmt结构体</td>
</tr>
<tr>
<td style="text-align:center">ClassType <em> const </em></td>
<td style="text-align:center">UnsafePointer<classtype></classtype></td>
<td style="text-align:center">指向指针的指针，指针不可变，指针指向的类可变</td>
</tr>
<tr>
<td style="text-align:center">ClassType <em> __strong </em></td>
<td style="text-align:center">UnsafeMutablePointer<classtype></classtype></td>
<td style="text-align:center">指向指针的指针，指针可变，指针指向的类可变</td>
</tr>
<tr>
<td style="text-align:center">int8_t a[]</td>
<td style="text-align:center">var x:[Int8] -&gt; UnsafeBufferPointer</td>
<td style="text-align:center">数组指针，指向数组一个元素的地址</td>
</tr>
</tbody>
</table>
<h4 id="二、MemoryLayout"><a href="#二、MemoryLayout" class="headerlink" title="二、MemoryLayout"></a>二、MemoryLayout</h4><p>提到指针就不得不说一下内存模型。Swift的内存分配与C/C++/Objective-C/Java等类似：</p>
<ul>
<li>Stack: 存储值类型变量（如int、float、struct等），函数调用栈，存储引用类型的临时变量指针</li>
<li>Heap: 存储引用类型的实例，比如类的对象</li>
</ul>
<blockquote>
<p>内存对齐：出于对寻址速度、原子操作以及简化CPU和Memory之间接口设计等方面的考虑，现代计算机系统对值类型的合法地址做了一些限制，要求某种数据类型的对象的地址必须是K的整数倍（K通常是2、4、8）。</p>
<p>因此对齐的原则是: <strong>任何K字节的基本对象的地址必须是K的整数倍</strong>。</p>
<p>Tip: 在声明类或者结构体的成员变量时，可以将占用空间大的变量写在前面，将占用空间小的变量写在后面，以达到减少内存占用的目的。</p>
</blockquote>
<p>MemoryLayout是Swift中用来计算数据类型占用内存空间大小的工具，它有三个比较常用的Int类型的属性：</p>
<ul>
<li>size/size(ofValue: T):  T类型的实例占用连续内存字节的大小</li>
<li>alignment/alignment(ofValue: T):  数据类型T的内存对齐原则，在64bit系统下，最大的内存对齐原则是8Byte</li>
<li>stride/stride(ofValue: T): 由于内存对齐的原因，T类型的实例实际消耗的内存空间stride可能比其size大，浪费的内存空间即：stride - size</li>
</ul>
<p>其简单用法如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var count: Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Int&gt;.size              <span class="comment">// 8</span></span><br><span class="line">MemoryLayout.size(ofValue: count)   <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.alignment         <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.stride            <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>我们看下Swift中基本数据类型的MemoryLayout三个属性的值：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test: <span class="built_in">NSObject</span> &#123;&#125;</span><br><span class="line">var count: Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK:- 值类型</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.size          <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.alignment     <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.stride        <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Double&gt;.size       <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Double&gt;.alignment  <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Double&gt;.stride     <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Float&gt;.size        <span class="comment">// 4</span></span><br><span class="line">MemoryLayout&lt;Float&gt;.alignment   <span class="comment">// 4</span></span><br><span class="line">MemoryLayout&lt;Float&gt;.stride      <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;<span class="built_in">UInt</span>&gt;.size         <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;<span class="built_in">UInt</span>&gt;.alignment    <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;<span class="built_in">UInt</span>&gt;.stride       <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;String&gt;.size       <span class="comment">// 16</span></span><br><span class="line">MemoryLayout&lt;String&gt;.alignment  <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;String&gt;.stride     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: - 引用类型</span></span><br><span class="line">MemoryLayout&lt;Test&gt;.size         <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Test&gt;.alignment    <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Test&gt;.stride       <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: - 指针类型</span></span><br><span class="line">MemoryLayout&lt;UnsafePointer&lt;Test&gt;&gt;.size      <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;UnsafePointer&lt;Test&gt;&gt;.alignment <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;UnsafePointer&lt;Test&gt;&gt;.stride    <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;UnsafeBufferPointer&lt;Test&gt;&gt;.size        <span class="comment">// 16</span></span><br><span class="line">MemoryLayout&lt;UnsafeBufferPointer&lt;Test&gt;&gt;.alignment   <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;UnsafeBufferPointer&lt;Test&gt;&gt;.stride      <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<h4 id="三、Swift指针"><a href="#三、Swift指针" class="headerlink" title="三、Swift指针"></a>三、Swift指针</h4><h5 id="3-1、使用类型指针"><a href="#3-1、使用类型指针" class="headerlink" title="3.1、使用类型指针"></a>3.1、使用类型指针</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 使用类型指针</span></span><br><span class="line">let ptr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line">ptr.initialize(to: <span class="number">1</span>)   <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">ptr              <span class="comment">// 0x6000022c00c0</span></span><br><span class="line">ptr.pointee      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">ptr.pointee = <span class="number">100</span></span><br><span class="line">ptr.pointee      <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">ptr.advanced(by: <span class="number">1</span>).pointee     <span class="comment">// 指针向后移动8Bytes，其指向的内存内容不确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完不要忘记销毁</span></span><br><span class="line">ptr.deallocate()</span><br></pre></td></tr></table></figure>
<h5 id="3-2、使用原生指针"><a href="#3-2、使用原生指针" class="headerlink" title="3.2、使用原生指针"></a>3.2、使用原生指针</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 使用原生指针</span></span><br><span class="line"></span><br><span class="line">let rawPtr = UnsafeMutableRawPointer.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">8</span>)</span><br><span class="line">rawPtr.storeBytes(of: <span class="string">"hello world"</span>, as: String.self)</span><br><span class="line">rawPtr.load(as: String.self)    <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">let bufferRawPtr = UnsafeMutableRawBufferPointer(start: rawPtr, count: <span class="number">16</span>)</span><br><span class="line"><span class="comment">// UnsafeRawBufferPointer类型以一系列字节的形式来读取内存</span></span><br><span class="line"><span class="keyword">for</span> (index, byte) <span class="keyword">in</span> bufferRawPtr.enumerated() &#123;</span><br><span class="line">    print(<span class="string">"byte \(index): \(byte)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、获取实例的bytes"><a href="#3-3、获取实例的bytes" class="headerlink" title="3.3、获取实例的bytes"></a>3.3、获取实例的bytes</h5><p>在Objective-C中我们经常遇到函数接受bytes指针的参数，那么Swift中如何获取bytes指针呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"hello world."</span></span><br><span class="line">withUnsafeBytes(of: str) &#123; bytes <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes &#123;</span><br><span class="line">        print(byte)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：禁止返回指针，如果指针超出withUnsafeBytes作用域，可能会导致意想不到的结果，其他withUnsafeXXX方法同样禁止返回指针</span></span><br><span class="line">    <span class="comment">// return bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4、指针类型转换"><a href="#3-4、指针类型转换" class="headerlink" title="3.4、指针类型转换"></a>3.4、指针类型转换</h5><p>我们操作C函数的时候，经常会遇到需要转换指针类型的情况，比如将指向结构体的指针转换为指向其它不同结构体的指针，这种操作在C语言中是很简单但也十分危险的。而由于Swift指针在创建时即明确了其类型，这就意味着一个UnsafePointer<int8>类型的指针不能用在需要UnsafePointer<uint8>的地方，比如：sqlite3_column_text返回值不能用在String(utf8String: )方法中，这个时候就需要用到指针类型转换了：</uint8></int8></p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let intPtr = UnsafeMutablePointer&lt;Int8&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">intPtr.pointee = <span class="number">-1</span></span><br><span class="line">intPtr.pointee      <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">let _ = intPtr.withMemoryRebound(to: <span class="built_in">UInt8</span>.self, capacity: <span class="number">1</span>) &#123; ptr <span class="keyword">in</span></span><br><span class="line">    ptr.pointee     <span class="comment">// 255</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、实践——通过指针修改Struct类型实例的属性的值"><a href="#四、实践——通过指针修改Struct类型实例的属性的值" class="headerlink" title="四、实践——通过指针修改Struct类型实例的属性的值"></a>四、实践——通过指针修改Struct类型实例的属性的值</h4><p>  先直接上代码：</p>
  <figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> TestStruct &#123;</span><br><span class="line">    var a: Int8 = <span class="number">7</span>             <span class="comment">// 1 bytes</span></span><br><span class="line">    private var b: Int = <span class="number">6</span>      <span class="comment">// 8 bytes</span></span><br><span class="line">    var c: String = <span class="string">"hello"</span>     <span class="comment">// 16 bytes</span></span><br><span class="line">    var d: Int?                 <span class="comment">// 9 bytes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var testStruct = TestStruct()</span><br><span class="line">let rawPtr = withUnsafeMutablePointer(to: &amp;testStruct) &#123;UnsafeMutableRawPointer(mutating: $<span class="number">0</span>)&#125;</span><br><span class="line">let b = rawPtr.load(fromByteOffset: <span class="number">8</span>, as: Int.self)</span><br><span class="line">let bPtr = rawPtr.advanced(by: <span class="number">8</span>).assumingMemoryBound(to: Int.self)</span><br><span class="line">bPtr.pointee        <span class="comment">// 6</span></span><br><span class="line">bPtr.initialize(to: <span class="number">10</span>)</span><br><span class="line">bPtr.pointee        <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>  代码分析：<br>  <code>rawPtr</code>指针是一个<code>void *</code>类型的指针，指向<code>testStruct</code>实例所在内存的第一个字节，我们可以通过移动指针获取<code>testStruct</code>的<code>private</code>属性<code>b</code>。<br>  属性<code>a</code>是<code>Int8</code>类型，占用1个字节，但是由于内存对齐的原因，其所占的内存空间为8个字节，因此需要将<code>rawPtr</code>向后移动8个字节才能获取到属性<code>b</code>的起始地址：<code>rawPtr.advanced(by: 8).assumingMemoryBound(to: Int.self)</code>。</p>
<blockquote>
<p>assumingMemoryBound(to:)</p>
</blockquote>
<blockquote>
<p>Returns a typed pointer to the memory referenced by this pointer, assuming that the memory is already bound to the specified type.</p>
</blockquote>
<p>  因此，将<code>rawPtr</code>向后移动8bytes后通过<code>assumingMemoryBound(to: Int.self)</code>方法，可以得到指向属性<code>b</code>的指针<code>bPtr</code>。之后通过<code>initialize(to: 10)</code>方法重新初始化属性b的内存区域，为其重新赋值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/" itemprop="url">从一个BUG谈起，剖析objc_msgSend函数的底层实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T19:46:12+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、引出问题"><a href="#一、引出问题" class="headerlink" title="一、引出问题"></a>一、引出问题</h3><hr>
<p>前段时间开发FLEX+Relative库（使用Category和Runtime实现将<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a>库扩展出可以查看UIView相对间距的功能）。开发完成后遇到了一个奇怪的BUG，模拟器与真机调试时行为不一致，模拟器上可以正常实现预期功能，但是在真机上却出现问题：程序展示的视图与实际选中的视图不一致。先看问题代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateRelativeViewsForSelectionPoint:(<span class="built_in">CGPoint</span>)selectionPointInWindow &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeAndClearRelativeLines];</span><br><span class="line">    <span class="built_in">UIView</span> *selectedView = objc_msgSend(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewForSelectionAtPoint:), selectionPointInWindow);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.relativeViews containsObject:selectedView]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.relativeViews removeObject:selectedView];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.relativeViews addObject:selectedView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.relativeViews.count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.relativeViews removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> updateRelativeDimensionLines];</span><br><span class="line">    [<span class="keyword">self</span>.view bringSubviewToFront:(<span class="built_in">UIView</span> *)[<span class="keyword">self</span> valueForKey:<span class="string">@"explorerToolbar"</span>]];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(updateButtonStates)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调试，定位到问题出现在objc_msgSend函数调用这一行，这行代码的作用是调用FLEX库的viewForSelectionAtPoint:方法返回用户点击的UIView，入参为用户点击的坐标。调试过程中发现，通过objc_msgSend函数调用时，传入viewForSelectionAtPoint:方法的坐标发生了变化（x和y值发生了互换，在模拟器上正常）。</p>
<p>我们知道objc_msgSend是OC中的核心函数，所有的方法调用最终都会转化成objc_msgSend函数调用，Apple为了优化其性能，该函数内部使用汇编语言实现，而且不同平台对应不同的汇编文件，你可以在这里<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/" target="_blank" rel="noopener">objc_msgSend汇编源码</a>查阅相关源代码。objc_msgSend中使用了cache，而且为了实现极致的性能优化，该函数使用了ldp指令、编译内存屏障（Compile Memory Barrier）、内存垃圾回收等技术代替锁来解决多线程环境下的读写竞争和死锁问题。</p>
<p>通过查阅资料发现，objc_msgSend函数与正常的C函数不同，调用时要准确地指定其返回值、入参等的类型：</p>
<blockquote>
<p>This unusual casting situation arises because objc_msgSend is not intended to be called like a normal C function. It is (and must be) implemented in assembly, and just jumps to a target C function after fiddling with a few registers. In particular, there is no consistent way to refer to any argument past the first two from within objc_msgSend. Another case where just calling objc_msgSend straight wouldn’t work is a method that returns an NSRect, say, because objc_msgSend is not used in that case, objc_msgSend_stret is. In the underlying C function for a method that returns an NSRect, the first argument is actually a pointer to an out value NSRect, and the function itself actually returns void. You must match this convention when calling because it’s what the called method will assume. Further, the circumstances in which objc_msgSend_stret is used differ between architectures. There is also an objc_msgSend_fpret, which should be used for methods that return certain floating point types on certain architectures.</p>
</blockquote>
<p>因此，修改objc_msgSend函数调用后，问题得到解决：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *selectedView = ((<span class="built_in">UIView</span>* (*)(<span class="keyword">id</span>, SEL, <span class="built_in">CGPoint</span> p))objc_msgSend)(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewForSelectionAtPoint:), selectionPointInWindow);</span><br></pre></td></tr></table></figure>
<h3 id="二、问题定位"><a href="#二、问题定位" class="headerlink" title="二、问题定位"></a>二、问题定位</h3><hr>
<p>以下分析均以ARM64架构为例</p>
<h4 id="2-1-预备知识"><a href="#2-1-预备知识" class="headerlink" title="2.1 预备知识"></a>2.1 预备知识</h4><p>开始之前，我们先了解一下ARM架构下程序的内存分配和汇编指令的相关知识。</p>
<h5 id="2-1-1-内存分配与管理"><a href="#2-1-1-内存分配与管理" class="headerlink" title="2.1.1 内存分配与管理"></a>2.1.1 内存分配与管理</h5><p>我们知道，任何指令的执行都离不开内存的操作，而根据用途的不同内存又被划分为堆(heap)、栈(stack)、常量区、全局（静态）区、代码区等。代码区存放可执行文件的指令，可以看做是可执行文件在内存中的镜像（只读）；全局区存放静态变量和全局变量；常量区，顾名思义，存放的是常量。这里重点介绍栈和堆。</p>
<p><img src="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/2.jpeg" alt="内存区域说明"></p>
<ul>
<li>堆：堆区是一块不连续的内存区域，由开发者分配和释放，我们开发时创建的一些对象等都是在堆中存储的，堆是由内存的低地址向高地址扩展的。</li>
<li>栈：栈区是一块连续的内存区域，由编译器进行分配和释放，其中的内存随着函数的运行和结束而分配和释放，由系统自动完成。栈的大小是有限制的，如果申请的内存大于栈区的剩余内存（如：快速排序递归层级过多时），程序会crash并报Stack Overflow错误。OS X和iOS系统中，子线程的最大栈空间默认为512KB，而对于主线程的最大栈空间，二者有所不同，OS X默认为8MB，iOS默认为1MB。</li>
</ul>
<p><img src="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/1.jpeg" alt="Apple堆栈大小说明"></p>
<h5 id="2-1-2-ARM汇编指令介绍"><a href="#2-1-2-ARM汇编指令介绍" class="headerlink" title="2.1.2 ARM汇编指令介绍"></a>2.1.2 ARM汇编指令介绍</h5><p>ARM64有32个长度为64bit的通用寄存器：x0~x30和sp，可以只使用其中的32bit：w0~w30，其中，前8个寄存器x0~x7用于函数调用时传参，同时，x0寄存器也可以作为函数返回值的寄存器。x8寄存器用于间接寻址（当函数返回的内容&gt;16Bytes时，该返回内容会被放入到内存中，然后将该内存地址存入x8寄存器）。</p>
<ul>
<li>sp寄存器指向当前frame的栈顶（低地址），可以通过移动sp的位置为栈分配或释放内存空间；</li>
<li>x29通常作为fp寄存器，指向当前frame的栈底（高地址）；</li>
<li>x30通常作为lr寄存器，它有两个作用：1、保存子程序的返回地址，2、当异常发生时，用来保存异常的返回地址；</li>
<li>pc，程序计数器，指向下一条指令。</li>
</ul>
<p>stp/ldp指令结合sp、x29、x30寄存器，保证了函数调用结束后的正确返回。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, sp, <span class="meta">#0x50</span></span><br><span class="line">stp    x29, x30, [sp, <span class="meta">#0x40]</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ldp    x29, x30, [sp, <span class="meta">#0x40]</span></span><br><span class="line">add    sp, sp, <span class="meta">#0x50</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>一些常用的汇编指令：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MOV X1, X0  ;寄存器X0的值传给X1</span><br><span class="line">ADD X0, X1, X2  ;寄存器X1和X2的值相加后给X0</span><br><span class="line">SUB X0, X1, X2  ;寄存器X1和X2的值相减后给X0</span><br><span class="line"></span><br><span class="line">AND X0, X0, <span class="meta">#0xF    ;X0和0xF相与后的值给X0</span></span><br><span class="line">ORR X0, X0, <span class="meta">#0x10   ;X0和0x10相或后的值给X0</span></span><br><span class="line">EOR X0, X0, <span class="meta">#0x11   ;X0和0x11相异或后的值给X0</span></span><br><span class="line"></span><br><span class="line">LDR(LDUR) X5, [X6, <span class="meta">#0x8]  ;X6寄存器的值(地址)加0x8的地址内的值给X5</span></span><br><span class="line">STR(STUR) X0, [SP, <span class="meta">#0x8]  ;X0的值给(SP+0x8)地址指向的空间</span></span><br><span class="line"></span><br><span class="line">STP X29, X30, [SP, <span class="meta">#0x1]    ;入栈操作</span></span><br><span class="line">LDP X29, X30, [SP, <span class="meta">#0x1]    ;出栈操作</span></span><br><span class="line"></span><br><span class="line">CBZ     比较，如果结果为<span class="number">0</span>，就跳转到后面的指令</span><br><span class="line">CBNZ    比较，如果结果非<span class="number">0</span>，就跳转到后面的指令</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMP</span>     比较指令，结果影响CSPR状态</span><br><span class="line"></span><br><span class="line">B/BL    绝对跳转,无返回值/绝对跳转,返回值地址保存到LR(X30)</span><br><span class="line">RET     子程序返回，返回地址保存到LR(X30)</span><br><span class="line"></span><br><span class="line">ADRP    用来定位数据段中的数据, 因为ASLR会导致代码及数据的地址随机化, 用ADRP来根据PC做辅助定位</span><br></pre></td></tr></table></figure>
<h4 id="2-2-定位问题"><a href="#2-2-定位问题" class="headerlink" title="2.2 定位问题"></a>2.2 定位问题</h4><p>开启XCode的Always Show Disassembly，并在updateRelativeViewsForSelectionPoint:方法中的调用objc_msgSend代码处加断点，程序执行到断点处，XCode输出反汇编代码如下:</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GWMovie`-[FLEXExplorerViewController(Relative) updateRelativeViewsForSelectionPoint:]:</span><br><span class="line">    <span class="number">0x1007dd3a0</span> &lt;+<span class="number">0</span>&gt;:   sub    sp, sp, <span class="meta">#0x50             ; =0x50        // 移动sp，分配0x50大小的空间，sp指向当前栈的栈顶</span></span><br><span class="line">    <span class="number">0x1007dd3a4</span> &lt;+<span class="number">4</span>&gt;:   stp    x29, x30, [sp, <span class="meta">#0x40]                    // 开始执行方法之前，将fp、lr寄存器入栈，状态保存到sp+0x40地址</span></span><br><span class="line">    <span class="number">0x1007dd3a8</span> &lt;+<span class="number">8</span>&gt;:   add    x29, sp, <span class="meta">#0x40            ; =0x40        // fp寄存器指向sp+0x40地址，fp指向当前frame的栈底</span></span><br><span class="line">    <span class="number">0x1007dd3ac</span> &lt;+<span class="number">12</span>&gt;:  stur   d0, [x29, <span class="meta">#-0x10]   // 将d0寄存器（存储浮点类型数据）的内容存到fp-0x10地址指向的空间</span></span><br><span class="line">    <span class="number">0x1007dd3b0</span> &lt;+<span class="number">16</span>&gt;:  stur   d1, [x29, <span class="meta">#-0x8]    // 将d1寄存器的内容存入fp-0x8地址指向的空间，d0和d1寄存器中存储的是CGPoint结构体的x、y值</span></span><br><span class="line">    <span class="number">0x1007dd3b4</span> &lt;+<span class="number">20</span>&gt;:  stur   x0, [x29, <span class="meta">#-0x18]</span></span><br><span class="line">    <span class="number">0x1007dd3b8</span> &lt;+<span class="number">24</span>&gt;:  str    x1, [sp, <span class="meta">#0x20]</span></span><br><span class="line">    <span class="number">0x1007dd3bc</span> &lt;+<span class="number">28</span>&gt;:  ldur   x0, [x29, <span class="meta">#-0x18]</span></span><br><span class="line">    <span class="number">0x1007dd3c0</span> &lt;+<span class="number">32</span>&gt;:  adrp   x1, <span class="number">8156</span></span><br><span class="line">    <span class="number">0x1007dd3c4</span> &lt;+<span class="number">36</span>&gt;:  ldr    x1, [x1, <span class="meta">#0x810]</span></span><br><span class="line">    <span class="number">0x1007dd3c8</span> &lt;+<span class="number">40</span>&gt;:  bl     <span class="number">0x101f86fa8</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend</span><br><span class="line">    <span class="comment">// 这句开始到bl指令之前，是编译器根据calling convention为objc_msgSend的函数调用设置寄存器、栈帧的数据和状态，但是由于未明确指定objc_msgSend函数的原型，导致了calling convention mismatch，这里取的数据和之前存的数据不一致，从而引起了程序的异常行为。</span></span><br><span class="line">-&gt;  <span class="number">0x1007dd3cc</span> &lt;+<span class="number">44</span>&gt;:  ldur   x0, [x29, <span class="meta">#-0x18]    // 将fp-0x18地址的内容存入x0，即：x0中存储的为消息的receiver，在该方法中为self</span></span><br><span class="line">    <span class="number">0x1007dd3d0</span> &lt;+<span class="number">48</span>&gt;:  adrp   x1, <span class="number">8153</span></span><br><span class="line">    <span class="number">0x1007dd3d4</span> &lt;+<span class="number">52</span>&gt;:  ldr    x1, [x1, <span class="meta">#0xf28]     // 将selector存入x1寄存器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题所在，这两句ldr指令将上文存储的d1的数据加载进d0，将d0的数据加载进了d1，从而导致了CGPoint结构体中x、y值的互换</span></span><br><span class="line">    <span class="number">0x1007dd3d8</span> &lt;+<span class="number">56</span>&gt;:  ldur   d0, [x29, <span class="meta">#-0x8]     // 将fp-0x8地址（存储了d1的值）的值给d0</span></span><br><span class="line">    <span class="number">0x1007dd3dc</span> &lt;+<span class="number">60</span>&gt;:  ldur   d1, [x29, <span class="meta">#-0x10]    // 将fp-0x10地址（存储了d0的值）的值给d1</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x1007dd3e0</span> &lt;+<span class="number">64</span>&gt;:  mov    x30, sp</span><br><span class="line">    <span class="number">0x1007dd3e4</span> &lt;+<span class="number">68</span>&gt;:  str    d0, [x30, <span class="meta">#0x8]</span></span><br><span class="line">    <span class="number">0x1007dd3e8</span> &lt;+<span class="number">72</span>&gt;:  str    d1, [x30]</span><br><span class="line">    <span class="number">0x1007dd3ec</span> &lt;+<span class="number">76</span>&gt;:  bl     <span class="number">0x101f86fa8</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend</span><br><span class="line">    <span class="number">0x1007dd3f0</span> &lt;+<span class="number">80</span>&gt;:  mov    x29, x29</span><br><span class="line">    <span class="number">0x1007dd3f4</span> &lt;+<span class="number">84</span>&gt;:  bl     <span class="number">0x101f87008</span>               ; symbol stub <span class="keyword">for</span>: objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="number">0x1007dd3f8</span> &lt;+<span class="number">88</span>&gt;:  mov    x1, <span class="meta">#0x0</span></span><br><span class="line">    <span class="number">0x1007dd3fc</span> &lt;+<span class="number">92</span>&gt;:  add    x30, sp, <span class="meta">#0x18            ; =0x18 </span></span><br><span class="line">    <span class="number">0x1007dd400</span> &lt;+<span class="number">96</span>&gt;:  str    x0, [sp, <span class="meta">#0x18]</span></span><br><span class="line">    <span class="number">0x1007dd404</span> &lt;+<span class="number">100</span>&gt;: mov    x0, x30</span><br><span class="line">    <span class="number">0x1007dd408</span> &lt;+<span class="number">104</span>&gt;: bl     <span class="number">0x101f87068</span>               ; symbol stub <span class="keyword">for</span>: objc_storeStrong</span><br><span class="line">    <span class="number">0x1007dd40c</span> &lt;+<span class="number">108</span>&gt;: ldp    x29, x30, [sp, <span class="meta">#0x40]    // 恢复到该方法调用之前的状态</span></span><br><span class="line">    <span class="number">0x1007dd410</span> &lt;+<span class="number">112</span>&gt;: add    sp, sp, <span class="meta">#0x50             ; =0x50    // 方法结束，释放空间</span></span><br><span class="line">    <span class="number">0x1007dd414</span> &lt;+<span class="number">116</span>&gt;: ret                 <span class="comment">// 返回，这一步直接执行lr的指令</span></span><br></pre></td></tr></table></figure>
<p>从反汇编代码中可以看出，输入objc_msgSend函数的CGPoint参数与实际传入updateRelativeViewsForSelectionPoint:方法中的CGPoint参数的x、y值出现了互换：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stur   d0, [x29, <span class="meta">#-0x10]</span></span><br><span class="line">stur   d1, [x29, <span class="meta">#-0x8]</span></span><br><span class="line">...</span><br><span class="line">ldur   d0, [x29, <span class="meta">#-0x8]</span></span><br><span class="line">ldur   d1, [x29, <span class="meta">#-0x10]</span></span><br></pre></td></tr></table></figure>
<p>定位到问题出现在objc_msgSend函数的调用上，通过明确指定函数的入参类型和返回值类型，解决该问题。</p>
<h3 id="三、刨根问底——objc-msgSend函数分析"><a href="#三、刨根问底——objc-msgSend函数分析" class="headerlink" title="三、刨根问底——objc_msgSend函数分析"></a>三、刨根问底——objc_msgSend函数分析</h3><hr>
<p>那么为什么会出现这种奇怪的BUG呢？实际上，这个问题早在苹果发布的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaTouch64BitGuide/ConvertingYourAppto64-Bit/ConvertingYourAppto64-Bit.html#//apple_ref/doc/uid/TP40013501-CH3-SW26" target="_blank" rel="noopener">64-Bit Transition Guide for Cocoa Touch</a>中提到：</p>
<blockquote>
<p>Test your app on actual 64-bit hardware. iOS Simulator can also be helpful during development, but some changes, such as the function calling conventions, are visible only when your app is running on a device.</p>
</blockquote>
<p>出现这个问题的原因是，在64-bit runtime下，ARM的调用约定（calling conventions）比32-bit更加严格。消息函数并不与runtime调用的方法函数共享同一个原型（prototype）,因此，当没有指定消息函数的原型时，runtime会直接调用该方法的函数实现，这样就导致了调用约定不匹配（calling convention mismatch）。以objc_msgSend函数为例，它被设计成一个通用的函数，通过calling convention来满足不同入参和不同返回值类型的函数调用，但是，当发生calling convention mismatch时，函数调用者会将参数放到非objc_msgSend函数期望的地方，这样一来，当objc_msgSend函数取值时，可能会取到错误的值，从而导致程序crash或异常行为。</p>
<blockquote>
<p>An exception to the casting rule described above is when you are calling the objc_msgSend function or any other similar functions in the Objective-C runtime that send messages. Although the prototype for the message functions has a variadic form, the method function that is called by the Objective-C runtime does not share the same prototype. The Objective-C runtime directly dispatches to the function that implements the method, so the calling conventions are mismatched, as described previously. Therefore you must cast the objc_msgSend function to a prototype that matches the method function being called.</p>
</blockquote>
<blockquote>
<p>If you pass a function pointer in your code, its calling conventions must stay consistent. It should always take the same set of parameters. Never cast a variadic function to a function that takes a fixed number of parameters (or vice versa). Listing 2-13 is an example of a problematic piece function call. Because the function pointer was cast to use a different set of calling conventions, a caller is going to place the parameters in a place that the called function is not expecting. This mismatch may cause your app to crash or to exhibit other unpredictable behaviors.</p>
</blockquote>
<h4 id="什么是Calling-Convention？"><a href="#什么是Calling-Convention？" class="headerlink" title="什么是Calling Convention？"></a>什么是Calling Convention？</h4><p>顾名思义，Calling Convention（调用约定）即一个函数调用另一个函数时的约定，包括了参数如何传递、如何从函数返回结果等，编译器必须严格遵循调用约定进行代码编译，这样才能保证生成的代码能够正确地运行。想了解更多有关Calling Convention的内容，请戳这里：<a href="https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html#//apple_ref/doc/uid/TP40013702-SW1" target="_blank" rel="noopener">ARM64 Function Calling Conventions</a></p>
<p>其实，objc_msgSend函数之所以用汇编实现，不仅仅是出于性能的考虑，我们知道objc_msgSend是一个特殊的函数，它被设计可以接收任意数量和类型的参数并可以返回任意类型的值，比如：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> b = [array containsObject:obj];</span><br><span class="line"><span class="built_in">NSUInteger</span> n = [array count];</span><br><span class="line"><span class="comment">// 上述代码会被转换成以下函数调用</span></span><br><span class="line"><span class="built_in">BOOL</span> b = (<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))objc_msgSend(array, <span class="keyword">@selector</span>(containsObject), obj);</span><br><span class="line"><span class="built_in">NSUInteger</span> n = (<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))objc_msgSend(array, <span class="keyword">@selector</span>(containsObject));</span><br></pre></td></tr></table></figure>
<p>当objc_msgSend通过selector找到对应的IMP后，只需要通过传入的参数和相应的IMP函数指针调用即可。Objective-C中有各种参数类型、数量的方法调用，objc_msgSend就必须支持任意参数类型、数量和任意返回值的函数调用，如果用C语言实现，就必须加很多switch分支，把所有的参数类型、数量的组合全都覆盖到，这显然是不可能实现的。</p>
<p>Apple的解决办法是，通过不同的Calling Convention，将objc_msgSend开始执行时所需要的栈帧（stack frame）的状态，各寄存器的参数、组合形式和状态设置等都交给编译器来设置，这样就保证了调用objc_msgSend函数时，栈和各个寄存器中的数据、状态正是调用具体函数时所需要的。</p>
<blockquote>
<p>当objc_msgSend找到要调用的函数实现IMP后，只需要把所有的对栈、寄存器的操作“倒”回到objc_msgSend执行开始的状态（类似于函数执行完成return返回前，做的“收尾处理”工作一样，即epilogue），直接jump/call到IMP函数指针对应的地址，执行指令即可，因为所有的参数已经被设置好了。</p>
</blockquote>
<blockquote>
<p>同时，当IMP执行完成后，返回值也被正确的设置好了（在x86平台上，返回值被设置到了指定的寄存器eax/rax里，在arm上，则是r0寄存器），所以，我们也不必担心不同类型的返回值问题了。</p>
</blockquote>
<h4 id="objc-msgSend函数汇编源码分析"><a href="#objc-msgSend函数汇编源码分析" class="headerlink" title="objc_msgSend函数汇编源码分析"></a>objc_msgSend函数汇编源码分析</h4><p>objc_msgSend函数的主要作用是：</p>
<ol>
<li>根据传入的对象，获取其isa指针，并根据isa指针找到对象所属的类</li>
<li>获取类的方法缓存，并根据selector从缓存中查找对应的IMP</li>
<li>如果从缓存中找到IMP，直接调用</li>
<li>如果没有从缓存中找到，调用C函数（__class_lookupMethodAndLoadCache3）继续查询，并将查询结果存入类的方法缓存</li>
</ol>
<p>首先看下objc_msgSend的完整指令（在lldb中输入disassemble -n objc_msgSend -c 100 -b命令）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718900</span> &lt;+<span class="number">0</span>&gt;:   <span class="number">0xf100001f</span>   cmp    x0, <span class="meta">#0x0                  ; =0x0 </span></span><br><span class="line"><span class="number">0x180718904</span> &lt;+<span class="number">4</span>&gt;:   <span class="number">0x5400034d</span>   b.le   <span class="number">0x18071896c</span>               ; &lt;+<span class="number">108</span>&gt;</span><br><span class="line"><span class="number">0x180718908</span> &lt;+<span class="number">8</span>&gt;:   <span class="number">0xf940000d</span>   ldr    x13, [x0]</span><br><span class="line"><span class="number">0x18071890c</span> &lt;+<span class="number">12</span>&gt;:  <span class="number">0x927d81b0</span>   and    x16, x13, <span class="meta">#0xffffffff8</span></span><br><span class="line"><span class="number">0x180718910</span> &lt;+<span class="number">16</span>&gt;:  <span class="number">0xa9412e0a</span>   ldp    x10, x11, [x16, <span class="meta">#0x10]</span></span><br><span class="line"><span class="number">0x180718914</span> &lt;+<span class="number">20</span>&gt;:  <span class="number">0x0a0b002c</span>   and    w12, w1, w11</span><br><span class="line"><span class="number">0x180718918</span> &lt;+<span class="number">24</span>&gt;:  <span class="number">0x8b0c114c</span>   add    x12, x10, x12, lsl <span class="meta">#4</span></span><br><span class="line"><span class="number">0x18071891c</span> &lt;+<span class="number">28</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br><span class="line"><span class="number">0x180718920</span> &lt;+<span class="number">32</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x180718924</span> &lt;+<span class="number">36</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x18071892c</span>               ; &lt;+<span class="number">44</span>&gt;</span><br><span class="line"><span class="number">0x180718928</span> &lt;+<span class="number">40</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x18071892c</span> &lt;+<span class="number">44</span>&gt;:  <span class="number">0xb40016a9</span>   cbz    x9, <span class="number">0x180718c00</span>           ; _objc_msgSend_uncached</span><br><span class="line"><span class="number">0x180718930</span> &lt;+<span class="number">48</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x180718934</span> &lt;+<span class="number">52</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718940</span>               ; &lt;+<span class="number">64</span>&gt;</span><br><span class="line"><span class="number">0x180718938</span> &lt;+<span class="number">56</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x18071893c</span> &lt;+<span class="number">60</span>&gt;:  <span class="number">0x17fffff9</span>   b      <span class="number">0x180718920</span>               ; &lt;+<span class="number">32</span>&gt;</span><br><span class="line"><span class="number">0x180718940</span> &lt;+<span class="number">64</span>&gt;:  <span class="number">0x8b2b518c</span>   add    x12, x12, w11, uxtw <span class="meta">#4</span></span><br><span class="line"><span class="number">0x180718944</span> &lt;+<span class="number">68</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br><span class="line"><span class="number">0x180718948</span> &lt;+<span class="number">72</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x18071894c</span> &lt;+<span class="number">76</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x180718954</span>               ; &lt;+<span class="number">84</span>&gt;</span><br><span class="line"><span class="number">0x180718950</span> &lt;+<span class="number">80</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x180718954</span> &lt;+<span class="number">84</span>&gt;:  <span class="number">0xb4001569</span>   cbz    x9, <span class="number">0x180718c00</span>           ; _objc_msgSend_uncached</span><br><span class="line"><span class="number">0x180718958</span> &lt;+<span class="number">88</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x18071895c</span> &lt;+<span class="number">92</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718968</span>               ; &lt;+<span class="number">104</span>&gt;</span><br><span class="line"><span class="number">0x180718960</span> &lt;+<span class="number">96</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x180718964</span> &lt;+<span class="number">100</span>&gt;: <span class="number">0x17fffff9</span>   b      <span class="number">0x180718948</span>               ; &lt;+<span class="number">72</span>&gt;</span><br><span class="line"><span class="number">0x180718968</span> &lt;+<span class="number">104</span>&gt;: <span class="number">0x140000a6</span>   b      <span class="number">0x180718c00</span>               ; _objc_msgSend_uncached</span><br><span class="line"><span class="number">0x18071896c</span> &lt;+<span class="number">108</span>&gt;: <span class="number">0x540001c0</span>   b.eq   <span class="number">0x1807189a4</span>               ; &lt;+<span class="number">164</span>&gt;</span><br><span class="line"><span class="number">0x180718970</span> &lt;+<span class="number">112</span>&gt;: <span class="number">0xd2fe000a</span>   mov    x10, <span class="meta">#-0x1000000000000000</span></span><br><span class="line"><span class="number">0x180718974</span> &lt;+<span class="number">116</span>&gt;: <span class="number">0xeb0a001f</span>   cmp    x0, x10</span><br><span class="line"><span class="number">0x180718978</span> &lt;+<span class="number">120</span>&gt;: <span class="number">0x540000c2</span>   b.hs   <span class="number">0x180718990</span>               ; &lt;+<span class="number">144</span>&gt;</span><br><span class="line"><span class="number">0x18071897c</span> &lt;+<span class="number">124</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718980</span> &lt;+<span class="number">128</span>&gt;: <span class="number">0x9109c14a</span>   add    x10, x10, <span class="meta">#0x270          ; =0x270 </span></span><br><span class="line"><span class="number">0x180718984</span> &lt;+<span class="number">132</span>&gt;: <span class="number">0xd37cfc0b</span>   lsr    x11, x0, <span class="meta">#60</span></span><br><span class="line"><span class="number">0x180718988</span> &lt;+<span class="number">136</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x18071898c</span> &lt;+<span class="number">140</span>&gt;: <span class="number">0x17ffffe1</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br><span class="line"><span class="number">0x180718990</span> &lt;+<span class="number">144</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718994</span> &lt;+<span class="number">148</span>&gt;: <span class="number">0x910bc14a</span>   add    x10, x10, <span class="meta">#0x2f0          ; =0x2f0 </span></span><br><span class="line"><span class="number">0x180718998</span> &lt;+<span class="number">152</span>&gt;: <span class="number">0xd374ec0b</span>   ubfx   x11, x0, <span class="meta">#52, #8</span></span><br><span class="line"><span class="number">0x18071899c</span> &lt;+<span class="number">156</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x1807189a0</span> &lt;+<span class="number">160</span>&gt;: <span class="number">0x17ffffdc</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br><span class="line"><span class="number">0x1807189a4</span> &lt;+<span class="number">164</span>&gt;: <span class="number">0xd2800001</span>   mov    x1, <span class="meta">#0x0</span></span><br><span class="line"><span class="number">0x1807189a8</span> &lt;+<span class="number">168</span>&gt;: <span class="number">0x2f00e400</span>   movi   d0, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189ac</span> &lt;+<span class="number">172</span>&gt;: <span class="number">0x2f00e401</span>   movi   d1, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b0</span> &lt;+<span class="number">176</span>&gt;: <span class="number">0x2f00e402</span>   movi   d2, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b4</span> &lt;+<span class="number">180</span>&gt;: <span class="number">0x2f00e403</span>   movi   d3, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b8</span> &lt;+<span class="number">184</span>&gt;: <span class="number">0xd65f03c0</span>   ret    </span><br><span class="line"><span class="number">0x1807189bc</span> &lt;+<span class="number">188</span>&gt;: <span class="number">0xd503201f</span>   nop</span><br></pre></td></tr></table></figure>
<p>完整的objc_msgSend流程包括了对receiver为空、<a href="https://juejin.im/post/58fe0c6561ff4b006671e789" target="_blank" rel="noopener">Tagged Pointer</a>、正常对象的判断，方法缓存命中、非命中等不同情况的处理，我们先从正常的情况开始分析，即：receiver非nil且非Tagged Pointer对象、并且在类的方法缓存中查找到对应的实现。</p>
<h5 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718900</span> &lt;+<span class="number">0</span>&gt;:   <span class="number">0xf100001f</span>   cmp    x0, <span class="meta">#0x0                  ; =0x0 </span></span><br><span class="line"><span class="number">0x180718904</span> &lt;+<span class="number">4</span>&gt;:   <span class="number">0x5400034d</span>   b.le   <span class="number">0x18071896c</span>               ; &lt;+<span class="number">108</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这两个指令是对存储在x0寄存器中的receiver与0进行比较，如果receiver小于等于0，跳转到第108行指令处，执行receiver == nil || Tagged Pointer流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718908</span> &lt;+<span class="number">8</span>&gt;:   <span class="number">0xf940000d</span>   ldr    x13, [x0]</span><br></pre></td></tr></table></figure>
<p>这条指令是加载receiver的第一个64bit(ARM64架构下)指针到x13寄存器。由于所有继承自NSObject的类实例化后的对象都会包含一个类型为isa_t的结构体（即，isa指针），该指针存在对象的第一个字中，因此，x13中保存的即是receiver的isa指针。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071890c</span> &lt;+<span class="number">12</span>&gt;:  <span class="number">0x927d81b0</span>   and    x16, x13, <span class="meta">#0xffffffff8</span></span><br></pre></td></tr></table></figure>
<p>由于ARM64可以使用非指针的isa(比如Tagged Pointer对象)，通常情况下，对象的isa指针指向的是对象的类，但是Tagged Pointer的isa利用了备用的bit位（比如，正常的OC对象地址的最高位为0，如果为1则表示对象是Tagged Pointer对象，而如果对象地址的最高4位位0xf，则代表该对象是用户自定义的Tagged Pointer对象，否则是系统自带的Tagged Pointer对象，如NSNumber、NSDate等），因此，这里通过isa指针与0xffffffff8得到receiver所属的Class对象obj_class，并将其保存到x16寄存器。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718910</span> &lt;+<span class="number">16</span>&gt;:  <span class="number">0xa9412e0a</span>   ldp    x10, x11, [x16, <span class="meta">#0x10]</span></span><br></pre></td></tr></table></figure>
<p>这个指令是从Class对象偏移16的地址处加载数据到x10,x11两个寄存器中，我们看下obj_class结构体的构成：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class对象首地址偏移16刚好指向cache_t,因此这条指令是将类的方法缓存加载到寄存器中，具体来说就是将_buckets加载到x10中，将_mask加载到x11的低32位，将_occupied加载到x11的高32位。cache_t的结构如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint32_t mask_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">    SEL selector;   <span class="comment">// selector</span></span><br><span class="line">    IMP imp;        <span class="comment">// 方法实现对应的函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;  <span class="comment">//缓存方法的哈希桶数组指针，桶的数量 = mask + 1</span></span><br><span class="line">    mask_t _mask;  <span class="comment">//描述了哈希表的尺寸，方便用于与运算的掩码。它的值总是一个2的幂减一，用二进制的方法描述看起来就像是000000001111111，末尾是可变数量的1。通过这个值可以知道selector的查找索引，并在查找表的时候包裹着结尾。</span></span><br><span class="line">    mask_t _occupied;           <span class="comment">//哈希表中的条目。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718914</span> &lt;+<span class="number">20</span>&gt;:  <span class="number">0x0a0b002c</span>   and    w12, w1, w11</span><br></pre></td></tr></table></figure>
<p>从上文介绍的内容知道，x1中存储的是selector，而w1代表了x1寄存器的低32位，w11位x11寄存器的低32位，因此这条指令将selector的低32位与上面提到的_mask进行与运算并将结果放入x12寄存器的低32位，结果相当于是计算selector % table_size，但是避免了开销很大的模运算。这条指令的作用是计算selector的起始哈希表的索引</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718918</span> &lt;+<span class="number">24</span>&gt;:  <span class="number">0x8b0c114c</span>   add    x12, x10, x12, lsl <span class="meta">#4</span></span><br></pre></td></tr></table></figure>
<p>有了索引，再取得地址我们就可以从哈希表中加载数据了。这条指令通过_buckets的地址结合上面得到的索引取得要查找的bucket地址。lsl #4是逻辑左移，相当于乘以16，由于每个bucket的大小是16Bytes，此时x12中刚好保存了第一个要查找的bucket的地址。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071891c</span> &lt;+<span class="number">28</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure>
<p>这条指令将当前bucket的selector加载到x9，将IMP加载到x17中。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718920</span> &lt;+<span class="number">32</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x180718924</span> &lt;+<span class="number">36</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x18071892c</span>               ; &lt;+<span class="number">44</span>&gt;</span><br><span class="line"><span class="number">0x180718928</span> &lt;+<span class="number">40</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x18071892c</span> &lt;+<span class="number">44</span>&gt;:  <span class="number">0xb40016a9</span>   cbz    x9, <span class="number">0x180718c00</span>           ;</span><br></pre></td></tr></table></figure>
<p>将当前receiver的selector与从bucket找到的selector进行比较，如果二者相等，则无条件跳转到x17,执行目标函数，至此，objc_msgSend的FAST_EXIT结束。<br>如果二者不相等，跳转到第44个指令，这条指令先是用当前查找的bucket的selector和0作比较，如果等于0则跳转到<strong>objc_msgSend_uncached。这说明这是一个空的bucket，并且意味着这次查找失败了。目标方法不在缓存中，这时候会回到C代码(</strong>objc_msgSend_uncached)，执行更详细的查找。否则就说明bucket不是空的，只是没有匹配，则继续查找。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718930</span> &lt;+<span class="number">48</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x180718934</span> &lt;+<span class="number">52</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718940</span>               ; &lt;+<span class="number">64</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>FLAG：</strong>将x12中的bucket地址与x10中的哈希表起始地址作比较，如果不相等，继续执行下面的指令，</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718938</span> &lt;+<span class="number">56</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x18071893c</span> &lt;+<span class="number">60</span>&gt;:  <span class="number">0x17fffff9</span>   b      <span class="number">0x180718920</span>               ; &lt;+<span class="number">32</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里可以看到一个循环，不断地从哈希表中取出新的bucket，执行第32条指令，直到找到匹配的bucket或者空的bucket或者命中表的开头。这条指令中，地址引用末尾的感叹号是一个有趣的特性。这指定一个寄存器进行回写，意思就是寄存器会更新为计算后的值。</p>
<p>如果<strong>FLAG</strong>处的比较结果相同，执行以下指令</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718940</span> &lt;+<span class="number">64</span>&gt;:  <span class="number">0x8b2b518c</span>   add    x12, x12, w11, uxtw <span class="meta">#4</span></span><br><span class="line"><span class="number">0x180718944</span> &lt;+<span class="number">68</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br><span class="line"><span class="number">0x180718948</span> &lt;+<span class="number">72</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x18071894c</span> &lt;+<span class="number">76</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x180718954</span>               ; &lt;+<span class="number">84</span>&gt;</span><br><span class="line"><span class="number">0x180718950</span> &lt;+<span class="number">80</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x180718954</span> &lt;+<span class="number">84</span>&gt;:  <span class="number">0xb4001569</span>   cbz    x9, <span class="number">0x180718c00</span>           ; _objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>x12包含了当前bucket的指针，此时x12指向的是第一个bucket。w11包含了表的掩码，即表的大小。这里将两个值做了相加，同时将w11左移4位。现在x12中的结果是指向表的末尾，并且从这里可以恢复查找。然后执行ldp指令加载一个新的bucket到x9和x17寄存器，并检查该bucket是否与receiver的selector匹配，如果匹配，跳转到x17执行IMP，否则判断当前bucke是否为空bucket，如果为空，执行_objc_msgSend_uncached流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718958</span> &lt;+<span class="number">88</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x18071895c</span> &lt;+<span class="number">92</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718968</span>               ; &lt;+<span class="number">104</span>&gt;</span><br><span class="line"><span class="number">0x180718960</span> &lt;+<span class="number">96</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x180718964</span> &lt;+<span class="number">100</span>&gt;: <span class="number">0x17fffff9</span>   b      <span class="number">0x180718948</span>               ; &lt;+<span class="number">72</span>&gt;</span><br><span class="line"><span class="number">0x180718968</span> &lt;+<span class="number">104</span>&gt;: <span class="number">0x140000a6</span>   b      <span class="number">0x180718c00</span>               ; _objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>再一次检查是否已到哈希表的表头，如果没有到表头，则重复上述步骤继续查找bucket；如果再次命中表头，跳转到104行指令处执行_objc_msgSend_uncached流程，调用C函数进行全面查找（SLOW_EXIT）。</p>
<blockquote>
<p>额外的二次扫描检查是为了在遇到内存被破坏或者无效对象时，防止陷入无限循环而榨干性能。举个例子，堆损坏能够在缓存中塞满非0的数据，或者设置缓存的掩码为0，缓存不命中就会一直循环执行缓存扫描。额外的检查可以停止循环，将问题转变为崩溃日志。</p>
</blockquote>
<blockquote>
<p>还有一种情况，当有另一个线程同时修改缓存时会引起这个线程即不命中也不miss。C代码做了额外的工作来解决竞争。之前一个版本的objc_msgSend的做法是错误的，它会立即终止，而不是回到C代码，这样做的话运气不好的时候会发生罕见的崩溃。</p>
</blockquote>
<h5 id="receiver为nil时"><a href="#receiver为nil时" class="headerlink" title="receiver为nil时"></a>receiver为nil时</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071896c</span> &lt;+<span class="number">108</span>&gt;: <span class="number">0x540001c0</span>   b.eq   <span class="number">0x1807189a4</span>               ; &lt;+<span class="number">164</span>&gt;</span><br><span class="line"><span class="number">0x1807189a4</span> &lt;+<span class="number">164</span>&gt;: <span class="number">0xd2800001</span>   mov    x1, <span class="meta">#0x0</span></span><br><span class="line"><span class="number">0x1807189a8</span> &lt;+<span class="number">168</span>&gt;: <span class="number">0x2f00e400</span>   movi   d0, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189ac</span> &lt;+<span class="number">172</span>&gt;: <span class="number">0x2f00e401</span>   movi   d1, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b0</span> &lt;+<span class="number">176</span>&gt;: <span class="number">0x2f00e402</span>   movi   d2, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b4</span> &lt;+<span class="number">180</span>&gt;: <span class="number">0x2f00e403</span>   movi   d3, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b8</span> &lt;+<span class="number">184</span>&gt;: <span class="number">0xd65f03c0</span>   ret</span><br></pre></td></tr></table></figure>
<p>当receiver为nil时，仅仅是将x0、x1、d0~d3寄存器的值设置为0（整型的返回值被保存在x0、x1中，浮点数返回值被保存在向量寄存器v0~v3中），然后返回给调用者。不清除x0是因为此时receiver为nil，x0中本来就是0。</p>
<h5 id="receiver为Tagged-Pointer时"><a href="#receiver为Tagged-Pointer时" class="headerlink" title="receiver为Tagged Pointer时"></a>receiver为Tagged Pointer时</h5><blockquote>
<p>简单讨论下tagged pointer是如何工作的。tagged pointer支持多个类。tagged pointer的前四位（ARM 64上）指明对象的类是哪个。本质上就是tagged pointer的isa。当然4位不够保存一个类的指针。实际上，有一张特殊的表存储了可用的tagged pointer的类。这个对象的类的查找是通过搜索这张表中的索引，是否对应于这个tagged pointer的前4位。</p>
</blockquote>
<blockquote>
<p>tagged pointer（至少在AMR64上）也支持扩展类。当前四位都设置为1，接下去的8位用于索引tagged pointer扩展类的表。减少存储他们的代价，就允许运行时能够支持更多的tagged pointer类。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718970</span> &lt;+<span class="number">112</span>&gt;: <span class="number">0xd2fe000a</span>   mov    x10, <span class="meta">#-0x1000000000000000</span></span><br><span class="line"><span class="number">0x180718974</span> &lt;+<span class="number">116</span>&gt;: <span class="number">0xeb0a001f</span>   cmp    x0, x10</span><br><span class="line"><span class="number">0x180718978</span> &lt;+<span class="number">120</span>&gt;: <span class="number">0x540000c2</span>   b.hs   <span class="number">0x180718990</span>               ; &lt;+<span class="number">144</span>&gt;</span><br></pre></td></tr></table></figure>
<p>x10被设置成一个整型值，只有前4位被设置为1，其余位都为0。x10被用作掩码从receiver中提取标志位，检查是否用户扩展的Tagged Pointer，如果receiver大于等于x10，则表示当前receiver为扩展的Tagged Pointer，跳转到144条指令处进行处理。否则说明receiver是系统自带的Tagged Pointer类型对象。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071897c</span> &lt;+<span class="number">124</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718980</span> &lt;+<span class="number">128</span>&gt;: <span class="number">0x9109c14a</span>   add    x10, x10, <span class="meta">#0x270          ; =0x270</span></span><br></pre></td></tr></table></figure>
<p>1、系统自带Tagged Pointer类型对象的流程， 这里加载了系统Tagged Pointer主表到x10。</p>
<blockquote>
<p>ARM64需要两条指令来加载一个符号的地址。这是RISC样架构上的一个标准技术。AMR64上的指针是64位宽的，指令是32位宽。所以一个指令无法保存一个完整的指针。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718984</span> &lt;+<span class="number">132</span>&gt;: <span class="number">0xd37cfc0b</span>   lsr    x11, x0, <span class="meta">#60</span></span><br><span class="line"><span class="number">0x180718988</span> &lt;+<span class="number">136</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x18071898c</span> &lt;+<span class="number">140</span>&gt;: <span class="number">0x17ffffe1</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br></pre></td></tr></table></figure>
<p>由于系统自带的Tagged Pointer对象的索引保存在对象地址的60~63位，这里将receiver的地址右移60位取得索引并保存到x11中，然后根据该索引从x10的系统Tagged Pointer主表中获取到对象的isa指针并存入x16寄存器，然后跳转到第16条指令处执行后续的方法缓存查找等流程。</p>
<p>2、用户扩展的Tagged Pointer对象的执行流程也是类似的</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718990</span> &lt;+<span class="number">144</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718994</span> &lt;+<span class="number">148</span>&gt;: <span class="number">0x910bc14a</span>   add    x10, x10, <span class="meta">#0x2f0          ; =0x2f0 </span></span><br><span class="line"><span class="number">0x180718998</span> &lt;+<span class="number">152</span>&gt;: <span class="number">0xd374ec0b</span>   ubfx   x11, x0, <span class="meta">#52, #8</span></span><br><span class="line"><span class="number">0x18071899c</span> &lt;+<span class="number">156</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x1807189a0</span> &lt;+<span class="number">160</span>&gt;: <span class="number">0x17ffffdc</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br></pre></td></tr></table></figure>
<p>不同的是扩展的Tagged Pointer对象的索引保存在对象地址的52~59位，这里用了一个位域提取指令ubfx提取对象地址的52~59位作为索引存入x11寄存器中，然后通过索引取得对象的isa指针，并进行后续的方法缓存查找等流程。</p>
<h3 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h3><hr>
<p>以上就是objc_msgSend函数的汇编分析的所有内容。理解objc_msgSend的实现原理，有助于我们深入理解Runtime机制、定位程序BUG等。<br>这篇文章只是浅显地分析了objc_msgSend函数的汇编实现，其中用到的的诸如Calling Convention、使用Compiler Memory Barrier（编译内存屏障）实现方法缓存的无锁读写同步的技术、使用享元设计模式从Tagged Pointer对象中获取isa等等都值得我们更深入地研究。</p>
<p><strong>参考文章</strong></p>
<ul>
<li><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm64.s.auto.html" target="_blank" rel="noopener">objc-msg-arm64.s源码</a></li>
<li><a href="https://draveness.me/isa" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html#//apple_ref/doc/uid/TP40013702-SW1" target="_blank" rel="noopener">iOS ABI Function Call Guide</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaTouch64BitGuide/ConvertingYourAppto64-Bit/ConvertingYourAppto64-Bit.html#//apple_ref/doc/uid/TP40013501-CH3-SW26" target="_blank" rel="noopener">64-Bit Transition Guide for Cocoa Touch</a></li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">Procedure Call Standard for the ARM 64-bit Architecture</a></li>
<li><a href="http://www.arigrant.com/blog/2014/2/12/why-objcmsgsend-must-be-written-in-assembly" target="_blank" rel="noopener">Why objc_msgSend Must be Written in Assembly</a></li>
<li><a href="https://www.jianshu.com/p/df6629ec9a25" target="_blank" rel="noopener">深入解构objc_msgSend函数的实现</a></li>
<li><a href="http://www.cocoachina.com/ios/20170802/20102.html" target="_blank" rel="noopener">剖析ARM64下的objc_msgSend</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/最长回文子串的4种解法（swift实现）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/最长回文子串的4种解法（swift实现）/" itemprop="url">最长回文子串的4种解法（swift实现）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T15:59:02+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/03/最长回文子串的4种解法（swift实现）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/03/最长回文子串的4种解法（swift实现）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/iOS页面优化经验总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/iOS页面优化经验总结/" itemprop="url">iOS页面优化经验总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-11T11:30:06+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/11/iOS页面优化经验总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/05/11/iOS页面优化经验总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><hr>
<p>前段时间接到了一个页面优化任务，一个选座的页面，要求峰值支持100*100个座位，并提高页面滑动的流畅度、内存占用率和加载速度等指标<br><img src="/2018/05/11/iOS页面优化经验总结/1.png" alt="页面样式"><br>前前后后做了一个月左右的时间，这里总结一下优化经验以供参考。</p>
<h3 id="二、分析问题"><a href="#二、分析问题" class="headerlink" title="二、分析问题"></a>二、分析问题</h3><hr>
<h5 id="1、该页面的问题所在"><a href="#1、该页面的问题所在" class="headerlink" title="1、该页面的问题所在"></a>1、该页面的问题所在</h5><p>之前该页面的是由一系列UIButton结合drawRect实现，在从服务器拉取到数据后，计算出每个座位的frame并在相应的位置创建一个button代表该座位，所有座位加载完成后在左上角显示整体座位的缩略图。</p>
<p>这个过程有以下问题：</p>
<ol>
<li>所有的操作都是在主线程进行，当座位较少时用户体验还好，但是当座位数增加到100*100个后，用户进入该页面后要卡住3~4s才能进行操作（在iPhone 5s上测试），用户体验较差；</li>
<li>大量的UIButton对象的创建，加重了CPU的负担并增加了内存消耗，当内存紧张时App容易被系统杀掉；而且大量的纹理渲染和视图混合等也加重了GPU的负担，造成滑动时掉帧。</li>
<li>使用snapshotViewAfterScreenUpdates创建缩略图，当座位图足够大时，很有可能超过GPU的最大纹理尺寸（参考：<a href="http://iosres.com/" target="_blank" rel="noopener">各机型的最大纹理尺寸</a>），此时使用snapshotViewAfterScreenUpdates只能获取到一个空白的视图（具体原因待深究）。</li>
</ol>
<h5 id="2、着手解决问题"><a href="#2、着手解决问题" class="headerlink" title="2、着手解决问题"></a>2、着手解决问题</h5><p>分析了问题之后，可以从以下几个方面对页面进行优化：</p>
<ol>
<li>减少视图层级和对象的创建</li>
<li>尽量将绘制任务放到后台线程中执行</li>
<li>如果必须在主线程中执行，将任务分散到主线程RunLoop的各个空闲状态中执行，以保证页面的流畅</li>
</ol>
<h3 id="三、准备知识"><a href="#三、准备知识" class="headerlink" title="三、准备知识"></a>三、准备知识</h3><hr>
<h5 id="1、如何将像素显示到屏幕上"><a href="#1、如何将像素显示到屏幕上" class="headerlink" title="1、如何将像素显示到屏幕上"></a>1、如何将像素显示到屏幕上</h5><p>首先看一张图片<br><img src="/2018/05/11/iOS页面优化经验总结/2.png" alt=""><br>这张图片简单描述了CPU与GPU的协同工作流程：CPU将计算并绘制好的内容通过总线提交给GPU，GPU对这些内容进行渲染（GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)）并由视频控制器将渲染结果显示到屏幕上。虽然GPU的浮点运算非常高效，但是在1/60s（大约16.7ms）时间内能执行的操作也很有限，因此为了保证60FPS的帧率，尽量不要将复杂的渲染任务提交给GPU。</p>
<h5 id="2、CPU参与的任务"><a href="#2、CPU参与的任务" class="headerlink" title="2、CPU参与的任务"></a>2、CPU参与的任务</h5><ul>
<li><p><strong>对象的创建、销毁和属性调整</strong><br>优化时尽量使用轻量级的对象，比如用CALyer代替UIView；如果对象的创建不涉及UI操作，尽量放到后台线程中执行；使用懒加载，推迟对象的创建时间；使用Storyboard创建视图对象时，消耗的资源比通过代码直接创建视图要大的多，因此，尽量使用代码创建视图对象。</p>
</li>
<li><p><strong>AutoLayout</strong><br>大部分情况下AutoLayout能很好的提升开发效率，但是对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，AutoLayout 带来的 CPU 消耗会呈指数级上升（<a href="http://pilky.me/36/" target="_blank" rel="noopener">http://pilky.me/36/</a>）。如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
</li>
<li><p><strong>视图的布局计算</strong><br>可以在后台线程中计算视图的布局并进行缓存。所有视图的调整最终会落到UIView.bounds/frame/center等属性上面，上文说过，对象的属性调整会消耗大量的CPU资源，因此尽量一次性地调整好视图的布局，避免频繁地调整这些属性。</p>
</li>
<li><p><strong>文本计算、文本渲染</strong><br>文本的宽、高计算会占用大量的CPU资源，并且是不可避免的，通常的文本显示控件（如：UILabel、UITextView等）其排版和绘制都是在主线程中进行的，当文本量较大时，会占用较大的CPU资源。优化的方法只有一个：自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
</li>
<li><p><strong>图片解码</strong><br>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码，这一步是发生在主线程的，并且不可避免。可以参考的优化方法：在后台线程中将图片绘制到CGBitmapContext中，并直接从Bitmap中创建图片。</p>
</li>
<li><p><strong>图像绘制</strong><br>这里通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示的过程，如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢。由于CoreGraphic的方法通常是线程安全的，因此可以把绘制任务放到后台线程中进行，绘制完成后再在主线程中更新UI。</p>
</li>
</ul>
<h5 id="3、GPU参与的任务"><a href="#3、GPU参与的任务" class="headerlink" title="3、GPU参与的任务"></a>3、GPU参与的任务</h5><ul>
<li><p><strong>纹理的渲染</strong><br>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。</p>
</li>
<li><p><strong>视图的混合 (Composing)</strong><br>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
</li>
<li><p><strong>图形的生成</strong><br>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
</li>
</ul>
<h5 id="4、RunLoop"><a href="#4、RunLoop" class="headerlink" title="4、RunLoop"></a>4、RunLoop</h5><p>前面说过尽量把非UI相关的操作放到后台线程中执行，但是如果遇到UI相关的操作怎么办呢？苹果规定UI相关的操作必须放到主线程中执行。我曾经尝试过将CALayer的renderInContext方法放到后台线程中并发执行，虽然使用了@autoreleasepool{}，但是多次进出页面后，内存消耗始终有增无减，而且偶尔还会出现EXEC_BAD_ACCESS的异常。<br>那么对于这类只能在主线程中执行的耗时UI操作应该怎么优化呢？</p>
<blockquote>
<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。<br>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
</blockquote>
<p>在AppDelegate中的didFinishLaunchingWithOptions方法中，使用CFRunLoopGetCurrent()获取主线程的RunLoop可以得到如下输出（只截取相关部分，输出的内容中还可以看到有关AutoreleasePool的创建释放机制、用户事件的响应等，感兴趣的可以自己研究一下）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">CFRunLoopObserver</span> <span class="number">0x6000001256e0</span> [<span class="number">0x10f578c80</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xa0</span>, repeats = Yes, order = <span class="number">1999000</span>, callout = _beforeCACommitHandler (<span class="number">0x10c33fe01</span>), context = &lt;<span class="built_in">CFRunLoopObserver</span> context <span class="number">0x7fc6d9402b30</span>&gt;&#125;</span><br><span class="line">&lt;<span class="built_in">CFRunLoopObserver</span> <span class="number">0x6000001258c0</span> [<span class="number">0x10f578c80</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xa0</span>, repeats = Yes, order = <span class="number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="number">0x10be96672</span>), context = &lt;<span class="built_in">CFRunLoopObserver</span> context <span class="number">0x0</span>&gt;&#125;</span><br><span class="line">&lt;<span class="built_in">CFRunLoopObserver</span> <span class="number">0x600000125780</span> [<span class="number">0x10f578c80</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xa0</span>, repeats = Yes, order = <span class="number">2001000</span>, callout = _afterCACommitHandler (<span class="number">0x10c33fe7c</span>), context = &lt;<span class="built_in">CFRunLoopObserver</span> context <span class="number">0x7fc6d9402b30</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到App启动后，UIApplicationMain函数创建了主线程RunLoop并在其中添加了一个优先级为2000000（order = 2000000）的<br>observer，该优先级低于常见的其他observer，该observer监听RunLoop的kCFRunLoopBeforeWaiting和kCFRunLoopExit事件（activities = 0xa0）。这样，当RunLoop 即将进入休眠（或者退出）时，关注该observer会得到通知，然后将通过CATransaction提交的中间状态合并到GPU中处理并显示到屏幕上。该机制能很好地保证CA的流畅度。</p>
<p>我们可以模拟Core Animation的这个机制，在合适的时机把异步、并发的操作放到主线程中执行，以保证尽量不阻塞主线程。</p>
<h3 id="四、开始优化"><a href="#四、开始优化" class="headerlink" title="四、开始优化"></a>四、开始优化</h3><p>Talk is cheap, show me the code!</p>
<h6 id="1、异步计算并缓存布局"><a href="#1、异步计算并缓存布局" class="headerlink" title="1、异步计算并缓存布局"></a>1、异步计算并缓存布局</h6><p>这一步比较简单，使用GCD异步队列实现即可</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">                <span class="comment">// 计算布局</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<h6 id="2、减少视图层级、使用轻量级视图，异步绘制"><a href="#2、减少视图层级、使用轻量级视图，异步绘制" class="headerlink" title="2、减少视图层级、使用轻量级视图，异步绘制"></a>2、减少视图层级、使用轻量级视图，异步绘制</h6><p>之前的视图中每个座位用一个UIButton表示，对于100*100个座位就有1万个UIButton，视图数量过大。这里考虑以行为单位创建视图，并且每行使用Core Graphic框架异步绘制</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RowLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RowLayer</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setSeatFrames:(<span class="built_in">NSArray</span> *)seatFrames &#123;</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">self</span> drawLayerContentAsync];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)drawLayerContentAsync &#123;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.bounds.size.width, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> rgb = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, size.width, size.height, <span class="number">8</span>, <span class="number">0</span>, rgb, kCGImageAlphaPremultipliedLast);</span><br><span class="line">    dispatch_group_t drawGroup = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(drawGroup, dispatch_get_global_queue(QOS_CLASS_UTILITY, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// draw contents</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(drawGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">CGImageRef</span> contentImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">UIImage</span> *contentImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:contentImageRef];</span><br><span class="line">        <span class="built_in">CGColorSpaceRelease</span>(rgb);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(contentImageRef);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.contents = (__bridge <span class="keyword">id</span>)contentImage.CGImage;</span><br><span class="line">            <span class="comment">// other operations</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="3、RunLoop优化"><a href="#3、RunLoop优化" class="headerlink" title="3、RunLoop优化"></a>3、RunLoop优化</h6><p>对于较少的视图，获取其缩略图可以直接用snapshotViewAfterScreenUpdates方法，但是对于很大的视图，snapshotViewAfterScreenUpdates貌似不太好使。这里使用逐行截图，然后拼接的方法。</p>
<p>首先，创建RunLoopObserver和RunLoopSource并将其添加到主线程的RunLoop上</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">CFRunLoopSourceRef</span>)runLoopSource &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_runLoopSource) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext</span> sourceContext = &#123;&#125;;</span><br><span class="line">        _runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;sourceContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _runLoopSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">CFRunLoopObserverRef</span>)runLoopObserver &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_runLoopObserver) &#123;</span><br><span class="line">        @weakify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">void</span> (^handlerBlock) (<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) = ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>);</span><br><span class="line">            <span class="comment">// 绘制每行的缩略图</span></span><br><span class="line">            [<span class="keyword">self</span> executeRender];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// observer监听RunLoop的BeforeWaiting和Exit状态</span></span><br><span class="line">        _runLoopObserver = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="literal">NULL</span>, kCFRunLoopBeforeWaiting | kCFRunLoopExit, <span class="literal">true</span>, <span class="number">0</span>, handlerBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _runLoopObserver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到主线程RunLoop中</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="keyword">self</span>.runLoop, <span class="keyword">self</span>.runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="keyword">self</span>.runLoop, <span class="keyword">self</span>.runLoopSource, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<p>将每行的绘制操作封装并添加到队列中，每当self.runLoopObserver被回调时，从队列中取出一个绘制任务并执行</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">RenderBlock renderBlock = ^(__<span class="keyword">unsafe_unretained</span> <span class="built_in">CALayer</span> *layer, <span class="built_in">CGContextRef</span> thumnailCtx, <span class="built_in">CGContextRef</span> rowCtx) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">CGContextClearRect</span>(rowCtx, layer.bounds);</span><br><span class="line">            <span class="comment">// 获取行截图</span></span><br><span class="line">            [layer renderInContext:rowCtx];</span><br><span class="line">            <span class="built_in">CGImageRef</span> outputImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(rowCtx);</span><br><span class="line">            <span class="built_in">UIImage</span> *rowImage = [<span class="built_in">UIImage</span> imageWithCGImage:outputImageRef];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(outputImageRef);</span><br><span class="line">            <span class="comment">// 将行截图绘制到缩略图的context中</span></span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(thumnailCtx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, layer.frame.origin.y, layer.frame.size.width, layer.frame.size.height), rowImage.CGImage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 绘制任务加入队列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">CALayer</span> *layer <span class="keyword">in</span> view.layer.sublayers) &#123;</span><br><span class="line">        [_renderQueue addObject:renderBlock];</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="comment">// self.runLoopObserver被回调时执行的方法</span></span><br><span class="line">-(<span class="keyword">void</span>)executeRender &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.renderQueue) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.renderQueue.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列中所有任务执行完成，</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> fullImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(<span class="keyword">self</span>.thumnailDrawContext);</span><br><span class="line">        <span class="built_in">UIImage</span> *fullImage = [<span class="built_in">UIImage</span> imageWithCGImage:fullImageRef];</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(fullImageRef);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(<span class="keyword">self</span>.rowDrawContext);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(<span class="keyword">self</span>.thumnailDrawContext);</span><br><span class="line">        <span class="keyword">self</span>.rowDrawContext = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.thumnailDrawContext = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.renderQueue = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置缩略图</span></span><br><span class="line">        _thumnailLayer.backgroundColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">        _thumnailLayer.contents = (__bridge <span class="keyword">id</span>)fullImage.CGImage;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CALayer</span> *layer = <span class="keyword">self</span>.scrollView.subviews[<span class="number">0</span>].layer.sublayers[<span class="keyword">self</span>.renderOperationIndex];</span><br><span class="line">        <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RenderBlock renderBlock = [<span class="keyword">self</span>.renderQueue objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        renderBlock(layer, <span class="keyword">self</span>.thumnailDrawContext, <span class="keyword">self</span>.rowDrawContext);</span><br><span class="line">        [<span class="keyword">self</span>.renderQueue removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">self</span>.renderOperationIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、优化前后性能对比"><a href="#五、优化前后性能对比" class="headerlink" title="五、优化前后性能对比"></a>五、优化前后性能对比</h3><p>优化后能很好地支持1万个座位了，以下均为1万个座位时的性能对比</p>
<h5 id="1、支持的座位数量"><a href="#1、支持的座位数量" class="headerlink" title="1、支持的座位数量"></a>1、支持的座位数量</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">5000个座位（正常显示）</td>
<td style="text-align:center">5000个座位（正常显示）</td>
</tr>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">10000个座位（页面空白）</td>
<td style="text-align:center">10000个座位（正常显示）</td>
</tr>
</tbody>
</table>
<p>优化后1万个座位可以正常显示了，由于后台最多只能创建1万个座位，更多的座位数目无法测试。经过优化后理论上可以支持10万+的座位数。</p>
<h5 id="2、帧率"><a href="#2、帧率" class="headerlink" title="2、帧率"></a>2、帧率</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">40~45</td>
<td style="text-align:center">55~60</td>
</tr>
</tbody>
</table>
<h5 id="3、内存"><a href="#3、内存" class="headerlink" title="3、内存"></a>3、内存</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">230MB左右</td>
<td style="text-align:center">120MB左右</td>
</tr>
</tbody>
</table>
<p>优化前，重复进入、退出选座页面若干次后，App因内存消耗过大被系统kill；<br>优化后，重复上述操作若干次后，内存消耗比较稳定且没有出现闪退现象。</p>
<h5 id="4、页面卡顿时间"><a href="#4、页面卡顿时间" class="headerlink" title="4、页面卡顿时间"></a>4、页面卡顿时间</h5><table>
<thead>
<tr>
<th style="text-align:center">测试机型</th>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 5s</td>
<td style="text-align:center">3s左右</td>
<td style="text-align:center">0s</td>
</tr>
</tbody>
</table>
<p>优化前，进入选座页面后，数据加载完后要等待3s左右才能进行操作，在此期间App卡住且不响应任何用户操作；<br>优化后，进入选座页面后，数据加载完后可以立即响应用户操作，不存在卡顿时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/14/Reactive-Cocoa中-weakify、-strongify的原理以及如何避免block中的retain-cycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/14/Reactive-Cocoa中-weakify、-strongify的原理以及如何避免block中的retain-cycle/" itemprop="url">RAC中@weakify、@strongify的原理以及如何避免block中的retain cycle</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-14T21:33:20+08:00">
                2018-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/14/Reactive-Cocoa中-weakify、-strongify的原理以及如何避免block中的retain-cycle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/14/Reactive-Cocoa中-weakify、-strongify的原理以及如何避免block中的retain-cycle/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、block中的循环引用"><a href="#1、block中的循环引用" class="headerlink" title="1、block中的循环引用"></a>1、block中的循环引用</h3><p>在iOS开发中，如果self持有block，在block中对self进行显式或隐式的引用，都会出现retain cycle而导致内存泄漏，比如：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.someBlock = ^&#123;</span><br><span class="line">    <span class="comment">// 显式引用self</span></span><br><span class="line">    [<span class="keyword">self</span> doSomething];</span><br><span class="line">    <span class="comment">// 隐式引用self，_someProperty为self的某个属性</span></span><br><span class="line">    _someProperty = xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前，我们是这样解决的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.someBlock = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    [<span class="keyword">self</span> doSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在block外部使用weakSelf定义self的弱引用对象，然后在block内部对weakSelf进行一次强引用（防止执行到block块中代码的时候self被提前释放导致weakSelf为nil），由于strongSelf定义为局部变量，当其作用域结束后，strongSelf自动释放对self的强引用，从而避免了retain cycle。</p>
<h3 id="2、优雅的解决办法"><a href="#2、优雅的解决办法" class="headerlink" title="2、优雅的解决办法"></a>2、优雅的解决办法</h3><p>上述写法虽然足够严谨而且能有效地解决问题，但是每次都要写一长串的weakSelf和strongSelf定义着实麻烦。我们先看看RAC是如何优雅地解决的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">self</span>.someBlock = @&#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> doSomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很神奇，self还可以原封不动地使用，下面我们看看@weakify(self)和@strongify(self)这两个宏究竟有何神奇之处。</p>
<h3 id="3、-weakify-self-和-strongify-self-的作用"><a href="#3、-weakify-self-和-strongify-self-的作用" class="headerlink" title="3、@weakify(self)和@strongify(self)的作用"></a>3、@weakify(self)和@strongify(self)的作用</h3><p>首先看下@weakify(self)和@strongify(self)究竟做了哪些事情，打开Xcode看看进行宏替换后的代码：</p>
<p><img src="/2018/04/14/Reactive-Cocoa中-weakify、-strongify的原理以及如何避免block中的retain-cycle/image-20180415161622807.png" alt="preprocess代码对比"></p>
<p>​    ①、self_weak_部分与我们通常的写法一致：外部定义self的弱引用weakSelf，然后在block内部强引用这个weakSelf防止其提前释放；</p>
<p>​    ②、@autoreleasepool{}: weakify连同它前面的@一起组合成了@autoreleasepool{},虽然这个autoreleasepool啥事都没做。。。（后面进行分析）</p>
<p>​    ③、 <code>__attribute__((objc_ownership(weak)))</code> 这部分代码就是<code>__weak</code>被编译器替换后的结果（weakify这个宏的替换结果中包含<code>__weak</code>）</p>
<h4 id="4、-weakify-self-和-strongify-self-的原理"><a href="#4、-weakify-self-和-strongify-self-的原理" class="headerlink" title="4、@weakify(self)和@strongify(self)的原理"></a>4、@weakify(self)和@strongify(self)的原理</h4><p>首先，我们对@weakify(self)一层层展开：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define weakify(...) \</span></span><br><span class="line">    rac_keywordify \</span><br><span class="line">    metamacro_foreach_cxt(rac_weakify_,, __<span class="keyword">weak</span>, __VA_ARGS__)</span><br></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line"><span class="meta">#define rac_keywordify autoreleasepool &#123;&#125;</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define rac_keywordify try &#123;&#125; @catch (...) &#123;&#125;</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>在宏中，<code>…</code>表示多个参数，<code>__VA_ARGS__</code>则对应相应的参数。用上述定义进行替换后，@weakify(self)等同于下面的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;&#125;</span><br><span class="line">metamacro_foreach_cxt(rac_weakify_,, __<span class="keyword">weak</span>, <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define metamacro_foreach_cxt(MACRO, SEP, CONTEXT, ...) \</span></span><br><span class="line">        metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(__VA_ARGS__))(MACRO, SEP, CONTEXT, __VA_ARGS__)</span><br></pre></td></tr></table></figure>
<p>这里包括了几个宏：</p>
<ul>
<li>metamacro_concat：</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define metamacro_concat(A, B) \</span></span><br><span class="line">        metamacro_concat_(A, B)</span><br><span class="line"></span><br><span class="line"><span class="meta">#define metamacro_concat_(A, B) A ## B</span></span><br></pre></td></tr></table></figure>
<p>​    可以看到metamacro_concat的最终转换成宏连接符<code>##</code> </p>
<ul>
<li>metamacro_argcount：</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define metamacro_argcount(...) \</span></span><br><span class="line">        metamacro_at(<span class="number">20</span>, __VA_ARGS__, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#define metamacro_at(N, ...) \</span></span><br><span class="line">        metamacro_concat(metamacro_at, N)(__VA_ARGS__)</span><br></pre></td></tr></table></figure>
<p>这个宏的作用是根据metamacro_argcount的参数个数，将其替换成相应的数字，比如：</p>
<p>metamacro_argcount(self)会被替换成1, 下面一步步进行分析：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">首先RAC定义了如下的一些宏：</span><br><span class="line"><span class="meta">#define metamacro_at0(...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at1(_0, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at2(_0, _1, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at3(_0, _1, _2, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at4(_0, _1, _2, _3, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at5(_0, _1, _2, _3, _4, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at6(_0, _1, _2, _3, _4, _5, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#define metamacro_head(...) \</span></span><br><span class="line">        metamacro_head_(__VA_ARGS__, <span class="number">0</span>)</span><br><span class="line"><span class="meta">#define metamacro_head_(FIRST, ...) FIRST</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>、metamacro_argcount(<span class="keyword">self</span>)替换成：</span><br><span class="line">	metamacro_at(<span class="number">20</span>, <span class="keyword">self</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>、上述宏替换后：</span><br><span class="line">	metamacro_concat(metamacro_at, <span class="number">20</span>)(<span class="keyword">self</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>、上述宏替换后：</span><br><span class="line">	metamacro_at20(<span class="keyword">self</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>、上述宏替换后：</span><br><span class="line">    metamacro_head(<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span>、上述宏替换后：</span><br><span class="line">    metamacro_head_(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">6</span>、最终替换成：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>将这两个宏完成替换后得到：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metamacro_foreach_cxt1(rac_weakify_,, __<span class="keyword">weak</span>, <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<p>RAC中还定义了从metamacro_foreach_cxt0到metamacro_foreach_cxt20的一组宏：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define metamacro_foreach_cxt0(MACRO, SEP, CONTEXT)</span></span><br><span class="line"><span class="meta">#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \</span></span><br><span class="line">    metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) \</span><br><span class="line">    SEP \</span><br><span class="line">    MACRO(<span class="number">1</span>, CONTEXT, _1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#define metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \</span></span><br><span class="line">    metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \</span><br><span class="line">    SEP \</span><br><span class="line">    MACRO(<span class="number">2</span>, CONTEXT, _2)</span><br><span class="line"></span><br><span class="line"><span class="meta">#define metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \</span></span><br><span class="line">    metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \</span><br><span class="line">    SEP \</span><br><span class="line">    MACRO(<span class="number">3</span>, CONTEXT, _3)</span><br><span class="line">......</span><br><span class="line"><span class="meta">#define metamacro_foreach_cxt20(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19) \</span></span><br><span class="line">    metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \</span><br><span class="line">    SEP \</span><br><span class="line">    MACRO(<span class="number">19</span>, CONTEXT, _19)</span><br></pre></td></tr></table></figure>
<p>将metamacro_foreach_cxt1替换后得到：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rac_weakify(<span class="number">0</span>,__<span class="keyword">weak</span>,<span class="keyword">self</span>)</span><br><span class="line">    </span><br><span class="line">rac_weakify的定义如下：</span><br><span class="line"><span class="meta">#define rac_weakify_(INDEX, CONTEXT, VAR) \</span></span><br><span class="line">    CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);</span><br></pre></td></tr></table></figure>
<p>继续根据rac_weakify的定义替换后得到：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) self_weak_ = (<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">@weakify(<span class="keyword">self</span>)的完整形式：</span><br><span class="line"><span class="keyword">@autoreleasepool</span>&#123;&#125;</span><br><span class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) self_weak_ = (<span class="keyword">self</span>);</span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<p>同理，@strongify(self)这个宏最终展开成以下形式:</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span> __typeof__(<span class="keyword">self</span>) <span class="keyword">self</span> = self_weak_;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Cui Lanqing</p>
              <p class="site-description motion-element" itemprop="description">一枚有梦想的程序猿</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cui Lanqing</span>

  
</div>


  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'WCdYKBzVHyUAmYLBFSD0S1EM-gzGzoHsz',
        appKey: 'TeFriUwpGPw3n0GaJ9PSdzEh',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>

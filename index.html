<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="一枚有梦想的程序猿">
<meta name="keywords" content="iOS、前端">
<meta property="og:type" content="website">
<meta property="og:title" content="崔岚清的个人博客">
<meta property="og:url" content="https://chy305chy.github.io/index.html">
<meta property="og:site_name" content="崔岚清的个人博客">
<meta property="og:description" content="一枚有梦想的程序猿">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="崔岚清的个人博客">
<meta name="twitter:description" content="一枚有梦想的程序猿">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chy305chy.github.io/"/>





  <title>崔岚清的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">崔岚清的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">集跬步至千里，积小流成江海</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2019/01/18/iOS-Runtime随笔——weak原理探究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/iOS-Runtime随笔——weak原理探究/" itemprop="url">iOS Runtime随笔——weak原理探究</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T13:36:19+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/18/iOS-Runtime随笔——weak原理探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/18/iOS-Runtime随笔——weak原理探究/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>年底了 版本任务不太重，趁着空闲时间把runtime的底层原理探索一遍，本篇文章着重介绍weak的底层实现原理。</p>
<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) TestObject *weakObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">__<span class="keyword">weak</span> TestObject *weakObj = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">TestBlock block = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> __typeof__(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    <span class="comment">// do something inside the block</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信大家对上述代码不陌生，weak修饰对象表示对该对象的弱引用，弱引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被设置的为nil，同时避免了”野指针（或者suspend pointer）”的问题。在使用代理模式或者block时，为了避免引起retain cycle而导致内存泄露，我们通常使用weak关键字来打破循环引用链。</p>
<p>之前只是单纯的知道使用weak，但是对于更深层的原理，正文开始前，先提出三个问题：</p>
<ol>
<li>weak为什么不会增加对象的引用计数</li>
<li>weak对象存储在哪里</li>
<li>对象释放时其weak指针如何自动设置为nil</li>
</ol>
<p>现在带着这些问题来一探究竟。本系列文章使用的源码：<a href="https://opensource.apple.com/tarballs/objc4/objc4-750.tar.gz" target="_blank" rel="noopener">objc4-750</a></p>
<h3 id="二、存储结构分析"><a href="#二、存储结构分析" class="headerlink" title="二、存储结构分析"></a>二、存储结构分析</h3><p>先看下测试代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSObject</span> *weakObj = obj;</span><br></pre></td></tr></table></figure>
<p>在<code>__weak</code>出断点并单步运行，发现它实际上调用了<code>objc_initWeak</code>函数。</p>
<p>在runtime源码中找到相关函数的实现如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数有两个入参：</p>
<ul>
<li>location: __weak指针的地址</li>
<li>newObj: 需要进行弱引用的对象的指针</li>
</ul>
<p>实际上该函数只是一个更深层函数的入口，在调用更深层函数之前做了一些判断，如果newObj已经被释放，同时置weak对象指针为空，并返回nil。否则调用<code>storeWeak</code>函数进行下一步处理。</p>
<p>注意，从函数的注释中可以看出，<code>objc_initWeak</code>不是线程安全的，因此在设置或修改weak对象时，注意避免一些因多线程引发的问题。</p>
<h4 id="2-1-objc-storeWeak函数"><a href="#2-1-objc-storeWeak函数" class="headerlink" title="2.1 objc_storeWeak函数"></a>2.1 objc_storeWeak函数</h4><p>先看下函数实现：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 断言：haveOld和haveNew必然有一个为true</span></span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="comment">// 如果haveNew为false, 断言newObj为nil</span></span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个Class类型指针previouslyInitializedClass</span></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    <span class="comment">// 声明两个SideTable散列表</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="comment">// 如果有旧值，从SideTables中获取以oldObj为索引的值并赋值给oldTable</span></span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// 如果有新值，从SideTables中获取以newObj为索引的值并赋值给newTable</span></span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对oldTable和newTable加锁，防止多线程读写竞争</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有旧值，*location应该与oldObj相同，</span></span><br><span class="line">    <span class="comment">// 否则说明当前oldObj已经被其他线程修改，为避免线程冲突，释放锁并重新进入retry流程</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免弱引用的死锁，并通过+initialize构造器保证所有的弱引用的isa指针都被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        <span class="comment">// 获取newObj的isa指针</span></span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="comment">// 如果isa指针改变或者未初始化，进入if语句内的流程进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            <span class="comment">// isa指针初始化</span></span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (<span class="keyword">id</span>)newObj));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果该类已经执行完毕+initialize方法或者类正在执行+initialize方法，设置previouslyInitializedClass的值为cls，并进入retry流程</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="comment">// 如果有旧的值，清除</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="comment">// 如果有新的值，分配新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果newObj非空且不是TaggedPointer类型，在引用计数表中设置newObj的weak referenced bit位</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为避免多线程竞争，只在这里设置location指向newObj</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了一个模板参数，包含了三个参数：</p>
<ul>
<li>HaveOld   true: 变量已经有值，需要先清理；false: 变量没有值，无需清理</li>
<li>HaveNew   true: 有一个新的值需要分配给变量，当前值可能为nil；false: 没有需要分配的新值</li>
<li>CrashIfDeallocating   true: 当newObj正在释放或者newObj不支持弱引用时，进程停止；false: 进程不停止，存储nil代替。</li>
</ul>
<p>然后从SideTables中取出相应的oldTable和newTable。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> uint8_t </span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br></pre></td></tr></table></figure>
<p>在SideTables()函数中使用了C++的强制类型转换符：<code>reinterpret_cast</code>：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的type_id 必须是一个指针、引用、算术类型、函数指针或者成员指针</span></span><br><span class="line">reinterpret_cast &lt;type_id&gt; (expression)</span><br></pre></td></tr></table></figure>
<p>它把<code>expression</code>转换成<code>type_id</code>类型，但是不做任何类型检查和转换，其结果只是简单地从一个指针到另一个指针的值的二进制copy，通常用于底层代码。</p>
<p><code>StripedMap</code>是一个模板类（Template Class），通过传入类（结构体）参数，会动态修改在该类中的一个array成员存储的元素类型，并且其中提供了一个针对于地址的hash算法，用作存储key。可以说，StripedMap提供了一套拥有将地址作为key的hash table解决方案，而且该方案采用了模板类，是拥有泛型性的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> StripedMap &#123;</span><br><span class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> PaddedT &#123;</span><br><span class="line">        T value alignas(CacheLineSize);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hash算法，从ptr地址计算对应的key，这里的key为数组下标</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> indexForPointer(<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123;</span><br><span class="line">        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    <span class="comment">// array取值</span></span><br><span class="line">    T&amp; operator[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; operator[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) <span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> const_cast&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcuts for StripedMaps of locks.</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    constexpr StripedMap() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看下SideTable的内部结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"Do not delete SideTable."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock相关的代码，省略</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SideTable结构体中定义了如下内容：</p>
<ul>
<li>spinlock_t slock  自旋锁，用来保证多线程下的原子操作</li>
<li>RefcountMap refcnts   引用计数表，Hash表</li>
<li>weak_table_t weak_table   弱引用表，Hash表</li>
<li>构造函数  其中包含了weak_table的初始化代码</li>
<li>析构函数  </li>
<li>加锁、解锁等：lock()/unlock()</li>
<li>对oldTable和newTable进行加锁、解锁操作的函数：lockTwo/unlockTwo</li>
</ul>
<p>RefcountMap是runtime中用于存储引用计数的hash表，它使用<code>DenseMap</code>数据结构来实现：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,<span class="literal">true</span>&gt; RefcountMap;</span><br></pre></td></tr></table></figure>
<p>对<code>DenseMap</code>的讨论超出了本篇的范围，这里我们只需要知道<code>DenseMap</code>是在llvm中定义并广泛使用的一种数据结构，它本身的实现是一个基于<code>Quadratic probing</code>（二次探查）的散列表，键值对本身是<code>std::pair&lt;KeyT, ValueT&gt;</code>。想看相关源码的同学可以戳这里：<a href="http://llvm.org/doxygen/DenseMap_8h_source.html" target="_blank" rel="noopener">llvm-Densemap.h</a></p>
<h4 id="2-2-weak-table-t"><a href="#2-2-weak-table-t" class="headerlink" title="2.2 weak_table_t"></a>2.2 weak_table_t</h4><p>全局的弱引用散列表，存储了所有weak变量（weak变量实际存储在<code>weak_entry_t</code>中，与对象相关联，下文详细介绍），先看下它的组成：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>weak_entry_t *weak_entries    指向了所有对象的所有weak变量存储区域的入口</li>
<li>size_t    num_entries         存储空间大小</li>
<li>uintptr_t mask</li>
<li>uintptr_t max_hash_displacement   对应key的值在hash表中的最大偏移值</li>
</ul>
<p><code>weak_table_t</code>使用hash表存储所有的weak变量，hash key是需要进行weak引用的对象，value是对象对应的entry（<code>weak_entry_t</code>结构体），entry中使用数组或hash表的方式存储了与对象相关的所有weak变量的指针。</p>
<p>看下<code>weak_entry_t</code>：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;    <span class="comment">// 64位系统下占用62bit，记录referent的弱引用变量的数量</span></span><br><span class="line">            uintptr_t        mask;      <span class="comment">// 记录当前referrers容器的大小</span></span><br><span class="line">            uintptr_t        max_hash_displacement;     <span class="comment">// 根据hash-key寻找index的最大移动次数</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> out_of_line() &#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t&amp; operator=(<span class="keyword">const</span> weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>逐个成员变量看：</p>
<ul>
<li><p><strong><code>DisguisedPtr&lt;objc_object&gt; referent</code></strong>  封装为<code>DisguisedPtr</code>类型的对象指针<code>referent</code>，该指针即指向需要进行弱引用的对象，封装的目的是为了解决weak hash表可能导致的内存泄露的问题。</p>
</li>
<li><p><strong><code>union</code>联合体</strong>    这里首先要明白<code>union</code>的一些概念，<code>union</code>的成员变量都是在同一地址存放的，使成员变量相互覆盖，共同占用同一段内存。<code>union</code>具有以下特点：</p>
<p>  1、<code>union</code>同一个内存段可以用来存放多种不同类型的成员，但是同一时刻只有一个成员起作用<br>  2、<code>union</code>中起作用的是最后一个存放的成员，在存入一个新成员后，原有的变量就会失去作用<br>  3、<code>union</code>中所有成员的起始地址相同<br>  4、<code>union</code>占用的内存长度等于最长的成员的内存长度，而<code>struct</code>的内存长度为其中所有成员变量占用的内存之和</p>
<p>  这里的<code>union</code>中定义了两个<code>struct</code>成员变量，这两个<code>struct</code>用于不同情形下的weak弱引用指针的存储。</p>
</li>
</ul>
<ol>
<li><p>当<code>out_of_line_ness != REFERRERS_OUT_OF_LINE</code>时，<code>weak_entry_t</code>中存储二维指针的区域是一个名称为<code>inline_referrers</code>的数组，该数组中的元素为weak指针的指针。</p>
</li>
<li><p>当<code>out_of_line_ness == REFERRERS_OUT_OF_LINE</code>时，<code>weak_entry_t</code>中存储weak二维指针的区域为一块特定的内存区域，<code>referrers</code>指向这块内存区域的起始地址，在这块内存的存取函数中定义了相关的hash key函数以及冲突解决策略等，将这块内存区域构造成一个hash set使用（后文再详细展开）。</p>
</li>
</ol>
<blockquote>
<p>// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].<br>// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.<br>// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00<br>// (disguised nil or 0x80..00) or 0b11 (any other address).<br>// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</p>
</blockquote>
<p><code>out_of_line_ness</code>变量与<code>inline_referrers[1]</code>的最低两位重叠(<code>inline_referrers[1]</code>也是一个封装为<code>DisguisedPtr</code>类型的指针)，在源码的注释中也说了，<code>out_of_line_ness</code>和<code>inline_referrers[1]</code>的最低2位重合，在64位系统下，<code>out_of_line_ness</code>和<code>num_refs</code>一共占用64bit，由于此时内存结构刚好对齐(<code>out_of_line_ness</code>和<code>num_refs</code>的长度加起来刚好与<code>inline_referrers[1]</code>的长度相同)，所以下一个元素<code>mask</code>的内存地址刚好换行。</p>
<p><code>weak_referrer_t</code>是一个封装为<code>DisguisedPtr</code>的<code>objc_object</code>类型的二维指针(<code>objc_object **</code>)</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc_object ** weak_referrer_t</span><br></pre></td></tr></table></figure>
<p>看下<code>weak_entry_t</code>的构造函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在创建<code>weak_entry_t</code>实例时，默认使用<code>inline_referrers</code>数组的方式来存储weak指针的指针，并把其余位上的数据清空。至此可以做出如下推断：当对象的weak变量的个数小于<code>WEAK_INLINE_COUNT</code>时，<code>weak_entry_t</code>中使用简单的inline数组(即：<code>inline_referrers</code>)方式来存储该对象的这些weak变量的指针，当<code>inline_referrers</code>数组装满之后，<code>out_of_line_ness</code>被设置为<code>REFERRERS_OUT_OF_LINE</code>，这时如果该对象有更多的weak变量，使用out_of_inline的方式存储(存储于hash表)。这么做也是基于性能的考虑，很明显当对象有大量的weak变量时，hash表的存取效率是优于数组的。</p>
<h4 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h4><p>通过上文的分析，可以看出对象的weak变量的存储结构，首先是两个结构体：<code>weak_tale_t</code>和<code>weak_entry_t</code>，它们中分别定义了一个hash表，其中<code>weak_tale_t</code>存储多个<code>weak_entry_t</code>，以hash表的形式存取，<code>weak_entry_t</code>存储某个对象的所有弱引用变量的指针（二维指针的形式），它里面也有一个hash表（当弱引用变量的数量&lt;=4时，以数组的方式存取）。</p>
<p><img src="/2019/01/18/iOS-Runtime随笔——weak原理探究/2.png" alt="weak变量的存储结构"></p>
<h3 id="三、部分细节分析"><a href="#三、部分细节分析" class="headerlink" title="三、部分细节分析"></a>三、部分细节分析</h3><p>既然上文说了weak变量都是以hash表的形式存取，自然而然地能想到这些问题：</p>
<ul>
<li>hash表是怎么实现的</li>
<li>hash函数是怎样的</li>
<li>怎样解决hash冲突</li>
<li>hash表是如何存取、删除的</li>
</ul>
<p>带着这些问题，开始下面的分析</p>
<h4 id="3-1-hash-key计算"><a href="#3-1-hash-key计算" class="headerlink" title="3.1 hash key计算"></a>3.1 hash key计算</h4><p>看下<code>objc-weak.mm</code>文件中有两个hash函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t hash_pointer(objc_object *key) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((uintptr_t)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uintptr_t w_hash_pointer(objc_object **key) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((uintptr_t)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个hash函数根据对象的指针或对象指针的指针，通过<code>ptr_hash</code>函数生成key，这个key就是存取hash表的关键。</p>
<ul>
<li><code>hash_pointer</code>函数对应<code>weak_table_t</code>中的hash表(即<code>weak_entries</code>)，根据被弱引用对象的地址生成key</li>
<li><code>w_hash_pointer</code>函数对应<code>weak_entry_t</code>中的out_of_line时的<code>referrers</code> hash表，根据对象的weak变量的指针生成key</li>
</ul>
<p>看下<code>ptr_hash</code>函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t ptr_hash(uint64_t key)</span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x8a970be7488fda55</span>;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    <span class="keyword">return</span> (uint32_t)key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ptr_hash</code>基于一种<a href="http://locklessinc.com/articles/fast_hash/" target="_blank" rel="noopener">Fash Hash算法</a>，该算法一定程度地牺牲hash准确度以保证hash的速度，适用于当前weak hash表的应用情形。</p>
<h4 id="3-2-weak-entry-t插入"><a href="#3-2-weak-entry-t插入" class="headerlink" title="3.2 weak_entry_t插入"></a>3.2 <code>weak_entry_t</code>插入</h4><p><code>grow_refs_and_insert</code>函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline, used))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> grow_refs_and_insert(weak_entry_t *entry, </span><br><span class="line">                                 objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    size_t old_size = TABLE_SIZE(entry);</span><br><span class="line">    <span class="comment">// 初始化size为8，然后以2倍大小进行增长</span></span><br><span class="line">    size_t new_size = old_size ? old_size * <span class="number">2</span> : <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    size_t num_refs = entry-&gt;num_refs;</span><br><span class="line">    weak_referrer_t *old_refs = entry-&gt;referrers;</span><br><span class="line">    <span class="comment">// 新的容器大小为new_size，增加一个元素后，size-1并赋值给entry-&gt;mask</span></span><br><span class="line">    entry-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新分配空间</span></span><br><span class="line">    entry-&gt;referrers = (weak_referrer_t *)</span><br><span class="line">        calloc(TABLE_SIZE(entry), <span class="keyword">sizeof</span>(weak_referrer_t));</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    entry-&gt;num_refs = <span class="number">0</span>;</span><br><span class="line">    entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将老数据逐个复制到新的entry存储空间中</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; old_size &amp;&amp; num_refs &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (old_refs[i] != <span class="literal">nil</span>) &#123;</span><br><span class="line">            append_referrer(entry, old_refs[i]);</span><br><span class="line">            num_refs--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Insert</span></span><br><span class="line">    <span class="comment">// entry插入新的数据</span></span><br><span class="line">    append_referrer(entry, new_referrer);</span><br><span class="line">    <span class="comment">// 释放老的存储空间</span></span><br><span class="line">    <span class="keyword">if</span> (old_refs) free(old_refs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向<code>weak_entry_t</code>中hash表新增数据时，首先创建一个新的存储空间（大小为<code>old_size * 2</code>），然后将所有的老数据复制到新的空间中，然后再将新的数据插入到新的空间中，最后释放老的存储空间。为什么要这么做呢？我们知道C数组的长度在创建的时候就固定了的，为了能够动态地向数组中添加新元素，就需要不断地申请新的内存空间（并且要求是连续的内存地址），这样就必须把老的数据复制到新申请的内存空间中，然后再加入新增的数据，最后释放掉原内存空间。同时，为了避免频繁地申请新的内存空间和复制数据，将新内存空间大小的增长设置为原来的2倍。</p>
<p><code>grow_refs_and_insert</code>函数使用<code>append_referrer</code>对entry进行数据插入操作。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="comment">// 先使用inline的方式增加新的弱引用，将新数据增加到inline_referrers数组中</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn't insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="comment">// inline存储方式失败，使用out_of_line方式</span></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(weak_referrer_t));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 弱引用数量超过当前存储空间大小的 3/4，对存储空间进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键代码</span></span><br><span class="line">    <span class="comment">// 对new_referrer调用hash函数，获取key，将其赋值给begin</span></span><br><span class="line">    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里用了线性探测法解决hash冲突</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="comment">// 探测到begin的位置，出现这种问题的原因可能是：</span></span><br><span class="line">        <span class="comment">// 1. runtime bug</span></span><br><span class="line">        <span class="comment">// 2. 内存错误导致存储空间扩容失败</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前index存储了新值可以插入的位置</span></span><br><span class="line">    weak_referrer_t &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    <span class="comment">// 插入新值并将weak引用数量+1</span></span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>append_referrer</code>函数的流程比较简单：</p>
<ol>
<li>插入新值时先判断当前entry是否out_of_line，如果没有，使用inline的方式将新值存储到<code>inline_referrers</code>数组中，如果inline存储方式失败，转为out_of_line的方式，分配一块大小为<code>WEAK_INLINE_COUNT</code>的内存空间，将起始地址赋值给<code>new_referrers</code>；</li>
<li>然后判断当前entry中的弱引用数量，如果超过了当前存储空间的3/4，对存储空间进行扩容。扩容的目的是避免hash表的装填因子过大，由于这里采用<strong>线性探测再散列</strong>法解决hash冲突，当装填因子非常接近于1时，线性探测类似于顺序查找，其性能相当于数组遍历，降低了hash表的存取性能；</li>
<li>最后是将新元素插入hash表，使用线性探测再散列找到可以插入的位置，插入新值并将<code>num_refs</code>加1。</li>
</ol>
<p>细心的同学可能注意到了，在计算key和线性探测的过程中有这样两句代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br></pre></td></tr></table></figure>
<p>为何key和index的值要跟<code>entry-&gt;mask</code>相与呢？我们知道，<code>entry-&gt;mask</code>存储了<code>referrers</code>数组的大小，进行“与”操作后，所有超过<code>referrers</code>数组边界的二进制位都被置为0，避免了可能出现的数组越界的问题。</p>
<p>既然有插入操作，那么就有对应的删除操作：<code>remove_referrer</code>函数，这个函数与<code>append_referrer</code>的流程基本相同，不同的是它是找到hash表中相应的位置并将其值置空。这里就不详细分析了。</p>
<h4 id="3-3-weak-table-t插入"><a href="#3-3-weak-table-t插入" class="headerlink" title="3.3 weak_table_t插入"></a>3.3 <code>weak_table_t</code>插入</h4><p><code>weak_table_t</code>的插入涉及到了插入、hash表的扩容等操作，相关的函数有：</p>
<ul>
<li><code>weak_entry_insert</code></li>
<li><code>weak_grow_maybe</code></li>
<li><code>weak_resize</code></li>
</ul>
<h5 id="3-3-1-weak-entry-insert函数"><a href="#3-3-1-weak-entry-insert函数" class="headerlink" title="3.3.1 weak_entry_insert函数"></a>3.3.1 <code>weak_entry_insert</code>函数</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    assert(weak_entries != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != <span class="literal">nil</span>) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>weak_entry_insert</code>函数的流程与上文的<code>append_referrer</code>函数相似，只是省略了inline方式存储的尝试，说明<code>weak_table_t</code>中默认使用hash表的方式存储所有的entries实例。</p>
<h5 id="3-3-2-weak-grow-maybe函数"><a href="#3-3-2-weak-grow-maybe函数" class="headerlink" title="3.3.2 weak_grow_maybe函数"></a>3.3.2 <code>weak_grow_maybe</code>函数</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_grow_maybe(weak_table_t *weak_table)</span><br><span class="line">&#123;</span><br><span class="line">    size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grow if at least 3/4 full.</span></span><br><span class="line">    <span class="keyword">if</span> (weak_table-&gt;num_entries &gt;= old_size * <span class="number">3</span> / <span class="number">4</span>) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*<span class="number">2</span> : <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>weak_grow_maybe</code>函数负责<code>weak_table_t</code> hash表的扩容，与<code>weak_entry_t</code>的策略相同：在hash表中存储的值数量大于hash表容量的3/4时，调用<code>weak_resize</code>函数将hash表扩容到之前容量的2倍。看下<code>weak_resize</code>函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_resize(weak_table_t *weak_table, size_t new_size)</span><br><span class="line">&#123;</span><br><span class="line">    size_t old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    weak_entry_t *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    weak_entry_t *new_entries = (weak_entry_t *)</span><br><span class="line">        calloc(new_size, <span class="keyword">sizeof</span>(weak_entry_t));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>;</span><br><span class="line">    weak_table-&gt;weak_entries = new_entries;</span><br><span class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">        weak_entry_t *entry;</span><br><span class="line">        weak_entry_t *end = old_entries + old_size;</span><br><span class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">                weak_entry_insert(weak_table, entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(old_entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>weak_entry_t</code>的策略相似，不同的是<code>weak_resize</code>只将老数据移动到新的内存空间中，插入新数据的操作又交给了<code>weak_entry_insert</code>函数。</p>
<h4 id="3-4-weak-table-t删除元素"><a href="#3-4-weak-table-t删除元素" class="headerlink" title="3.4 weak_table_t删除元素"></a>3.4 <code>weak_table_t</code>删除元素</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// remove entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) free(entry-&gt;referrers);</span><br><span class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断entry的存储方式是否out_of_line，如果是，直接释放掉<code>referrers</code>内存空间，然后调用<code>sizeof(*entry)</code>获取当前entry占用的内存空间大小，将这块内存全部置0，然后将num_entries减1，最后调用<code>weak_compact_maybe</code>函数缩小hash表的容量至当前容量的 1/8。只有同时满足以下两个条件时才收缩表的容量：1、当前表容量&gt;=1024；2、当前表中entry的数量&lt;=表容量的1/16。<code>weak_compact_maybe</code>的源码这里就不贴出来了。</p>
<h4 id="3-5-对象与weak变量的绑定、解绑等"><a href="#3-5-对象与weak变量的绑定、解绑等" class="headerlink" title="3.5 对象与weak变量的绑定、解绑等"></a>3.5 对象与weak变量的绑定、解绑等</h4><p>通过前文的分析，<code>weak_table_t</code>存储了与某个对象关联的所有弱引用entry(<code>weak_entry_t</code>)，这种结构类似于键值对，那么这种<code>对象-entry</code>的键值对是如何创建并添加到<code>weak_table_t</code>中的，又是如何删除的呢？</p>
<h5 id="3-5-1-weak-register-no-lock"><a href="#3-5-1-weak-register-no-lock" class="headerlink" title="3.5.1 weak_register_no_lock"></a>3.5.1 weak_register_no_lock</h5><p><code>weak_register_no_lock</code>函数负责注册一个新的<code>对象-entry</code>键值对，如果新的对象不存在则去创建一个新的entry并将其与该对象绑定。这里只贴出关键代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查对象是否有效以及是否TaggedPointer对象</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 将对象的弱引用指针添加到entry中</span></span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建新的`weak_entry_t`实例，并将其与需要弱引用的对象关联</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>weak_register_no_lock</code>函数做的事情主要有：</p>
<ol>
<li>判断对象是否可用、是否<code>TaggedPointer</code>对象，如果对象不可用或者是<code>TaggedPointer</code>对象，直接返回被引用的对象自身。</li>
<li>确保需要进行弱引用的对象是可用的(没有释放或没有正在释放等)。</li>
<li>如果当前被引用的对象已存在对应的entry，调用<code>append_referrer</code>将弱引用指针添加到entry中。如果不存在，调用<code>weak_entry_t</code>的构造函数创建一个新的entry并与当前对象绑定，然后调用<code>weak_grow_maybe</code>对当前<code>weak_table_t</code>的hash表进行扩容(如果需要)。最后调用<code>weak_entry_insert</code>函数将新的entry插入到<code>weak_table_t</code>的hash表中。</li>
</ol>
<h5 id="3-5-2-weak-unregister-no-lock"><a href="#3-5-2-weak-unregister-no-lock" class="headerlink" title="3.5.2 weak_unregister_no_lock"></a>3.5.2 weak_unregister_no_lock</h5><p>有绑定操作就有与之对应的解绑操作，该函数的流程就不具体说了，看注释。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                        <span class="keyword">id</span> *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据弱引用的对象去weak_table中查找对应的entry</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 删除entry中对应的弱引用指针</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 判断inline或out_of_line两种存储方式下entry是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果entry为空，将其从weak_table中删除</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、-结语"><a href="#四、-结语" class="headerlink" title="四、 结语"></a>四、 结语</h3><p>行文比较乱，这里自上而下简单总结一下，主要是两个结构体：</p>
<ul>
<li><code>weak_table_t</code>使用hash表的形式存储多个<code>weak_entry_t</code>实例(entry)，并且hash表会根据entry的数量动态调整hash表的容量</li>
<li><code>weak_entry_t</code>使用数组和hash表的形式存储与弱引用对象相关的所有弱引用变量（二维指针）</li>
</ul>
<p>回到开篇提出的三个问题：</p>
<ul>
<li><strong>weak为什么不会增加对象的引用计数</strong></li>
</ul>
<p>我们知道，引用计数的增加离不开<code>retain</code>操作，而在<code>storeWeak</code>函数中并没有调用任何<code>retain</code>操作，当然也就不会使对象的引用计数增加了。对比下<code>objc_storeStrong</code>（对象的强引用最终调用<code>objc_storeStrong</code>函数）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_storeStrong(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>weak变量存储在哪里</strong></li>
</ul>
<p>看上面的总结。</p>
<ul>
<li><strong>对象释放时其weak指针如何自动设置为nil</strong></li>
</ul>
<p>对象释放时，runtime会调用相应的<code>dealloc</code>函数，而<code>dealloc</code>函数中会调用相应的weak指针置空函数：<code>weak_clear_no_lock</code>将与该对象相关的所有weak指针全部设置为nil，详情看代码注释。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对象指针</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// 获取与对象关联的entry</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断entry中弱引用变量的存储方式：数组还是hash表</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历取出与对象相关的所有弱引用变量</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="comment">// referrer为weak指针的指针</span></span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                <span class="comment">// 将对象的weak指针置为nil</span></span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从weak_table的hash表中移除对象的相应entry</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/12/18/一个objc-retain-16的crash问题分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/一个objc-retain-16的crash问题分析/" itemprop="url">一个objc_retain+16的crash问题分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T13:59:59+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/18/一个objc-retain-16的crash问题分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/18/一个objc-retain-16的crash问题分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于测试用例不可能覆盖到所有情况，因此，上线后面对复杂的用户环境和用户操作，难免出现一些crash问题。crash也是很影响用户体验的，常见的crash异常信息有：</p>
<ul>
<li>EXEC_BAD_ACCESS (SIGSEGV/SIGBUS)，发生在程序试图房屋无效的内存或试图以内存的保护级别所不允许的方式去访问内存的时候；</li>
<li>EXEC_CRASH (SIGABRT)，异常退出，比如：如果程序初始化时间过长而触发了watch dog，被强制终止，会产生这类异常；</li>
<li>EXC_BAD_INSTRUCTION (SIGILL)，程序执行非法指令时，或者堆栈溢出时会报非法指令异常；</li>
<li>EXC_RESOURCE，程序消耗的资源过多超过了限制，这是一个从操作系统通知,进程是使用太多的资源。这虽然不是崩溃但也会生成崩溃日志。</li>
</ul>
<p>其他的异常信息有：</p>
<ul>
<li>0x8badf00d，读起来像：ate bad food，该编码表示应用是因为发生watchdog超时而被iOS终止的。 通常是应用花费太多时间而无法启动、终止或响应用系统事件。</li>
<li>0xbad22222，VoIP 应用因为过于频繁重启而被终止。</li>
<li>0xdead10cc，读起来像：dead lock，应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止。</li>
<li>0xdeadfa11，读起来像：dead fall，应用被用户强制退出。</li>
</ul>
<h4 id="crash-log"><a href="#crash-log" class="headerlink" title="crash log"></a>crash log</h4><p>App上线后，遇到这样一个crash，测试时未发现。先看下crash日志，略去无用信息。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: <span class="number">86</span>D40C68<span class="number">-5158</span><span class="number">-436</span>E-A619-AB19A8E7006C</span><br><span class="line">CrashReporter Key:   <span class="number">82</span>b59c10d300ce0f26b67acba78caf0bb632483c</span><br><span class="line">Hardware Model:      iPhone10,<span class="number">3</span></span><br><span class="line">Process:         ***** [<span class="number">5374</span>]</span><br><span class="line">Path:            /var/containers/Bundle/Application/BBEFF30F<span class="number">-9</span>DBD<span class="number">-41</span>AC-AC2D<span class="number">-76479532E149</span>/GWMovie.app/GWMovie</span><br><span class="line">Identifier:      **********</span><br><span class="line">Version:         <span class="number">9.4</span><span class="number">.1</span> (<span class="number">9407</span>)</span><br><span class="line">Code Type:       ARM<span class="number">-64</span></span><br><span class="line">Parent Process:  ? [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Date/Time:       <span class="number">2018</span><span class="number">-12</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">09</span>:<span class="number">04.000</span> +<span class="number">0800</span></span><br><span class="line">OS Version:      iOS <span class="number">12.1</span> (<span class="number">16</span>B92)</span><br><span class="line">Report Version:  <span class="number">104</span></span><br><span class="line"></span><br><span class="line">Exception Type:  EXC_BAD_ACCESS (SIGBUS)</span><br><span class="line">Exception Codes: KERN_EXCEPTION_PROTECTED at <span class="number">0x0000000000000020</span></span><br><span class="line">Crashed Thread:  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Thread <span class="number">0</span> Crashed:</span><br><span class="line"><span class="number">0</span>   libobjc.A.dylib                 objc_retain + <span class="number">16</span></span><br><span class="line"><span class="number">1</span>   QuartzCore                      CA::AttrList::set(<span class="keyword">unsigned</span> <span class="keyword">int</span>, _CAValueType, <span class="keyword">void</span> <span class="keyword">const</span>*) + <span class="number">464</span></span><br><span class="line"><span class="number">2</span>   QuartzCore                      <span class="built_in">CAAnimation_setter</span>(<span class="built_in">CAAnimation</span>*, <span class="keyword">unsigned</span> <span class="keyword">int</span>, _CAValueType, <span class="keyword">void</span> <span class="keyword">const</span>*) + <span class="number">232</span></span><br><span class="line"><span class="number">3</span>   QuartzCore                      -[<span class="built_in">CAAnimation</span> setDelegate:] + <span class="number">48</span></span><br><span class="line"><span class="number">4</span>   <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UIViewAnimationState</span> setAnimationAttributes:correctZeroDuration:skipDelegateAssignment:customCurve:] + <span class="number">876</span></span><br><span class="line"><span class="number">5</span>   <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UIViewAnimationState</span> animationForLayer:forKey:forView:] + <span class="number">1184</span></span><br><span class="line"><span class="number">6</span>   <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UIViewAnimationState</span> actionForLayer:forKey:forView:] + <span class="number">120</span></span><br><span class="line"><span class="number">7</span>   <span class="built_in">UIKitCore</span>                       +[<span class="built_in">UIView</span>(Animation) _defaultUIViewActionForLayer:forKey:] + <span class="number">112</span></span><br><span class="line"><span class="number">8</span>   <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UIView</span>(<span class="built_in">UIKitManual</span>) actionForLayer:forKey:] + <span class="number">312</span></span><br><span class="line"><span class="number">9</span>   QuartzCore                      -[<span class="built_in">CALayer</span> actionForKey:] + <span class="number">136</span></span><br><span class="line"><span class="number">10</span>  QuartzCore                      CA::Layer::begin_change(CA::Transaction*, <span class="keyword">unsigned</span> <span class="keyword">int</span>, objc_object*, objc_object*&amp;) + <span class="number">200</span></span><br><span class="line"><span class="number">11</span>  QuartzCore                      CA::Layer::<span class="keyword">setter</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, _CAValueType, <span class="keyword">void</span> <span class="keyword">const</span>*) + <span class="number">312</span></span><br><span class="line"><span class="number">12</span>  QuartzCore                      -[<span class="built_in">CALayer</span> setContentsMultiplyColor:] + <span class="number">64</span></span><br><span class="line"><span class="number">13</span>  <span class="built_in">UIKitCore</span>                       -[_UILabelLayer setContentsMultiplyColor:] + <span class="number">60</span></span><br><span class="line"><span class="number">14</span>  <span class="built_in">UIKitCore</span>                       <span class="built_in">UILabelCommonInit</span> + <span class="number">204</span></span><br><span class="line"><span class="number">15</span>  <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UILabel</span> initWithFrame:] + <span class="number">60</span></span><br><span class="line"><span class="number">16</span>  GWMovie                         -[GWHomePosterButtonView loadAllControls] (GWHomePosterButtonView.m:<span class="number">89</span>)</span><br><span class="line"><span class="number">17</span>  GWMovie                         -[GWHomePosterButtonView initWithFrame:] (GWHomePosterButtonView.m:<span class="number">109</span>)</span><br><span class="line"><span class="number">18</span>  GWMovie                         -[GWHomeBaseClassView loadAllControls] (GWHomeBaseClassView.m:<span class="number">102</span>)</span><br><span class="line"><span class="number">19</span>  GWMovie                         -[GWHomeBaseClassView initWithFrame:] (GWHomeBaseClassView.m:<span class="number">153</span>)</span><br><span class="line"><span class="number">20</span>  GWMovie                         -[GWHomeDramaBaseClassView initWithFrame:] (GWHomeDramaBaseClassView.m:<span class="number">176</span>)</span><br><span class="line"><span class="number">21</span>  GWMovie                         -[GWHomeDramaTableViewCell dramaCardView] (GWHomeDramaTableViewCell.m:<span class="number">125</span>)</span><br><span class="line"><span class="number">22</span>  GWMovie                         -[GWHomeViewController tableView:cellForRowAtIndexPath:] (GWHomeViewController.m:<span class="number">377</span>)</span><br><span class="line"><span class="number">23</span>  <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UITableView</span> _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + <span class="number">684</span></span><br><span class="line"><span class="number">24</span>  <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UITableView</span> _createPreparedCellForGlobalRow:willDisplay:] + <span class="number">80</span></span><br><span class="line"><span class="number">25</span>  <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UITableView</span> _updateVisibleCellsNow:isRecursive:] + <span class="number">2256</span></span><br><span class="line"><span class="number">26</span>  <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UITableView</span> layoutSubviews] + <span class="number">140</span></span><br><span class="line"><span class="number">27</span>  <span class="built_in">UIKitCore</span>                       -[<span class="built_in">UIView</span>(<span class="built_in">CALayerDelegate</span>) layoutSublayersOfLayer:] + <span class="number">1380</span></span><br><span class="line"><span class="number">28</span>  QuartzCore                      -[<span class="built_in">CALayer</span> layoutSublayers] + <span class="number">184</span></span><br><span class="line"><span class="number">29</span>  QuartzCore                      CA::Layer::layout_if_needed(CA::Transaction*) + <span class="number">324</span></span><br><span class="line"><span class="number">30</span>  QuartzCore                      CA::Context::commit_transaction(CA::Transaction*) + <span class="number">340</span></span><br><span class="line"><span class="number">31</span>  QuartzCore                      CA::Transaction::commit() + <span class="number">608</span></span><br><span class="line"><span class="number">32</span>  QuartzCore                      CA::Transaction::observer_callback(__CFRunLoopObserver*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">void</span>*) + <span class="number">92</span></span><br><span class="line"><span class="number">33</span>  CoreFoundation                  __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + <span class="number">32</span></span><br><span class="line"><span class="number">34</span>  CoreFoundation                  __CFRunLoopDoObservers + <span class="number">412</span></span><br><span class="line"><span class="number">35</span>  CoreFoundation                  __CFRunLoopRun + <span class="number">1264</span></span><br><span class="line"><span class="number">36</span>  CoreFoundation                  <span class="built_in">CFRunLoopRunSpecific</span> + <span class="number">436</span></span><br><span class="line"><span class="number">37</span>  GraphicsServices                GSEventRunModal + <span class="number">100</span></span><br><span class="line"><span class="number">38</span>  <span class="built_in">UIKitCore</span>                       <span class="built_in">UIApplicationMain</span> + <span class="number">212</span></span><br><span class="line"><span class="number">39</span>  GWMovie                         main (main.m:<span class="number">16</span>)</span><br><span class="line"><span class="number">40</span>  libdyld.dylib                   start + <span class="number">4</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Thread <span class="number">0</span> crashed with ARM<span class="number">-64</span> Thread State:</span><br><span class="line">  cpsr: <span class="number">0x00000000a0000000</span>     fp: <span class="number">0x000000016ae03800</span>     lr: <span class="number">0x00000001bbceb3e8</span>     pc: <span class="number">0x00000001b6881430</span> </span><br><span class="line">    sp: <span class="number">0x000000016ae037c0</span>     x0: <span class="number">0x00000001078e22b0</span>     x1: <span class="number">0x0000000000000002</span>    x10: <span class="number">0x00000001f127e100</span> </span><br><span class="line">   x11: <span class="number">0x0000000000000354</span>    x12: <span class="number">0x0000000000000154</span>    x13: <span class="number">0x0000000000000154</span>    x14: <span class="number">0x000000000000007f</span> </span><br><span class="line">   x15: <span class="number">0x00000000ffffffe8</span>    x16: <span class="number">0x00000001b72a39e4</span>    x17: <span class="number">0x0000010000000100</span>    x18: <span class="number">0x0000000000000000</span> </span><br><span class="line">   x19: <span class="number">0x0000000107b345b0</span>     x2: <span class="number">0x0000000000000303</span>    x20: <span class="number">0x00000001078e22b0</span>    x21: <span class="number">0x0000000107b34e60</span> </span><br><span class="line">   x22: <span class="number">0x0000000000000002</span>    x23: <span class="number">0x000000000000008c</span>    x24: <span class="number">0x0000000107b345b8</span>    x25: <span class="number">0x0000000107b34bd0</span> </span><br><span class="line">   x26: <span class="number">0x0000000282a1cc60</span>    x27: <span class="number">0x0000000000000000</span>    x28: <span class="number">0x0000000106ff3d10</span>    x29: <span class="number">0x000000016ae03800</span> </span><br><span class="line">    x3: <span class="number">0x0000000000000002</span>     x4: <span class="number">0x0000000000000000</span>     x5: <span class="number">0x0000000000000000</span>     x6: <span class="number">0x000000016ae036a0</span> </span><br><span class="line">    x7: <span class="number">0x0000000000000000</span>     x8: <span class="number">0x0000000000000000</span>     x9: <span class="number">0x00000001f127a070</span></span><br></pre></td></tr></table></figure>
<p>先看下崩溃类型是EXC_BAD_ACCESS，第一反应可能是对象被提前释放了导致读到了错误的内存。<br>看下崩溃线程的堆栈信息，crash发生在main thread的objc_retain函数的第16条指令。</p>
<p>使用<code>disassemble</code>命令将objc_retain转换为汇编代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">libobjc.A.dylib`objc_retain:</span><br><span class="line">    <span class="number">0x1b53cd420</span> &lt;+<span class="number">0</span>&gt;:  <span class="number">0xb40001a0</span>   cbz    x0, <span class="number">0x1b53cd454</span>           ; &lt;+<span class="number">52</span>&gt;</span><br><span class="line">    <span class="number">0x1b53cd424</span> &lt;+<span class="number">4</span>&gt;:  <span class="number">0xb7f80180</span>   tbnz   x0, <span class="meta">#0x3f, 0x1b53cd454    ; <span class="meta-string">&lt;+52&gt;</span></span></span><br><span class="line">    <span class="number">0x1b53cd428</span> &lt;+<span class="number">8</span>&gt;:  <span class="number">0xf9400008</span>   ldr    x8, [x0]</span><br><span class="line">    <span class="number">0x1b53cd42c</span> &lt;+<span class="number">12</span>&gt;: <span class="number">0x927d8108</span>   and    x8, x8, <span class="meta">#0xffffffff8</span></span><br><span class="line">    <span class="number">0x1b53cd430</span> &lt;+<span class="number">16</span>&gt;: <span class="number">0x39408108</span>   ldrb   w8, [x8, <span class="meta">#0x20]</span></span><br><span class="line">    <span class="number">0x1b53cd434</span> &lt;+<span class="number">20</span>&gt;: <span class="number">0x36100128</span>   tbz    w8, <span class="meta">#0x2, 0x1b53cd458     ; <span class="meta-string">&lt;+56&gt;</span></span></span><br><span class="line">    <span class="number">0x1b53cd438</span> &lt;+<span class="number">24</span>&gt;: <span class="number">0xb25303e8</span>   orr    x8, xzr, <span class="meta">#0x200000000000</span></span><br><span class="line">    <span class="number">0x1b53cd43c</span> &lt;+<span class="number">28</span>&gt;: <span class="number">0xc85f7c09</span>   ldxr   x9, [x0]</span><br><span class="line">    <span class="number">0x1b53cd440</span> &lt;+<span class="number">32</span>&gt;: <span class="number">0x36000149</span>   tbz    w9, <span class="meta">#0x0, 0x1b53cd468     ; <span class="meta-string">&lt;+72&gt;</span></span></span><br><span class="line">    <span class="number">0x1b53cd444</span> &lt;+<span class="number">36</span>&gt;: <span class="number">0xab080129</span>   adds   x9, x9, x8</span><br><span class="line">    <span class="number">0x1b53cd448</span> &lt;+<span class="number">40</span>&gt;: <span class="number">0x54000142</span>   b.hs   <span class="number">0x1b53cd470</span>               ; &lt;+<span class="number">80</span>&gt;</span><br><span class="line">    <span class="number">0x1b53cd44c</span> &lt;+<span class="number">44</span>&gt;: <span class="number">0xc80a7c09</span>   stxr   w10, x9, [x0]</span><br><span class="line">    <span class="number">0x1b53cd450</span> &lt;+<span class="number">48</span>&gt;: <span class="number">0x35ffff6a</span>   cbnz   w10, <span class="number">0x1b53cd43c</span>          ; &lt;+<span class="number">28</span>&gt;</span><br><span class="line">    <span class="number">0x1b53cd454</span> &lt;+<span class="number">52</span>&gt;: <span class="number">0xd65f03c0</span>   ret    </span><br><span class="line">    <span class="number">0x1b53cd458</span> &lt;+<span class="number">56</span>&gt;: <span class="number">0xd01d0348</span>   adrp   x8, <span class="number">237674</span></span><br><span class="line">    <span class="number">0x1b53cd45c</span> &lt;+<span class="number">60</span>&gt;: <span class="number">0x913c8108</span>   add    x8, x8, <span class="meta">#0xf20            ; =0xf20 </span></span><br><span class="line">    <span class="number">0x1b53cd460</span> &lt;+<span class="number">64</span>&gt;: <span class="number">0xf9400101</span>   ldr    x1, [x8]</span><br><span class="line">    <span class="number">0x1b53cd464</span> &lt;+<span class="number">68</span>&gt;: <span class="number">0x17fffe3f</span>   b      <span class="number">0x1b53ccd60</span>               ; objc_msgSend</span><br><span class="line">    <span class="number">0x1b53cd468</span> &lt;+<span class="number">72</span>&gt;: <span class="number">0xd5033f5f</span>   clrex  </span><br><span class="line">    <span class="number">0x1b53cd46c</span> &lt;+<span class="number">76</span>&gt;: <span class="number">0x140003ea</span>   b      <span class="number">0x1b53ce414</span>               ; objc_object::sidetable_retain()</span><br><span class="line">    <span class="number">0x1b53cd470</span> &lt;+<span class="number">80</span>&gt;: <span class="number">0xd5033f5f</span>   clrex  </span><br><span class="line">    <span class="number">0x1b53cd474</span> &lt;+<span class="number">84</span>&gt;: <span class="number">0x52800001</span>   mov    w1, <span class="meta">#0x0</span></span><br><span class="line">    <span class="number">0x1b53cd478</span> &lt;+<span class="number">88</span>&gt;: <span class="number">0x14000a05</span>   b      <span class="number">0x1b53cfc8c</span>               ; objc_object::rootRetain_overflow(<span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure>
<p>取前后几条相关的指令：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1b53cd428</span> &lt;+<span class="number">8</span>&gt;:  <span class="number">0xf9400008</span>   ldr    x8, [x0]</span><br><span class="line"><span class="number">0x1b53cd42c</span> &lt;+<span class="number">12</span>&gt;: <span class="number">0x927d8108</span>   and    x8, x8, <span class="meta">#0xffffffff8</span></span><br><span class="line"><span class="number">0x1b53cd430</span> &lt;+<span class="number">16</span>&gt;: <span class="number">0x39408108</span>   ldrb   w8, [x8, <span class="meta">#0x20]</span></span><br></pre></td></tr></table></figure>
<p>熟悉objective-c消息发送<code>objc_msgSend</code>函数的同学应该对这三条指令不陌生，有关<code>objc_msgSend</code>函数的分析，有兴趣的同学可以看我的这篇文章：<a href="https://chy305chy.github.io/2018/08/14/%E4%BB%8E%E4%B8%80%E4%B8%AABUG%E8%B0%88%E8%B5%B7%EF%BC%8C%E5%89%96%E6%9E%90objc-msgSend%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">objc_msgSend分析</a></p>
<p>回到<code>objc_retain</code>函数中，这三条指令的作用是：</p>
<ol>
<li>当前x0中存的是消息receiver的对象的地址，加载其第一个64bit（即<code>isa</code>指针）到x8寄存器中</li>
<li>通过<code>isa</code>指针与<code>0xffffffff8</code>得到receiver所属的Class对象<code>obj_class</code>，并将其保存到x8寄存器中</li>
<li>从Class对象首地址+32处(<code>[x8, #0x20]</code>)加载数据到x8寄存器的低32位。</li>
</ol>
<p>看下crash log中有关x8寄存器的内容：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x8: <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>因此，第三条指令<code>ldrb</code>读到了<code>0x20</code>内存地址的内容，但是<code>0x20</code>地址是操作系统保留地址，因此crash code为：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception Codes: KERN_EXCEPTION_PROTECTED at <span class="number">0x0000000000000020</span></span><br></pre></td></tr></table></figure>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>通过分析crash log系统收集的其他相关crash日志发现，该bug导致的crash集中发生在同一个类中的<code>[UIView setBackgroundColor]</code>、<code>initWithFrame:</code>等处。同样也会导致<code>objc_msgSend + 16</code>的<code>EXEC_BAD_ACCESS</code>类型的crash。</p>
<p>我们知道，iOS的隐式动画会统一由CATransaction收集并在当前线程的下一个runloop中统一提交。但是如果下一个runloop中执行动画时，与之关联的<code>UIView/CALayer</code>已经释放了，就会发生野指针错误。</p>
<p>但是查看相关代码，并没有发现<code>UIView/CALayer</code>被提前释放的相关代码，那是什么原因呢？</p>
<p>根据苹果的文档，UIKit相关操作必须在主线程中进行，否则可能导致程序异常，那么会不会是子线程刷新UI造成的呢？</p>
<p>查看源码发现一句调用层级比较深的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_queue_create(<span class="string">"HomeDataRequest"</span>, <span class="literal">NULL</span>), ^&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">self</span>.homeTableView refreshTableView];</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里在后台线程中进行了reload tableView的操作。改到主线程中刷新就好了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/12/10/GCD源码分析（四）——dispatch-once-下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/10/GCD源码分析（四）——dispatch-once-下/" itemprop="url">GCD源码分析（四）——dispatch_once(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-10T19:16:01+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/10/GCD源码分析（四）——dispatch-once-下/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/10/GCD源码分析（四）——dispatch-once-下/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>上篇文章中讲到，<code>dispatch_once</code>使用无锁方式实现线程安全和优异的性能。本篇文章我们来分析一下<code>dispatch_once</code>的性能。</p>
<p>从<code>dispatch_once</code>的源码可以看出，其本质就是一个<code>if-else</code>语句。我们使用非线程安全的纯<code>if-else</code>语句作为空白对照。</p>
<p>纯if-else:</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)benchmark &#123;</span><br><span class="line">    TestObject *obj = <span class="literal">nil</span>;</span><br><span class="line">    mach_timebase_info(&amp;_timebaseInfo);</span><br><span class="line">    uint64_t start = mach_absolute_time();</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        uint64_t end = mach_absolute_time();</span><br><span class="line">        uint64_t duration = (end - start) * _timebaseInfo.numer / _timebaseInfo.denom;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=== benchmark: %llu"</span>, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是用<code>pthread_mutex_lock</code>实现的线程安全的<code>if-else</code>：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mutexLock &#123;</span><br><span class="line">    TestObject *obj = <span class="literal">nil</span>;</span><br><span class="line">    mach_timebase_info_data_t timebaseInfo;</span><br><span class="line">    mach_timebase_info(&amp;timebaseInfo);</span><br><span class="line">    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    uint64_t start = mach_absolute_time();</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        <span class="comment">//obj = [TestObject new];</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    uint64_t end = mach_absolute_time();</span><br><span class="line">    uint64_t duration = (end - start) * _timebaseInfo.numer / _timebaseInfo.denom;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=== mutex_lock: %llu"</span>, duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>dispatch_once</code>：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchOnce &#123;</span><br><span class="line">    __block TestObject *obj = <span class="literal">nil</span>;</span><br><span class="line">    mach_timebase_info_data_t timebaseInfo;</span><br><span class="line">    mach_timebase_info(&amp;timebaseInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        uint64_t start = mach_absolute_time();</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            <span class="comment">//obj = [TestObject new];</span></span><br><span class="line">        &#125;);</span><br><span class="line">        uint64_t end = mach_absolute_time();</span><br><span class="line">        uint64_t duration = (end - start) * _timebaseInfo.numer / _timebaseInfo.denom;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"=== dispatch_once %llu"</span>, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的macbook pro上测试三种方式的耗时（单位：纳秒）分别为：</p>
<ol>
<li>纯if-else：41</li>
<li>pthread_mutex_lock: 13429</li>
<li>dispatch_once: 5次输出分别为：3457、328、298、293、194</li>
</ol>
<p>可以看出纯<code>if-else</code>语句耗时最少，而效率相对较高的<code>pthread_mutex_lock</code>锁比之<code>dispatch_once</code>的性能有最高40多倍的差距！（<code>dispatch_once</code>首次执行耗时较多）。<br>回顾下上篇中讲到的<code>dispatch_once</code>的三个场景：</p>
<blockquote>
<ol>
<li>第一次执行，执行block，执行完成后置predicate标记</li>
<li>非第一次执行，而步骤1尚未执行完毕，此时线程需要等待步骤1完成，步骤1完成后依次唤醒等待的线程</li>
<li>非第一次执行，且步骤1已经执行完成，线程跳过block继续执行后续任务</li>
</ol>
</blockquote>
<p>思考一下，在程序的实际运行中，场景1最多发生一次，场景2发生的次数很少甚至可能一次也不会发生，而场景3是程序执行中最常见的，可能成千上万次地执行。场景3的效率直接影响到整个程序的运行效率。</p>
<p>从上述的简单测试中发现：针对场景3，<code>dispatch_once</code>只比纯<code>if-else</code>语句慢不到10倍，但是它有着比<code>pthread_mutex_lock</code>高40多倍的性能表现，而且这是在保证线程安全的前提下的性能，确实不可思议，<code>dispatch_once</code>究竟是怎么做到的呢？</p>
<h3 id="二、CPU指令流水与dispatch-once"><a href="#二、CPU指令流水与dispatch-once" class="headerlink" title="二、CPU指令流水与dispatch_once"></a>二、CPU指令流水与dispatch_once</h3><p>回顾《计算机组成原理》的知识，CPU的指令执行一般包括：取指、译码、执行、回写三个步骤。</p>
<p>在最古老的CPU上，指令是严格按照顺序执行的：</p>
<p><img src="/2018/12/10/GCD源码分析（四）——dispatch-once-下/1.png" alt=""></p>
<p>而现代CPU为了提升运行速度，加入了指令流水线、分支预测和乱序执行等特性，此时CPU的执行顺序如下（图片出自Wikipedia）：</p>
<p><img src="/2018/12/10/GCD源码分析（四）——dispatch-once-下/2.png" alt=""></p>
<h4 id="2-1-CPU分支预测"><a href="#2-1-CPU分支预测" class="headerlink" title="2.1 CPU分支预测"></a>2.1 CPU分支预测</h4><p>流水线特性使得CPU能够更快速地执行线性指令序列，但是对于<code>if-else</code>语句，在条件判断结果出来之前，CPU不知道应该执行哪个分支，如果此时让CPU停下来等待判断结果显然不是最优的做法。</p>
<p>所以现代CPU加入了分支预测的特性，分析程序以往运行记录猜测本次要执行的分支并进行预执行，这样就会产生两个结果：</p>
<ol>
<li>猜测正确，CPU无需等待判断结果了，继续往下执行。这样效率是最高的。</li>
<li>猜测错误，CPU要抛弃所有预执行的结果，重置寄存器等，回滚到正确的分支，重新热启动。由于现代编译器的高度复杂性，程序运行时往往有着很长的piplines，回滚状态和热启动都是很耗时的。</li>
</ol>
<p>幸运的是，大多数的程序都有着状态良好的（well-behaved）分支，比如：<code>dispatch_once_f</code>的<code>if-else</code>语句。所以现代CPU的分支预测一般能达到90%的准确率，但是面对无法预测的分支（比如，判断的条件依赖网络返回值等），分支预测就无用武之地了。</p>
<p>想了解更详细的分支预测，请戳这里：<a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="noopener">Wikipedia_Brach_predictor</a>。</p>
<h4 id="2-2-barrier"><a href="#2-2-barrier" class="headerlink" title="2.2 barrier"></a>2.2 barrier</h4><p>现代CPU为了尽可能快的运行速度，加入了分支预测和预执行技术。想象一下如下场景：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> TestObject *obj;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;predicate, ^&#123;</span><br><span class="line">    obj = [TestObject new];</span><br><span class="line">&#125;);</span><br><span class="line">[obj description];</span><br></pre></td></tr></table></figure>
<p>线程A第一次执行<code>dispatch_once</code>，此时线程B、C、D执行<code>dispatch_once</code>，CPU根据以往的经验预执行了“<code>dispatch_once</code>已执行完毕”的分支，但是此时线程A的<code>block</code>尚未执行完毕，<code>obj</code>是<code>nil</code>，此时程序往下执行必然会导致异常行为，严重时甚至会引起crash。</p>
<p>这种问题要如何避免呢？</p>
<p>这时，<code>dispatch_once</code>需要一种类似于<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">Memory_barrier</a>的机制，防止CPU跑的太快导致程序的异常。当然由于memory_barrier的开销比较大，在对性能很敏感<code>dispatch_once</code>中尽量不要使用。</p>
<p>我们在<code>_dispatch_once</code>函数中发现了这样一行代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_compiler_barrier();</span><br></pre></td></tr></table></figure>
<p>它是一个宏：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if __GNUC__</span></span><br><span class="line"><span class="meta">#define DISPATCH_EXPECT(x, v) __builtin_expect((x), (v))</span></span><br><span class="line"><span class="meta">#define dispatch_compiler_barrier()  __asm__ __volatile__(<span class="meta-string">""</span> ::: <span class="meta-string">"memory"</span>)</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define DISPATCH_EXPECT(x, v) (x)</span></span><br><span class="line"><span class="meta">#define dispatch_compiler_barrier()  do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>在GCC编译器下，<code>dispatch_compiler_barrier</code>使用<code>__asm__ __volatile__(&quot;&quot; ::: &quot;memory&quot;)</code>语句创建了一个memory_barrier。</p>
<p><strong>扩展：Xcode编译器的历史</strong></p>
<p>由于GCC是一个开源组织维护的编译器，GCC的开发组很傲娇，经常无视或者拖延Apple对GCC提出的各种需求，同时GCC对Objecttive-C的许多新特性的支持并不友好。因此，苹果从Xcode3开始就着手使用自家的LLVM编译器代替GCC了，到Xcode5版本时，GCC已被完全废弃，使用LLVM代替。现在Xcode中使用的编译器普遍是Clang-LLVM了，这个编译器的作者是大名鼎鼎的Swift之父Chris Lattner。</p>
<blockquote>
<p>Clang-LLVM比GCC优秀在哪些方面<br>据说新的Clang编译器编译Objective-C代码速度比GCC快3倍，并且提供了更友好的代码提示。</p>
</blockquote>
<p>对比下新老版本的<code>dispatch_once</code>是如何解决由于CPU预执行了错误的分支而导致的程序异常的问题。</p>
<h4 id="2-2-1-libdispatch-187-9"><a href="#2-2-1-libdispatch-187-9" class="headerlink" title="2.2.1 libdispatch-187.9"></a>2.2.1 libdispatch-187.9</h4><p>看下相关代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *val, dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> Block_basic *bb = (<span class="keyword">void</span> *)block;</span><br><span class="line"></span><br><span class="line">	dispatch_once_f(val, block, (<span class="keyword">void</span> *)bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_once_f(<span class="built_in">dispatch_once_t</span> *predicate, <span class="keyword">void</span> *context,</span><br><span class="line">		dispatch_function_t function)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) &#123;</span><br><span class="line">		dispatch_once_f(predicate, context, function);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="built_in">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> _dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval =</span><br><span class="line">			(<span class="keyword">struct</span> _dispatch_once_waiter_s**)val;</span><br><span class="line">	<span class="keyword">struct</span> _dispatch_once_waiter_s dow = &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">	_dispatch_thread_semaphore_t sema;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, <span class="literal">NULL</span>, &amp;dow)) &#123;</span><br><span class="line">		dispatch_atomic_acquire_barrier();</span><br><span class="line">		_dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">		dispatch_atomic_maximally_synchronizing_barrier();</span><br><span class="line">		<span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span></span><br><span class="line">		tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);</span><br><span class="line">		tail = &amp;dow;</span><br><span class="line">		<span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">				_dispatch_hardware_pause();</span><br><span class="line">			&#125;</span><br><span class="line">			sema = tmp-&gt;dow_sema;</span><br><span class="line">			tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">			_dispatch_thread_semaphore_signal(sema);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			tmp = *vval;</span><br><span class="line">			<span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dispatch_atomic_store_barrier();</span><br><span class="line">			<span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123;</span><br><span class="line">				dow.dow_next = tmp;</span><br><span class="line">				_dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		_dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老版本的libdispatch在写入端的执行block和设置<code>predicate</code>值为<code>DISPATCH_ONCE_DONE</code>中间加入了<code>dispatch_atomic_maximally_synchronizing_barrier();</code>这样一行语句，使得dispatch_once在置<code>predicate</code>的值为done之前，让CPU等待足够长的时间，防止CPU由于预执行到错误的分支而却认为自己执行对了，而继续执行从而导致程序行为异常。</p>
<blockquote>
<p>另一个线程B（耗时为Ta）在预执行读取了未初始化的obj值之后，回过头来确认猜测正确性时，predicate可能被执行block的线程A置为了“done”，这就导致线程B误认为自己的预执行有效（实际上它读取了未初始化的值）</p>
</blockquote>
<p><code>dispatch_atomic_maximally_synchronizing_barrier()</code>实际上是调用GCC的<code>__sync_synchronize(...)</code>函数发出一个full_barrier，它其实生成了一个的memory_barrier，效率比较低。</p>
<h4 id="2-2-2-libdispatch-913-1-6"><a href="#2-2-2-libdispatch-913-1-6" class="headerlink" title="2.2.2 libdispatch-913.1.6"></a>2.2.2 libdispatch-913.1.6</h4><p>由于苹果在最新版的Xcode摒弃了GCC，因此新版本的libdispatch中也放弃使用了一些GCC中的操作，比如<code>__sync_synchronize</code>。</p>
<p>回顾下代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_once_f(<span class="built_in">dispatch_once_t</span> *predicate, <span class="keyword">void</span> *_Nullable context,</span><br><span class="line">		dispatch_function_t function)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) &#123;</span><br><span class="line">		dispatch_once_f(predicate, context, function);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0</span>l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与老版本不同的是，新版本增加了else分支和<code>DISPATCH_COMPILER_CAN_ASSUME</code>语句。</p>
<p><code>dispatch_compiler_barrier()</code>在GCC编译器下使用<code>__asm__ __volatile__ (&quot;&quot; ::: &quot;memory&quot;)</code>制造一个memory_barrier，但是在Clang-LLVM编译器下，它转换成如下语句：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，无论CPU预测的分支正确与否，预执行的语句始终被局限在<code>_dispatch_once_f</code>函数中，即使第一次执行<code>dispatch_once</code>时，CPU分支预测错误，预执行了else分支，但是由于else分支中实际上是一句没实际作用的<code>do-while</code>代码，执行它不会对的程序行为产生异常影响。</p>
<p>这样一来，在<code>dispatch_once_f_slow</code>写入端就可以抛弃效率低下的memory_barrier了，进一步提高了<code>dispatch_once</code>的性能。这种做法相当于使用编译器给程序加了一层barrier，这也许就是<code>dispatch_compiler_barrier</code>命名的由来吧。</p>
<h3 id="三、总结-amp-参考文献"><a href="#三、总结-amp-参考文献" class="headerlink" title="三、总结&amp;参考文献"></a>三、总结&amp;参考文献</h3><ul>
<li><a href="https://www.mikeash.com/pyblog/?tag=gcd" target="_blank" rel="noopener">MikeAsh_GCD</a></li>
<li><a href="http://www.dreamingwish.com/article/gcd-guide-dispatch-once-1.html" target="_blank" rel="noopener">dispatch_once负载探究</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/12/06/GCD源码分析（三）——dispatch-once/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/GCD源码分析（三）——dispatch-once/" itemprop="url">GCD源码分析（三）——dispatch_once（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T10:58:41+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/06/GCD源码分析（三）——dispatch-once/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/06/GCD源码分析（三）——dispatch-once/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>) sharedInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> TestObject sharedInstance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [TestObject new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信大家对上面的代码很熟悉，objective-c中单例的实现离不开dispatch_once。从Swift3.0开始Apple就废弃了dispatch_once：<code>DISPATCH_SWIFT3_UNAVAILABLE(&quot;Use lazily initialized globals instead&quot;)</code>，Swift中的单例写法变成了下面这种写法，由静态不可变变量代替。但是了解dispatch_once的工作原理对我们编写高质量高性能的代码依然有着重要的参考作用。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> let singleton = TestObject()</span><br><span class="line">private override init() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch_once被广泛使用在OC单例中，它可以保证在多线程程序中，指定的代码只被执行一次。dispatch_once没有使用任何“锁”，但是依然能够保证多线程情况下的线程安全，并且有着优异的性能。</p>
<h3 id="二、-dispatch-once-f"><a href="#二、-dispatch-once-f" class="headerlink" title="二、_dispatch_once_f"></a>二、_dispatch_once_f</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_once_f(<span class="built_in">dispatch_once_t</span> *predicate, <span class="keyword">void</span> *_Nullable context,</span><br><span class="line">		dispatch_function_t function)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) &#123;</span><br><span class="line">		dispatch_once_f(predicate, context, function);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0</span>l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>predicate是<code>dispatch_once_t</code>类型的指针，用来指示block代码是否执行完毕。其实<code>dispatch_once_t</code>就是<code>long</code>类型：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="built_in">dispatch_once_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的核心就是if-else语句，<code>DISPATCH_EXPECT</code>告诉编译器predict的期待值是<code>~0l</code>，由编译器对代码进行优化，如果predicate != ~0l，说明block语句尚未执行过，进入<code>dispatch_once_f_slow</code>函数，进行一些操作，如：执行block，线程等待、block执行完成后唤醒等待线程等。否则，执行<code>dispatch_compiler_barrier</code>。这个if-else语句涉到了CPU的分支预测和指令预执行，放到下篇讲。</p>
<p>进入<code>dispatch_once_f_slow</code>函数之前，先看下dispatch_once的执行过程中可能遇到哪些情形：</p>
<ol>
<li>第一次执行，执行block，执行完成后置predicate标记</li>
<li>非第一次执行，而步骤1尚未执行完毕，此时线程需要等待步骤1完成，步骤1完成后依次唤醒等待的线程</li>
<li>非第一次执行，且步骤1已经执行完成，线程跳过block继续执行后续任务</li>
</ol>
<p>上述的1、2就是在<code>dispatch_once_f_slow</code>中进行处理的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dispatch_once_f_slow(<span class="built_in">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">	_dispatch_once_waiter_t <span class="keyword">volatile</span> *vval = (_dispatch_once_waiter_t*)val;</span><br><span class="line">	<span class="keyword">struct</span> _dispatch_once_waiter_s dow = &#123; &#125;;</span><br><span class="line">	_dispatch_once_waiter_t tail = &amp;dow, next, tmp;</span><br><span class="line">	dispatch_thread_event_t event;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (atomic_compare_exchange_strong_explicit((<span class="keyword">typeof</span>(*(vval)) _Atomic *)(vval), </span><br><span class="line">		<span class="literal">NULL</span>, tail, memory_order_acquire, memory_order_relaxed)) &#123;</span><br><span class="line">		dow.dow_thread = _dispatch_tid_self();</span><br><span class="line">		_dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">		next = (_dispatch_once_waiter_t)atomic_exchange_explicit((<span class="keyword">typeof</span>(*(val)) _Atomic *)(val), DLOCK_ONCE_DONE, memory_order_release);</span><br><span class="line">		<span class="keyword">while</span> (next != tail) &#123;</span><br><span class="line">			tmp = (_dispatch_once_waiter_t)_dispatch_wait_until(next-&gt;dow_next);</span><br><span class="line">			event = &amp;next-&gt;dow_event;</span><br><span class="line">			next = tmp;</span><br><span class="line">			_dispatch_thread_event_signal(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_thread_event_init(&amp;dow.dow_event);</span><br><span class="line">		next = *vval;</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="keyword">if</span> (next == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</span><br><span class="line">				dow.dow_thread = next-&gt;dow_thread;</span><br><span class="line">				dow.dow_next = next;</span><br><span class="line">				<span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line">					pthread_priority_t pp = _dispatch_get_priority();</span><br><span class="line">					_dispatch_thread_override_start(dow.dow_thread, pp, val);</span><br><span class="line">				&#125;</span><br><span class="line">				_dispatch_thread_event_wait(&amp;dow.dow_event);</span><br><span class="line">				<span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line">					_dispatch_thread_override_end(dow.dow_thread, val);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		_dispatch_thread_event_destroy(&amp;dow.dow_event);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看函数的入参：</p>
<ul>
<li><code>dispatch_once_t *val</code>，即外部传入的predicate标识，指示上述步骤1是否完成</li>
<li><code>void *ctxt</code>，需要执行的block的指针</li>
<li><code>dispatch_function_t func</code>，由libdispatch封装的block内部的执行函数</li>
</ul>
<p>接下来是声明变量：</p>
<ul>
<li><code>vval</code>：由volatile修饰的val，</li>
</ul>
<blockquote>
<p>volatile关键字的作用是告诉编译器：这个值随时可能改变，每次用的时候都要从内存中取，使得编译器不对该值进行优化</p>
</blockquote>
<ul>
<li><code>tail, next, tmp</code>都是<code>_dispatch_once_waiter_t</code>类型的变量，其中tail被初始化为<code>dow</code>，这些值与线程等待链有关</li>
<li><code>dispatch_thread_event_t event</code>，用于线程的同步，<code>dispatch_thread_event_t</code>存储了线程的信号量信息</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dispatch_thread_event_s &#123;</span><br><span class="line"><span class="meta">#if HAVE_UL_COMPARE_AND_WAIT || HAVE_FUTEX</span></span><br><span class="line">	<span class="comment">// 1 means signalled but not waited on yet</span></span><br><span class="line">	<span class="comment">// UINT32_MAX means waited on, but not signalled yet</span></span><br><span class="line">	<span class="comment">// 0 is the initial and final state</span></span><br><span class="line">	uint32_t dte_value;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">	_dispatch_sema4_t dte_sema;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125; dispatch_thread_event_s, *dispatch_thread_event_t;</span><br></pre></td></tr></table></figure>
<p>接下来是if-else语句，通过<code>atomic_compare_exchange_strong_explicit</code>原子操作判断传入的val(即：predicate)是否为0，如果为0，说明是第一次执行，进入if分支，并将vval赋值为<code>&amp;dow</code> 执行block。</p>
<h4 id="if-分支"><a href="#if-分支" class="headerlink" title="if 分支"></a>if 分支</h4><p>dispatch_once第一次执行时，进入if分支，将vval赋值为<code>&amp;dow</code>，指向<code>_dispatch_once_waiter_s</code>类型的变量，即进入等待，等待<code>DISPATCH_ONCE_DONE</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _dispatch_once_waiter_s &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">struct</span> _dispatch_once_waiter_s *<span class="keyword">volatile</span> dow_next;</span><br><span class="line">	dispatch_thread_event_s dow_event;</span><br><span class="line">	mach_port_t dow_thread;</span><br><span class="line">&#125; *_dispatch_once_waiter_t;</span><br></pre></td></tr></table></figure>
<p>waiter结构体中有next指针，说明这些等待的线程构成了一个等待链。</p>
<p>然后<code>dow.dow_thread = _dispatch_tid_self();</code>将等待链的头指针指向当前线程。</p>
<p><code>_dispatch_client_callout</code>函数调用func执行block。</p>
<p>block执行完毕后，使用<code>next = (_dispatch_once_waiter_t)atomic_exchange_explicit((typeof(*(val)) _Atomic *)(val), DLOCK_ONCE_DONE, memory_order_release);</code>，这行代码的作用是：1、先将val的值赋值给next；2、把<code>DLOCK_ONCE_DONE</code>赋值给val，说明dispatch_once执行完毕。</p>
<p>由于dispatch_once面临的是多线程，在block执行的过程中可能有多个线程也调用了dispatch_once：</p>
<ol>
<li>如果在block执行完毕之前，没有其他线程调用dispatch_once，此时next应该是等于tail的，二者都为0，最后的while循环条件不成立；</li>
<li>如果在block执行完毕之前，有其他线程调用dispatch_once，此时next在else分支中被改变为<code>dow</code>，<code>next = *vval</code>，进入while循环。</li>
</ol>
<p>最后的while循环中，遍历等待链，调用<code>_dispatch_thread_event_signal</code>逐个signal信号量，唤醒等待的线程执行后续的操作。</p>
<h4 id="else-分支"><a href="#else-分支" class="headerlink" title="else 分支"></a>else 分支</h4><p>else分支是线程等待分支，在第一次调用dispatch_once开始执行block且未结束的时候，所有后来调用dispatch_once的线程都会进入等待分支。</p>
<p>首先是更改next的值为<code>*vval</code>，通过上文分析，此时的vval指针已经被赋值为<code>&amp;dow</code>。</p>
<p>然后进入一个无限for循环，如果发现vval的值为<code>DISPATCH_ONCE_DONE</code>，直接break，并调用<code>_dispatch_thread_event_destroy</code>函数销毁线程信号量，说明第一次的dispatch_once已经完成，此时进入的线程已经无需进入等待链了，直接执行后续操作即可。</p>
<p>如果vval的值不为<code>DISPATCH_ONCE_DONE</code>，说明第一次的dispatch_once还未完成，进行一个原子比较并交换的操作：<code>if (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release))</code>，我们把宏展开</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&#123;</span><br><span class="line">		_os_atomic_basetypeof(vval) _r = next; </span><br><span class="line">		_Bool _b = atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(vval), </span><br><span class="line">		&amp;_r, tail, memory_order_release, memory_order_relaxed); </span><br><span class="line">		next = _r; </span><br><span class="line">		_b;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p><code>atomic_compare_exchange_strong_explicit</code>就是进行比较并交换的原子操作函数，比较当前<code>vval</code>与<code>tail</code>的值。<code>tail</code>为初始化的dispatch_waiter对象，用于存储当前进入dispatch_once的等待线程的信息。</p>
<ol>
<li><p>如果二者相等，说明第一次的dispatch_once还未执行完毕（如果执行完毕，vval的值会被变更为<code>DLOCK_ONCE_DONE</code>），将<code>tail</code>赋值给<code>vval</code>，然后进入if流程，将当前进入等待线程的<code>dispatch_once_waiter</code>的next指针指向当前next。如果在dispatch_once尚未执行完毕的时候，不断地有线程进入等待，结合前面的<code>next = *vval</code>语句，可以看到这样一个线程进入等待链的过程：</p>
<p> 线程进入等待(创建<code>dispatch_once_waiter</code>：dow，并将其作为tail);<br> next = vval;<br> vval = tail;<br> tail-&gt;next = next;</p>
<p> 进入等待链的线程调用<code>_dispatch_thread_event_wait</code>来wait信号量，直到dispatch_once完成后signal信号量唤醒线程。</p>
</li>
<li><p>如果二者不相等，那只有一个可能，dispatch_once完成。将<code>vval</code>（此时的值为<code>DISPATCH_ONCE_DONE</code>）赋值给next，然后在for循环中触发<code>next == DISPATCH_ONCE_DONE</code>条件，break掉for循环，然后调用<code>_dispatch_thread_event_destroy</code>销毁信号量。</p>
</li>
</ol>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>如同libdispatch中其他代码一样，<code>dispatch_once_f_slow</code>中也使用了诸多的原子操作来实现无锁情形下的线程安全。实际上，原子操作是利用CPU指令执行的原子性实现的CPU级别的“锁”，比传统的软件锁（<code>pthread_mutex_lock等</code>）性能高很多，当我们使用软件锁所带来的性能消耗过大时，可以考虑使用原子锁。但是使用原子操作代替传统锁也有缺陷：编程实现较为复杂，一不小心可能会出问题而且bug难以查找。<br>下篇文章中，我们分析一下dispatch_once的性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/" itemprop="url">GCD源码分析（二）——Dispatch Queue和Thread Pool</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T19:21:37+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>大部分的GCD操作都离不开队列（queue）：使用<code>dispatch_get_main_queue</code>获取主队列，使用<code>dispatch_queue_create</code>创建一个自定义的队列，使用<code>dispatch_get_global_queue</code>获取一个全局的并发队列等等。那么GCD是如何通过这些队列实现多线程的呢？它又是如何管理这些队列的呢？<code>dispatch_async/dispatch_sync</code>是如何工作的呢？带着这些问题，我们从源码中寻找答案。</p>
<h3 id="二、队列与线程"><a href="#二、队列与线程" class="headerlink" title="二、队列与线程"></a>二、队列与线程</h3><p>首先，借用一张网上的图片直观地描述GCD队列和线程的关系。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/gcd_queues_thread.png" alt="GCD队列和线程"></p>
<p>通过GCD，我们可以很方便地实现多线程，而不需要过多地关注线程的实现和创建等，GCD内部维护了一个线程池，由系统根据任务的数量和优先级动态地创建和分配线程执行。</p>
<p>我们提交的任务由GCD内部的manager queue管理一层层地分发到target queue中，最终汇聚到root queue中并由线程池管理线程来执行任务。</p>
<p>线程和队列并不是一对一的关系，一个线程中可能有多个串行或并行队列，这些队列按照同步或异步的方式工作。</p>
<p>注：为方便阅读，文中的所有代码均为宏展开后的代码。</p>
<h4 id="GCD中队列的种类"><a href="#GCD中队列的种类" class="headerlink" title="GCD中队列的种类"></a>GCD中队列的种类</h4><p>从libdispatch源码中可以看到，GCD中一共有如下几种队列：</p>
<ul>
<li>主队列，使用<code>dispatch_get_main_queue()</code>获得的队列，与主线程绑定</li>
<li>全局队列，使用<code>dispatch_get_global_queue()</code>获得的队列，是并行队列，由GCD创建并管理，也是libdispatch内部使用的root-queue</li>
<li>自定义队列，使用<code>dispatch_queue_create()</code>创建的队列，为串行或并行队列</li>
<li>管理队列，libdispatch内部使用的队列，不暴露给开发者，作为队列的调度管理者使用</li>
<li>Runloop队列，用于与线程绑定的<code>dispatch_queue</code>，比如：提交到main-queue上的任务是由runloop-queue进行管理并最终调度到main thread的runloop中处理。</li>
</ul>
<h5 id="主队列main-queue"><a href="#主队列main-queue" class="headerlink" title="主队列main queue"></a>主队列main queue</h5><p>在<code>dispatch_get_main_queue()</code>的函数声明处有如下内容：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @function dispatch_get_main_queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @abstract</span></span><br><span class="line"><span class="comment"> * Returns the default queue that is bound to the main thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @discussion</span></span><br><span class="line"><span class="comment"> * In order to invoke blocks submitted to the main queue, the application must</span></span><br><span class="line"><span class="comment"> * call dispatch_main(), NSApplicationMain(), or use a CFRunLoop on the main</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @result</span></span><br><span class="line"><span class="comment"> * Returns the main queue. This queue is created automatically on behalf of</span></span><br><span class="line"><span class="comment"> * the main thread before main() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>可以看出主队列在<code>main()</code>函数调用之前被创建，同时也说明了libdispatch库的初始化工作在main函数之前就完成了。</p>
<p>调用<code>dispatch_get_main_queue()</code>返回的是<code>_dispatch_main_q</code>这样一个<code>dispatch_queue_t</code>类型的结构体。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_get_main_queue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (__bridge <span class="built_in">dispatch_queue_t</span>)&amp;(_dispatch_main_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_main_q</code>的结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_main_q = &#123;</span><br><span class="line">	.do_vtable = OS_dispatch_queue_main_class,</span><br><span class="line">	._objc_isa = OS_dispatch_queue_main_class</span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT</span><br><span class="line"><span class="meta">#if !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT],</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_CANNOT_TRYSYNC | DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到<code>_dispatch_main_q</code>包含以下属性：</p>
<h5 id="1、-do-vtable、-objc-isa"><a href="#1、-do-vtable、-objc-isa" class="headerlink" title="1、.do_vtable、._objc_isa"></a>1、.do_vtable、._objc_isa</h5><ul>
<li>do_vtable 包含了队列的类型、dispose、invoke、push、wakeup和debug等信息，这些信息与队列和任务的调度有关</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"main-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_main_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>_objc_isa main_queue的isa指针指向OS_dispatch_queue_main_class</li>
</ul>
<h5 id="2、-do-ref-cnt、-do-xref-cnt"><a href="#2、-do-ref-cnt、-do-xref-cnt" class="headerlink" title="2、.do_ref_cnt、.do_xref_cnt"></a>2、.do_ref_cnt、.do_xref_cnt</h5><p>队列的内部、外部引用计数都赋值为<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>，而<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>的实际定义为<code>INT_MAX</code>，说明了主队列的生命周期与App的生命周期一致，开发者无需对主队列进行retain/release操作，其生命周期由GCD管理。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_OBJECT_GLOBAL_REFCNT		_OS_OBJECT_GLOBAL_REFCNT</span></span><br><span class="line"><span class="meta">#define _OS_OBJECT_GLOBAL_REFCNT INT_MAX</span></span><br></pre></td></tr></table></figure>
<h5 id="3、-do-targetq"><a href="#3、-do-targetq" class="headerlink" title="3、.do_targetq"></a>3、.do_targetq</h5><p>主队列的target queue为<code>&amp;_dispatch_root_queues[
            DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT],</code>，实际上就是serialnum=11的”com.apple.root.default-qos.overcommit”这个全局队列，注意这里虽然有个条件编译命令：<code>#if !DISPATCH_USE_RESOLVERS</code>，但是实际上在<code>libdispatch_init()</code>函数中又一次设置了main_queue的do_targetq：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DISPATCH_USE_RESOLVERS // rdar://problem/8541707</span></span><br><span class="line">	_dispatch_main_q.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>所以无论条件编译是否命中，主队列的target queue都被设置为”com.apple.root.default-qos.overcommit”这个root queue。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/2.png" alt="dispatch_main_queue的target_queue"></p>
<blockquote>
<p>GCD中所有的非全局队列（自定义队列及内部的管理队列）的任务最终都是要提交到全局队列（即：root queue）中处理，主队列除外，主队列与主线程绑定，提交到主队列中的任务由runloop queue管理并提交到主线程的runloop执行。</p>
</blockquote>
<h5 id="全局队列global-queue"><a href="#全局队列global-queue" class="headerlink" title="全局队列global queue"></a>全局队列global queue</h5><p>GCD内部维护12个全局队列，对应上述的四个优先级：High/Default/Low/Background。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_root_queues[] = &#123;</span><br><span class="line"><span class="meta">#define _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">	((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_<span class="meta">##n##_QOS_OVERCOMMIT : \</span></span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_<span class="meta">##n##_QOS)</span></span><br><span class="line"><span class="meta">#define _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT_HEADER(queue_root), \</span><br><span class="line">		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[ \</span><br><span class="line">				_DISPATCH_ROOT_QUEUE_IDX(n, flags)], \</span><br><span class="line">		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">		.dq_priority = _dispatch_priority_make(DISPATCH_QOS_<span class="meta">##n, 0) | flags | \</span></span><br><span class="line">				DISPATCH_PRIORITY_FLAG_ROOTQUEUE | \</span><br><span class="line">				((flags &amp; DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE) ? <span class="number">0</span> : \</span><br><span class="line">				DISPATCH_QOS_<span class="meta">##n <span class="meta-string">&lt;&lt; DISPATCH_PRIORITY_OVERRIDE_SHIFT), \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		__VA_ARGS__ \</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.maintenance-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 4,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.maintenance-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 5,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.background-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 6,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.background-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 7,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.utility-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 8,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.utility-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 9,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.default-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 10,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">			DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.default-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 11,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-initiated-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 12,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-initiated-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 13,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, 0,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-interactive-qos",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 14,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_label = "com.apple.root.user-interactive-qos.overcommit",</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">		.dq_serialnum = 15,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">	),</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>dq_serialnum为队列号，全局队列的队列号从4开始，前面三个分别为：</p>
<ul>
<li>主队列，dq_serialnum = 1</li>
<li>管理队列（_dispatch_mgr_q），dq_serialnum = 2</li>
<li>dispatch_mgr_root_queue（_dispatch_mgr_q的目标队列），dq_serialnum = 3</li>
</ul>
<h5 id="管理队列manager-queue"><a href="#管理队列manager-queue" class="headerlink" title="管理队列manager queue"></a>管理队列manager queue</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s _dispatch_mgr_q = &#123;</span><br><span class="line">	.do_vtable = DISPATCH_VTABLE(queue_mgr), </span><br><span class="line">	._objc_isa = DISPATCH_OBJC_CLASS(queue_mgr), </span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, </span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.do_targetq = &amp;_dispatch_mgr_root_queue,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.libdispatch-manager"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |</span><br><span class="line">			DISPATCH_PRIORITY_SATURATED_OVERRIDE,</span><br><span class="line">	.dq_serialnum = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> dispatch_queue_s _dispatch_mgr_root_queue = &#123;</span><br><span class="line">	DISPATCH_GLOBAL_OBJECT_HEADER(queue_root),</span><br><span class="line">	.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE,</span><br><span class="line">	.do_ctxt = &amp;_dispatch_mgr_root_queue_context,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.root.libdispatch-manager"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL),</span><br><span class="line">	.dq_priority = DISPATCH_PRIORITY_FLAG_MANAGER |</span><br><span class="line">			DISPATCH_PRIORITY_SATURATED_OVERRIDE,</span><br><span class="line">	.dq_serialnum = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line"><span class="comment">// 6618342 Contact the team that owns the Instrument DTrace probe before</span></span><br><span class="line"><span class="comment">//         renaming this symbol</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_dispatch_worker_thread(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line"><span class="meta">#if DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">bool</span> overcommit = (qc-&gt;dgq_wq_options &amp; WORKQ_ADDTHREADS_OPTION_OVERCOMMIT);</span><br><span class="line">	<span class="keyword">bool</span> manager = (dq == &amp;_dispatch_mgr_root_queue);</span><br><span class="line">	<span class="keyword">bool</span> monitored = !(overcommit || manager);</span><br><span class="line">	<span class="keyword">if</span> (monitored) &#123;</span><br><span class="line">		_dispatch_workq_worker_register(dq, qc-&gt;dgq_qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> int64_t timeout = <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">	pthread_priority_t old_pri = _dispatch_get_priority();</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_root_queue_drain(dq, old_pri);</span><br><span class="line">		_dispatch_reset_priority_and_voucher(old_pri, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dispatch_semaphore_wait(&amp;pqc-&gt;dpq_thread_mediator,</span><br><span class="line">			dispatch_time(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (monitored) &#123;</span><br><span class="line">		_dispatch_workq_worker_unregister(dq, qc-&gt;dgq_qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	(<span class="keyword">void</span>)os_atomic_inc2o(qc, dgq_thread_pool_size, release);</span><br><span class="line">	_dispatch_global_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	_dispatch_release(dq); <span class="comment">// retained in _dispatch_global_queue_poke_slow</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif // DISPATCH_USE_PTHREAD_POOL</span></span><br></pre></td></tr></table></figure>
<p>从代码可以看出，manager queue是作为root queue与线程池之间的调度和管理者的，如：GCD Timer的实现就用到了管理队列</p>
<h5 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a>自定义队列</h5><p>使用<code>dispatch_queue_create</code>创建自定义队列，为方便阅读，只保留主要流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span></span><br><span class="line">_dispatch_queue_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t dqa,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(dqa)) &#123;</span><br><span class="line">		<span class="comment">// 如果没有传入dispatch_queue_attr_t，将其设置为默认参数</span></span><br><span class="line">		dqa = _dispatch_get_default_queue_attr();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;do_vtable != DISPATCH_VTABLE(queue_attr)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 获取要创建的队列的优先级</span></span><br><span class="line">	dispatch_qos_t qos = _dispatch_priority_qos(dqa-&gt;dqa_qos_and_relpri);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		<span class="comment">// 如果没有指定target queue, 将dispatch_root_queue赋值给tq</span></span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">		<span class="keyword">if</span> (slowpath(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqa-&gt;dqa_inactive || dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建dispatch_queue的vtable参数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	dispatch_queue_flags_t dqf = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;dqa_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">	<span class="comment">// 根据上文的参数初始化队列</span></span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqa-&gt;dqa_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqa-&gt;dqa_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置label</span></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	<span class="comment">// 设置优先级</span></span><br><span class="line">	dq-&gt;dq_priority = dqa-&gt;dqa_qos_and_relpri;</span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_priority) &#123;</span><br><span class="line">		<span class="comment">// legacy way of inherithing the QoS from the target</span></span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqa-&gt;dqa_inactive) &#123;</span><br><span class="line">		_dispatch_queue_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// retain target queue，防止其提前释放</span></span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	<span class="comment">// 设置target queue</span></span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="comment">// 自省函数</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据传入的参数调用<code>_dispatch_queue_init</code>创建相应的串行或并行队列，然后设置label、队列优先级，并设置target queue为dispatch_root_queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">dq-&gt;do_targetq = tq;</span><br></pre></td></tr></table></figure>
<p>targetq的作用就是将push到queue中的任务（可能是任务也可能是queue）层层向上push，最终push到全局队列中，由全局队列调度线程池来执行任务（或者pop queue）。</p>
<blockquote>
<p>While custom queues are a powerful abstraction, all blocks you schedule on them will ultimately trickle down to one of the system’s global queues and its thread pool(s).</p>
</blockquote>
<blockquote>
<p>虽然自定义队列是一个强大的抽象，但你在队列上安排的所有Block最终都会渗透到系统的某一个全局队列及其线程池。</p>
</blockquote>
<h5 id="Runloop队列"><a href="#Runloop队列" class="headerlink" title="Runloop队列"></a>Runloop队列</h5><p>Runloop队列用于与线程绑定的队列的任务调度，比如主队列，看下main queue的wake up函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_main_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_is_thread_bound(dq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_queue_is_thread_bound</code>函数判断当前队列是否是与线程绑定的，由于主队列是绑定在主线程上的，这里就调用了<code>_dispatch_runloop_queue_wakeup</code>函数，由runloop queue将任务调度到主线程的runloop上，最终由主线程runloop在合适的时机执行。</p>
<h4 id="GCD-dispatch流程分析"><a href="#GCD-dispatch流程分析" class="headerlink" title="GCD dispatch流程分析"></a>GCD dispatch流程分析</h4><p>上一篇文章说过，<code>dispatch_queue_s</code>结构体中有<code>do_vtable</code>元素，这个<code>do_vtable</code>中包含了队列的push/wakeup/invoke/dispose等与dispatch相关的信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_main, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"main-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_main_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其它队列，如：manager queue、runloop queue、root queue等也有类似的vtable结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// manager queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_mgr, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_MGR_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"mgr-queue"</span>,</span><br><span class="line">	.do_push = _dispatch_mgr_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_mgr_thread,</span><br><span class="line">	.do_wakeup = _dispatch_mgr_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// runloop queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_runloop, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_RUNLOOP_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"runloop-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_runloop_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_queue_push,</span><br><span class="line">	.do_invoke = _dispatch_queue_invoke,</span><br><span class="line">	.do_wakeup = _dispatch_runloop_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// root queue vtable</span></span><br><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_root, queue,</span><br><span class="line">	.do_type = DISPATCH_QUEUE_GLOBAL_ROOT_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_pthread_root_queue_dispose,</span><br><span class="line">	.do_push = _dispatch_root_queue_push,</span><br><span class="line">	.do_invoke = <span class="literal">NULL</span>,</span><br><span class="line">	.do_wakeup = _dispatch_root_queue_wakeup,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_push: 调用push操作将任务提交到queue上</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_continuation_push(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">   dx_vtable(dq)-&gt;do_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_wakeup: 当push任务到队列中时，会调用do_wakeup唤醒队列</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_queue_push_inline(<span class="built_in">dispatch_queue_t</span> dq, dispatch_object_t _tail,</span><br><span class="line">		dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *tail = _tail._do;</span><br><span class="line">	dispatch_wakeup_flags_t flags = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> dx_vtable(dq)-&gt;do_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>.do_invoke: 在libdispatch中，do_invoke只在以下3种情况执行：1、任务出队；2、runloop queue出队；3、如果queue重写了invoke，则当queue元素出队时，调用<code>_dispatch_queue_override_invoke</code>，在<code>_dispatch_queue_override_invoke</code>函数中调用do_invoke。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 1.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(dispatch_object_t dou,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_pthread_root_queue_observer_hooks_t observer_hooks =</span><br><span class="line">			_dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">	_dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">	flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">	   <span class="comment">/// 调用invoke，执行任务</span></span><br><span class="line">		dx_invoke(dou._do, dic, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_root_queue_drain_deferred_wlh(dispatch_deferred_items_t ddi</span><br><span class="line">		DISPATCH_PERF_MON_ARGS_PROTO)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">retry:</span><br><span class="line">	dispatch_assert(ddi-&gt;ddi_wlh_needs_delete);</span><br><span class="line">	<span class="comment">// 出队一个任务块</span></span><br><span class="line">	_dispatch_trace_continuation_pop(rq, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_drain_try_lock_wlh(dq, &amp;dq_state)) &#123;</span><br><span class="line">	   <span class="comment">/// runloop queue出队一个元素，调用其invoke函数</span></span><br><span class="line">		dx_invoke(dq, &amp;dic, flags);</span><br><span class="line">		...</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3.</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(dispatch_continuation_t dc,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">	dispatch_priority_t old_dp;</span><br><span class="line">	voucher_t ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">	dispatch_object_t dou;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	_dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">		<span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">			dx_invoke(dou._do, dic, flags);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	_dispatch_reset_basepri(old_dp);</span><br><span class="line">	_dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了主队列，其他所有队列中提交的任务最终都要通过层层的target queue提交到root queue中（把queue整体提交到target queue中），从线程池中取出或新建一个线程执行：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_queue_class_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags, dispatch_queue_wakeup_target_t target)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">		_dispatch_retain_2(dq);</span><br><span class="line">		flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">			<span class="built_in">dispatch_queue_t</span> tq;</span><br><span class="line">			<span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">				os_atomic_thread_fence();dependency</span><br><span class="line">				tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">						(<span class="keyword">long</span>)new_state);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tq = target;</span><br><span class="line">			&#125;</span><br><span class="line">			dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">			<span class="comment">// 将queue提交到它的target queue中</span></span><br><span class="line">			<span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">		&#125;</span><br><span class="line">      ...</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么队列的dispatch的大致流程如下所示：</p>
<p>提交任务到queue -&gt; 调用push将任务入队 -&gt; 调用wakeup唤醒队列 -&gt; 如果有target queue，往上提交，直到root queue为止 -&gt; 由root queue从线程池中取出或创建一个新线程执行任务。</p>
<p>主队列的dispatch流程与上述略有不同，提交到主队列的任务由GCD内部的runloop queue管理并最终由主线程的runloop执行。</p>
<h5 id="dispatch-async分析"><a href="#dispatch-async分析" class="headerlink" title="dispatch_async分析"></a>dispatch_async分析</h5><p>先看下主队列上的异步任务。</p>
<h6 id="主队列的dispatch-async"><a href="#主队列的dispatch-async" class="headerlink" title="主队列的dispatch_async"></a>主队列的dispatch_async</h6><p>如果我们想在主线程中执行一个异步操作，通常的做法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch async in main queue"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述这段代码在libdispatch内部的流程如下：</p>
<p>1、将传入的block任务转换成一个<code>dispatch_continuation_t</code>类型的结构体对象，然后调用<code>_dispatch_continuation_async</code>将continuation push到main queue中。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 分配空间</span></span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line">   <span class="comment">// block转换成dispatch_continuation对象</span></span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">	   <span class="comment">// 将任务push到main queue中</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在libdispatch源码中能经常见到fastpath、slowpath、likely、unlikely等宏，编写这些宏的目的是告诉编译器来对我们的代码进行优化，通常：</p>
<ul>
<li>fastpath/likely 表示条件更可能成立</li>
<li>slowpath/unlikely 表示条件更不可能成立</li>
</ul>
<p>2、唤醒main queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_continuation_push(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">   dx_vtable(dq)-&gt;do_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上文说过main queue的vtable存储了push/wakeup/invoke等信息，上述代码实际上是调用了_dispatch_queue_push</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_queue_push_inline(<span class="built_in">dispatch_queue_t</span> dq, dispatch_object_t _tail,</span><br><span class="line">		dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这里调用queue的wakeup函数</span></span><br><span class="line">	<span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、wakeup runloop queue</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_main_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_is_thread_bound(dq)) &#123;</span><br><span class="line">	   <span class="comment">// 这里是判断queue是否与与线程绑定，main queue的wake up命中判断，唤醒runloop queue.</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_runloop_queue_wakeup(<span class="built_in">dispatch_queue_t</span> dq, dispatch_qos_t qos,</span><br><span class="line">		dispatch_wakeup_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">	   <span class="comment">// 判断队列中是否有任务，如果有，执行runloop queue poke操作</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_runloop_queue_poke(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_wakeup(dq, qos, flags);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、唤醒主线程，并注册回调函数，由mach内核在合适的时机执行<code>_dispatch_main_queue_drain</code>操作</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_class_poke(<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_runloop_handle_t handle = _dispatch_runloop_queue_get_handle(dq);</span><br><span class="line">	<span class="keyword">if</span> (!_dispatch_runloop_handle_is_valid(handle)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if HAVE_MACH</span></span><br><span class="line">	mach_port_t mp = handle;</span><br><span class="line">	kern_return_t kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">switch</span> (kr) &#123;</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		(<span class="keyword">void</span>)dispatch_assume_zero(kr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#error <span class="meta-string">"runloop support not implemented on this platform"</span></span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_main_queue_callback_4CF(</span><br><span class="line">		<span class="keyword">void</span> *ignored DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (main_q_is_draining) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">true</span>);</span><br><span class="line">	_dispatch_main_queue_drain();</span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、执行<code>_dispatch_continuation_pop_inline</code>函数，如果主队列中有未完成的任务，将任务出队并执行。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_main_queue_drain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);</span><br><span class="line">		_dispatch_continuation_pop_inline(dc, &amp;dic, DISPATCH_INVOKE_NONE, dq);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(dispatch_object_t dou,</span><br><span class="line">		dispatch_invoke_context_t dic, dispatch_invoke_flags_t flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">		dx_invoke(dou._do, dic, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，主队列的dispatch_async流程执行完毕，其实我们在xcode断点时的堆栈信息也能窥探一二。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/3.png" alt="dispatch_async(dispatch_main_queue)的调用栈"></p>
<h6 id="自定义队列-全局队列上的dispatch-async"><a href="#自定义队列-全局队列上的dispatch-async" class="headerlink" title="自定义队列/全局队列上的dispatch_async"></a>自定义队列/全局队列上的dispatch_async</h6><p>示例代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、自定义串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> customSerialQueue = dispatch_queue_create(<span class="string">"com.gcd.queue.custom"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(customSerialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customSerialQueue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、自定义并行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> customConcurrentQueue = dispatch_queue_create(<span class="string">"com.gcd.queue.custom"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(customConcurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customConcurrentQueue task"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(QOS_CLASS_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3、全局队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"customGlobalQueue task"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>自定义创建的并行队列比其他队列（串行队列和全局队列）多了一个redirection流程</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 判断是否需要redirection，如果不需要，将任务入队</span></span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行redirection流程</span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>DISPATCH_QUEUE_USES_REDIRECTION</code>这个宏是用来判断queue是否需要redirection，如果<code>dq_width</code>满足<code>width &gt; 1 &amp;&amp; width &lt; 0xfff</code>条件，则队列需要热direction。串行队列(<code>dq_width</code> = 1)和全局队列(<code>dq_width</code> = 0xfff)都不满足上述条件，无需direction。</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/4.png" alt="queue width"></p>
<p>redirection：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f_redirect(<span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_object_t dou, dispatch_qos_t qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(_dispatch_object_is_redirection(dou))) &#123;</span><br><span class="line">		dou._dc = _dispatch_async_redirect_wrap(dq, dou);</span><br><span class="line">	&#125;</span><br><span class="line">	dq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the queue to redirect to</span></span><br><span class="line">	<span class="keyword">while</span> (slowpath(DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!fastpath(_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		dq = dq-&gt;do_targetq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>redirection操作的目的就是要将任务最终push到root queue中。</p>
<p>对于无需redirection的队列，调用其push函数，将任务push到队列中，分两种情况：</p>
<ul>
<li>普通的自定义队列：如果queue有target_queue，调用<code>_dispatch_queue_push_queue</code>，将queue层层向上push到target_queue中，最终push到root queue中。</li>
<li>全局队列：由于全局队列(root queue)没有target_queue，调用<code>_dispatch_root_queue_push</code>直接把任务push到root queue中。</li>
</ul>
<p>最终，所有提交到非主队列的任务都push到了root queue中，由root queue调度线程池并分配线程执行。 </p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// root queue线程池管理相关</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_global_queue_poke_slow(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> floor)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_root_queue_context_t qc = dq-&gt;do_ctxt;</span><br><span class="line">	<span class="keyword">int</span> remaining = n;</span><br><span class="line">	<span class="keyword">int</span> r = ENOSYS;</span><br><span class="line"></span><br><span class="line">	_dispatch_root_queues_init();</span><br><span class="line">	_dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">...</span><br><span class="line"><span class="meta">#if DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">	dispatch_pthread_root_queue_context_t pqc = qc-&gt;dgq_ctxt;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(pqc-&gt;dpq_thread_mediator.do_vtable)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (dispatch_semaphore_signal(&amp;pqc-&gt;dpq_thread_mediator)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"signaled sleeping worker for "</span></span><br><span class="line">					<span class="string">"global queue: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">if</span> (!--remaining) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> overcommit = dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	<span class="keyword">if</span> (overcommit) &#123;</span><br><span class="line">		os_atomic_add2o(qc, dgq_pending, remaining, relaxed);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!os_atomic_cmpxchg2o(qc, dgq_pending, <span class="number">0</span>, remaining, relaxed)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"worker thread request still pending for "</span></span><br><span class="line">					<span class="string">"global queue: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int32_t can_request, t_count;</span><br><span class="line">	<span class="comment">// seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt;</span></span><br><span class="line">	t_count = os_atomic_load2o(qc, dgq_thread_pool_size, ordered);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		can_request = t_count &lt; floor ? <span class="number">0</span> : t_count - floor;</span><br><span class="line">		<span class="keyword">if</span> (remaining &gt; can_request) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"pthread pool reducing request from %d to %d"</span>,</span><br><span class="line">					remaining, can_request);</span><br><span class="line">			os_atomic_sub2o(qc, dgq_pending, remaining - can_request, relaxed);</span><br><span class="line">			remaining = can_request;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">"pthread pool is full for root queue: "</span></span><br><span class="line">					<span class="string">"%p"</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!os_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">			t_count - remaining, &amp;t_count, acquire));</span><br><span class="line"></span><br><span class="line">	pthread_attr_t *attr = &amp;pqc-&gt;dpq_thread_attr;</span><br><span class="line">	pthread_t tid, *pthr = &amp;tid;</span><br><span class="line"><span class="meta">#if DISPATCH_USE_MGR_THREAD &amp;&amp; DISPATCH_ENABLE_PTHREAD_ROOT_QUEUES</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq == &amp;_dispatch_mgr_root_queue)) &#123;</span><br><span class="line">		pthr = _dispatch_mgr_root_queue_init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_retain(dq); <span class="comment">// released in _dispatch_worker_thread</span></span><br><span class="line">		<span class="keyword">while</span> ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">				(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_temporary_resource_shortage();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (--remaining);</span><br><span class="line"><span class="meta">#endif // DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么root queue是如何出队的呢？上述代码的do-while循环中调用了<code>pthread_create</code>创建新的线程，并将线程运行函数起始地址指向<code>_dispatch_worker_thread</code>，那么线程创建后会执行<code>_dispatch_worker_thread</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_dispatch_worker_thread(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_root_queue_drain(dq, old_pri);</span><br><span class="line">		_dispatch_reset_priority_and_voucher(old_pri, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (dispatch_semaphore_wait(&amp;pqc-&gt;dpq_thread_mediator,</span><br><span class="line">			dispatch_time(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">	_dispatch_global_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="built_in">dispatch_queue_t</span> dq, pthread_priority_t pp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">		_dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">		reset = _dispatch_reset_basepri_override();</span><br><span class="line">		<span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	_dispatch_last_resort_autorelease_pool_pop(&amp;dic);</span><br><span class="line"><span class="meta">#endif // DISPATCH_COCOA_COMPAT</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_dispatch_worker_thread</code>中进行drain root queue，将root queue中的元素一个个出队，元素出队时调用<code>_dispatch_continuation_pop_inline</code>，触发队元素的<code>.do_invoke</code>，执行任务。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>整理一下dispatch_async的流程：</p>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/5.png" alt="dispatch_async流程"></p>
<h4 id="dispatch-sync分析"><a href="#dispatch-sync分析" class="headerlink" title="dispatch_sync分析"></a>dispatch_sync分析</h4><p>dispatch_sync的流程与上文分析的大同小异，一般来说同步任务是在当前线程中执行，同时它会阻塞当前线程直到任务执行完毕。</p>
<ul>
<li>当queue时串行队列时，当前线程会获取lock，如果成功则执行任务，否则出发crash，比如</li>
</ul>
<p><img src="/2018/11/29/GCD源码分析（二）——Dispatch-Queue和Thread-Pool/6.png" alt="dispatch_sync死锁"></p>
<ul>
<li>当queue是并行队列时，会直接执行任务。</li>
</ul>
<p>关于dispatch_sync的流程不详细分析了，这里重点关注一下lock机制以及引起死锁的情形。</p>
<p><code>dispatch_sync_f</code>函数：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">	   <span class="comment">// 串行队列</span></span><br><span class="line">		<span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dq))) &#123;</span><br><span class="line">	   <span class="comment">// 全局队列</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">	   <span class="comment">// 多重队列，寻找最终的targetq，最终还是会回到该函数中</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行队列中的任务</span></span><br><span class="line">	_dispatch_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取队列的lock"><a href="#获取队列的lock" class="headerlink" title="获取队列的lock"></a>获取队列的lock</h5><p><code>dispatch_sync_f</code>函数中，如果是串行队列，执行<code>dispatch_barrier_sync_f</code>，一步步往下执行，会看到lock相关的函数：<code>_dispatch_queue_try_acquire_barrier_sync_and_suspend</code>。</p>
<p>使用宏替换后的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync_and_suspend(<span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		uint32_t tid, uint64_t suspend_count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 根据queue的width初始化init</span></span><br><span class="line">	uint64_t init  = DISPATCH_QUEUE_STATE_INIT_VALUE(dq-&gt;dq_width);</span><br><span class="line">	<span class="comment">// _dispatch_lock_value_from_tid获取传入tid的第3到32位，mask为0xfffffffc</span></span><br><span class="line">	uint64_t value = DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |</span><br><span class="line">			_dispatch_lock_value_from_tid(tid) |</span><br><span class="line">			(suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL);</span><br><span class="line">	uint64_t old_state, new_state;</span><br><span class="line">	<span class="keyword">bool</span> _result = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">typeof</span>(&amp;(dq)-&gt;dq_state) _p = &amp;(dq)-&gt;dq_state;</span><br><span class="line">	<span class="comment">// 原子操作，获取queue的dq_state并赋值给old_state</span></span><br><span class="line">	old_state = os_atomic_load(_p, relaxed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		uint64_t role = old_state &amp; DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">		<span class="keyword">if</span> (old_state != (init | role)) &#123;</span><br><span class="line">			<span class="comment">// 如果old_state与(init | role)值不相等，说明queue的dq_state被改变，当前有thread持有该queue,</span></span><br><span class="line">			<span class="comment">// 终止循环并直接返回false</span></span><br><span class="line">			os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		new_state = value | role;</span><br><span class="line"></span><br><span class="line">		_os_atomic_basetypeof(_p) _r = old_state; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断old_state是否等于new_state, </span></span><br><span class="line">		<span class="comment">// 如果相等，获取lock成功，置db.dq_state为new_state，并返回true</span></span><br><span class="line">		<span class="comment">// 否则，获取lock失败，结束循环，返回false</span></span><br><span class="line">		_Bool _b = atomic_compare_exchange_weak_explicit(_os_atomic_c11_atomic(_p), &amp;_r, new_state, memory_order_acquire, memory_order_relaxed); </span><br><span class="line">		old_state = _r;</span><br><span class="line">		_result = _b;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (os_unlikely(!_result));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，libdispatch通过一些原子操作来比较queue.dq_state的值来实现lock操作：</p>
<p>1、如果dq_state为初始值(<code>init | role</code>)，说明当前queue没有被任何线程lock，则lock成功并设置dq_state为(<code>value | role</code>)；<br>2、否则lock失败，返回false。</p>
<p>线程获取到queue的lock后，queue.dq_state中同时也记录了当前持有lock的线程的tid信息。</p>
<p>再返回到上一级函数<code>dispatch_barrier_sync_f</code>中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_barrier_sync_f(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fastpath, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fastpath, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dq, tid))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_queue_barrier_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当lock失败后，进入到<code>_dispatch_sync_f_slow</code>等待上一个任务执行完成：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_wait(<span class="built_in">dispatch_queue_t</span> top_dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t top_dc_flags,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_priority_t pp = _dispatch_get_priority();</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line">	dispatch_qos_t qos;</span><br><span class="line">	uint64_t dq_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 死锁检测部分</span></span><br><span class="line">	<span class="comment">// 获取当前queue的dq_state</span></span><br><span class="line">	dq_state = _dispatch_sync_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, tid))) &#123;</span><br><span class="line">		<span class="comment">// 如果当前queue已经被当前thread持有，引起死锁，触发crash</span></span><br><span class="line">		DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> dispatch_sync_context_s dsc = &#123;</span><br><span class="line">		.dc_flags    = dc_flags | DISPATCH_OBJ_SYNC_WAITER_BIT,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = DISPATCH_NO_VOUCHER,</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = tid,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将任务入队</span></span><br><span class="line">	_dispatch_queue_push_sync_waiter(dq, &amp;dsc, qos);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待之前的任务执行完毕</span></span><br><span class="line">	<span class="keyword">if</span> (dsc.dc_data == DISPATCH_WLH_ANON) &#123;</span><br><span class="line">		<span class="comment">// 信号量等待，semaphore_wait(dsc.dsc_event-&gt;dte_sema)</span></span><br><span class="line">		_dispatch_thread_event_wait(&amp;dsc.dsc_event); <span class="comment">// acquire</span></span><br><span class="line">		<span class="comment">// 销毁信号量，结束等待，semaphore_destroy(mach_task_self(), dsc.dsc_event-&gt;dte_sema)</span></span><br><span class="line">		_dispatch_thread_event_destroy(&amp;dsc.dsc_event);</span><br><span class="line">		<span class="comment">// If _dispatch_sync_waiter_wake() gave this thread an override,</span></span><br><span class="line">		<span class="comment">// ensure that the root queue sees it.</span></span><br><span class="line">		<span class="keyword">if</span> (dsc.dsc_override_qos &gt; dsc.dsc_override_qos_floor) &#123;</span><br><span class="line">			_dispatch_set_basepri_override_qos(dsc.dsc_override_qos);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 等待owner释放</span></span><br><span class="line">		_dispatch_event_loop_wait_for_ownership(&amp;dsc);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终调用_dispatch_sync_function_invoke_inline，执行任务</span></span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="built_in">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h5><p>死锁的产生必须满足四个必要条件：</p>
<ul>
<li>资源互斥访问</li>
<li>请求与保持</li>
<li>不剥夺</li>
<li>循环等待</li>
</ul>
<p>libdispatch中创建并分配线程来执行任务块的过程中，线程/队列对资源的操作满足上述前三个条件，那么如果再满足第四个条件，必然会发生死锁。</p>
<p>在GCD中满足两个条件即会形成循环等待的情形：</p>
<ul>
<li><strong>串行队列</strong>正在执行任务Task 1（无论是sync还是async方式提交的）</li>
<li>Task 1未执行完成，又向队列中同步提交Task 2（<strong>dispatch_sync</strong>方式提交）</li>
</ul>
<p>死锁的示例代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQ = dispatch_queue_create(<span class="string">"com.testqueue.serial"</span>, DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 2."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQ, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQ, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 2."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 两种情况输出一样：</span></span><br><span class="line">Task <span class="number">1</span> begin.</span><br><span class="line"><span class="comment">// 并且发生crash, xcode提示：Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</span></span><br></pre></td></tr></table></figure>
<p>新版libdispatch中引入了死锁检测机制，发生死锁时，主动触发程序crash，并定位到引起死锁的代码，降低了调试难度。</p>
<p>死锁检测相关的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dq_state = _dispatch_sync_wait_prepare(dq);</span><br><span class="line"><span class="keyword">if</span> (unlikely(_dispatch_lock_is_locked_by(dq_state, tid))) &#123;</span><br><span class="line">    <span class="comment">// 如果当前queue已经被当前thread持有，引起死锁，触发crash</span></span><br><span class="line">	DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看到，libdispatch是通过<code>(dq_state ^ tid) &amp; DLOCK_OWNER_MASK</code>这句代码判断dq是否被某个线程持有，而dq.dq_state中存有持有它的线程的tid信息，如果对应tid的线程持有了dq，则返回true，说明当前线程已持有dq，循环等待条件成立，产生死锁，否则返回false。</p>
<p>那么问题来了，如果在thread_A中提交Task1，在Task1还在执行时，在thread_B中同步提交Task2会发生什么情况呢，GCD能否检测出死锁呢？</p>
<p>测试代码中为了避开主线程死锁对测试的干扰，采用dispatch_async方式提交Task1。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.testqueue.serial"</span>, DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL);</span><br><span class="line">    <span class="comment">// 为了避免主线程的死锁，干扰测试结果，这里使用dispatch_async方式提交Task1.</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 1 begin."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"Task 2 begin."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Task 1 complete."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main queue task complete."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test[<span class="number">73008</span>:<span class="number">2443797</span>] main queue complete.</span><br><span class="line">Test[<span class="number">73008</span>:<span class="number">2443854</span>] Task <span class="number">1</span> begin.</span><br></pre></td></tr></table></figure>
<p>此时程序卡住并没有crash，xcode也并未提示任何crash信息。</p>
<p>这说明了libdispatch死锁检测机制的问题：它只针对在同一个线程中向串行队列同步提交任务的情况。如果Task 2是在其它线程中同步提交的，它就无法检测出来了。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>本文只是粗略地分析了GCD的queue、dispatch过程以及queue和线程之间的调度关系，libdispatch源码的繁杂远远不止于此，细节之处还有如：mach_port通信、线程tsd、runloop callback、系统内核(libkern)交互等等，同时还有一些提升程序性能的编程技巧等（libdispatch为了最大限度地提升性能，大量使用了原子操作而非<code>pthread_mutex_lock</code>、<code>OSSpinLock/OSUnfairLock</code>等锁来实现同步）。感兴趣的同学可以把源码下载下来仔细阅读一下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/11/29/GCD源码分析（一）——“对象”和数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/" itemprop="url">GCD源码分析（一）——“对象”和数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T10:43:30+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Grand Central Dispatch(GCD)作为iOS和MacOS开发中不可或缺的工具，它的重要性不言而喻。作为一个喜欢刨根问底的猿，知其然更要知其所以然。网上关于GCD解析的文章不多，仅有的几篇使用的源码版本很老，<code>libdispatch</code>从187.10发展到913.60，其内部已经发生了很多变化。趁工作之余断断续续把GCD的源码<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch-913.60.2.tar.gz</a>看了一下，算是对它的底层原理有了一个大致的了解。</p>
<p>本篇作为系列文章的第一篇，先讲一下GCD中“对象”和数据结构。</p>
<h5 id="为什么“对象”加引号"><a href="#为什么“对象”加引号" class="headerlink" title="为什么“对象”加引号"></a>为什么“对象”加引号</h5><p><code>libdispatch</code>库是纯C语言编写的，并不存在类似面向对象语言中的类、对象之类的概念，它的所有对象（如：<code>dispatch_object_s</code>, <code>dispatch_queue_s</code>, <code>dispatch_semaphore_s</code>等）都是定义为struct（<code>dispatch_object_t</code>是union类型）。<br>为了实现类似面向对象中的“继承”效果，GCD使用了若干个<code>DISPATCH_XXX_HEADER</code>宏，将“基类”的内容在了“子类”结构体内存布局的起始处重写了一次，实现了类似“继承”的概念。注意，这里的继承与OOP中的继承不一样，看不到诸如extends/:之类的继承符号的。</p>
<h3 id="二、结构分析"><a href="#二、结构分析" class="headerlink" title="二、结构分析"></a>二、结构分析</h3><p>libdispatch中定义了很多结构体，这里只选取比较常用的几个，不想看过程的同学可以下面的代码分析。<br>先上图，GCD中的继承结构：</p>
<p><img src="/2018/11/29/GCD源码分析（一）——“对象”和数据结构/dispatch_object_structure.png" alt="GCD中的继承结构"></p>
<h4 id="2-1-dispatch-object-t"><a href="#2-1-dispatch-object-t" class="headerlink" title="2.1 dispatch_object_t"></a>2.1 dispatch_object_t</h4><p>从上图可以看到，<code>dispatch_object_t</code>可以看做GCD中所有“类”的“基类”，看下其代码结构</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> _os_object_s *_os_obj;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *_<span class="keyword">do</span>;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *_dc;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *_dq;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_attr_s *_dqa;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_group_s *_dg;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_source_s *_ds;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_mach_s *_dm;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_mach_msg_s *_dmsg;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_source_attr_s *_dsa;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_semaphore_s *_dsema;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_data_s *_ddata;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_io_s *_dchannel;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_operation_s *_doperation;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_disk_s *_ddisk;</span><br><span class="line">&#125; dispatch_object_t DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_object_t</code>被定义为union，熟悉C语言的同学应该知道：union可以表示任意它里面定义的数据类型，union的大小为这些数据类型中最大的数据类型的大小。这里利用了union的特性将<code>dispatch_object_t</code>定义为所有子类：<code>dispatch_xxx_s</code>的基类。</p>
<h4 id="2-2-os-object-s"><a href="#2-2-os-object-s" class="headerlink" title="2.2 _os_object_s"></a>2.2 _os_object_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _os_object_s &#123;</span><br><span class="line">	<span class="keyword">const</span> _os_object_vtable_s *isa;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> os_obj_ref_cnt;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> os_obj_xref_cnt;</span><br><span class="line">&#125; _os_object_s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _os_object_vtable_s &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *_os_obj_objc_isa;</span><br><span class="line">&#125; _os_object_vtable_s;</span><br></pre></td></tr></table></figure>
<ul>
<li>isa指针，应该类似于OC对象中的isa指针，用于判断当前dispatch object的类型，从下面的代码中可以看出一二：</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *_dispatch_object_alloc(<span class="keyword">const</span> <span class="keyword">void</span> *vtable, size_t size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if OS_OBJECT_HAVE_OBJC1</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_object_vtable_s *_vtable = vtable;</span><br><span class="line">	dispatch_object_t dou;</span><br><span class="line">	dou._os_obj = _os_object_alloc_realized(_vtable-&gt;_os_obj_objc_isa, size);</span><br><span class="line">	dou._do-&gt;do_vtable = vtable;</span><br><span class="line">	<span class="keyword">return</span> dou._do;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">	<span class="keyword">return</span> _os_object_alloc_realized(vtable, size);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>os_obj_ref_cnt/os_obj_xref_cnt，从命名方式猜测，应该是引用计数，与GCD的内存管理相关。从代码中的备注发现，二者分别为object在GCD内部和外部使用的引用计数。</li>
</ul>
<h4 id="2-3-dispatch-object-s"><a href="#2-3-dispatch-object-s" class="headerlink" title="2.3 dispatch_object_s"></a>2.3 dispatch_object_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_object_s &#123;</span><br><span class="line">	<span class="keyword">struct</span> _os_object_s _as_os_obj[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/// 继承自_os_object_s结构体的内容，包含了isa指针和引用计数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *isa;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; </span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_object_vtable_s *do_vtable;</span><br><span class="line">	<span class="comment">// object链表中的下一个元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="comment">// 目标队列，指定当前object的执行队列</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *do_targetq;</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt;</span><br><span class="line">	<span class="keyword">void</span> *do_finalizer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述为宏替换后的代码，原始代码中<code>dispatch_object_s</code>只有<code>_DISPATCH_OBJECT_HEADER(object)</code>宏</p>
<h4 id="2-4-dispatch-queue-s"><a href="#2-4-dispatch-queue-s" class="headerlink" title="2.4 dispatch_queue_s"></a>2.4 dispatch_queue_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_s &#123;</span><br><span class="line">	<span class="keyword">struct</span> os_mpsc_queue_s _as_oq[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s _as_do[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">/// 继承自dispatch_object_s结构体的内容</span></span><br><span class="line">	<span class="keyword">struct</span> _os_object_s _as_os_obj[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *isa;</span><br><span class="line">	<span class="keyword">int</span> ref_cnt;</span><br><span class="line">	<span class="keyword">int</span> xref_cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_queue_vtable_s *do_vtable;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *do_targetq;</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt;</span><br><span class="line">	<span class="keyword">void</span> *do_finalizer</span><br><span class="line"></span><br><span class="line">	DISPATCH_UNION_LE(uint64_t <span class="keyword">volatile</span> dq_state, </span><br><span class="line">			dispatch_lock dq_state_lock, </span><br><span class="line">			uint32_t dq_state_bits </span><br><span class="line">	) DISPATCH_ATOMIC64_ALIGN; </span><br><span class="line">	<span class="comment">// queue的首元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *<span class="keyword">volatile</span> dq_items_head; </span><br><span class="line">	<span class="comment">// queue编号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; </span><br><span class="line">	<span class="comment">// queue名称</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *dq_label; </span><br><span class="line">	<span class="comment">// queue的尾元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s *<span class="keyword">volatile</span> dq_items_tail; </span><br><span class="line">	<span class="comment">// queue的优先级</span></span><br><span class="line">	dispatch_priority_t dq_priority; </span><br><span class="line">	<span class="comment">// queue的reference count</span></span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> dq_sref_cnt;</span><br><span class="line">	</span><br><span class="line">	uint32_t dq_side_suspend_cnt;</span><br><span class="line">	dispatch_unfair_lock_s dq_sidelock;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> dq_specific_q; </span><br><span class="line">		<span class="keyword">struct</span> dispatch_source_refs_s *ds_refs;</span><br><span class="line">		<span class="keyword">struct</span> dispatch_timer_source_refs_s *ds_timer_refs;</span><br><span class="line">		<span class="keyword">struct</span> dispatch_mach_recv_refs_s *dm_recv_refs;</span><br><span class="line">	&#125;;</span><br><span class="line">	DISPATCH_UNION_LE(uint32_t <span class="keyword">volatile</span> dq_atomic_flags,</span><br><span class="line">		<span class="keyword">const</span> uint16_t dq_width,  <span class="comment">// 应该是队列的并发数，当为1时表示串行队列</span></span><br><span class="line">		<span class="keyword">const</span> uint16_t __dq_opaque</span><br><span class="line">	);</span><br><span class="line">	DISPATCH_INTROSPECTION_QUEUE_HEADER</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; <span class="comment">// for static queues only</span></span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-dispatch-continuation-s"><a href="#2-5-dispatch-continuation-s" class="headerlink" title="2.5 dispatch_continuation_s"></a>2.5 dispatch_continuation_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dispatch_continuation_s &#123;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s _as_do[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 任务的函数地址</span></span><br><span class="line">	dispatch_function_t dc_func;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	   <span class="comment">// 优先级</span></span><br><span class="line">		pthread_priority_t dc_priority;</span><br><span class="line">		<span class="keyword">int</span> dc_cache_cnt;</span><br><span class="line">		uintptr_t dc_pad;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">struct</span> voucher_s *dc_voucher;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">void</span> *do_vtable;</span><br><span class="line">		uintptr_t dc_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 任务链表中的下一个元素</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="comment">// 上下文</span></span><br><span class="line">	<span class="keyword">void</span> *dc_ctxt;</span><br><span class="line">	<span class="keyword">void</span> *dc_data;</span><br><span class="line">	<span class="keyword">void</span> *dc_other</span><br><span class="line">&#125; *dispatch_continuation_t;</span><br></pre></td></tr></table></figure>
<p>从结构体中的<code>dispatch_function_t</code>类型，可以猜测<code>dispatch_continuation_s</code>与GCD的任务有关，我们向GCD中提交的任务，无论是Block或者函数形式，最终都转化成<code>dispatch_continuation_s</code></p>
<h4 id="2-6-dispatch-group-s"><a href="#2-6-dispatch-group-s" class="headerlink" title="2.6 dispatch_group_s"></a>2.6 dispatch_group_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_group_s &#123;</span><br><span class="line">   <span class="comment">/// 继承自dispatch_object_s的内容</span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_object_s _as_do[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">struct</span> _os_object_s _as_os_obj[<span class="number">0</span>]; </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *_objc_isa;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> do_ref_cnt;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> do_xref_cnt;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> dispatch_group_vtable_s *do_vtable;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> dispatch_group_s *<span class="keyword">volatile</span> do_next;</span><br><span class="line">	<span class="comment">// group执行的目标队列 </span></span><br><span class="line">	<span class="keyword">struct</span> dispatch_queue_s *do_targetq; </span><br><span class="line">	<span class="keyword">void</span> *do_ctxt; </span><br><span class="line">	<span class="keyword">void</span> *do_finalizer;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标识符或者当前group中执行的任务数，0：当前group未在执行，非0：当前group正在执行</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">volatile</span> dg_value; </span><br><span class="line">	_dispatch_sema4_t dg_sema;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">volatile</span> dg_waiters;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *<span class="keyword">volatile</span> dg_notify_head;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_continuation_s *<span class="keyword">volatile</span> dg_notify_tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与其他结构体内容大同小异，需要关注的是这两个参数:</p>
<ul>
<li><code>dg_notify_head</code></li>
<li><code>dg_notify_tail</code>。</li>
</ul>
<p>我们知道<code>dispatch_group_notify</code>可以用来做线程同步，那么猜测猜测这两个变量与实现<code>dispatch_group_notify</code>功能相关，当group中内容执行完毕后，通知<code>dg_notify</code>链表中的任务，<code>_head</code>和<code>_tail</code>用于定位这些需要接收通知的任务的位置。</p>
<p>在semaphore.c中找到相关源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_continuation_t dsn)</span><br><span class="line">&#123;</span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_update_tail(dg, dg_notify, dsn, do_next)) &#123;</span><br><span class="line">	   <span class="comment">// retain group</span></span><br><span class="line">		_dispatch_retain(dg);</span><br><span class="line">		<span class="comment">// 调用atomic_store_explicit函数将当前任务(dsn)替换为dg-&gt;dg_notify_head，</span></span><br><span class="line">		<span class="comment">// 该操作为原子操作</span></span><br><span class="line">		atomic_store_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_notify_head)) _Atomic *)(&amp;(dg)-&gt;dg_notify_head)), dsn, memory_order_ordered)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// seq_cst with atomic store to notify_head &lt;rdar://problem/11750916&gt;</span></span><br><span class="line">		<span class="comment">// 判断当前group中是否有正在执行的任务，如果没有，调用_dispatch_group_wake函数唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_load_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_value)) _Atomic *)(&amp;(dg)-&gt;dg_value)), memory_order_ordered)) == <span class="number">0</span>) &#123;</span><br><span class="line">		  <span class="comment">// 唤醒group</span></span><br><span class="line">			_dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">_dispatch_group_wake(dispatch_group_t dg, <span class="keyword">bool</span> needs_release)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t next, head, tail = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">long</span> rval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cannot use os_mpsc_capture_snapshot() because we can have concurrent</span></span><br><span class="line">	<span class="comment">// _dispatch_group_wake() calls</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将head设置成dg-&gt;dg_notify_head，然后清空dg-&gt;dg_notify_head的值</span></span><br><span class="line">	head = atomic_exchange_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_notify_head)) _Atomic *)(&amp;(dg)-&gt;dg_notify_head)), <span class="literal">NULL</span>, memory_order_relaxed);</span><br><span class="line">	<span class="keyword">if</span> (head) &#123;</span><br><span class="line">		<span class="comment">// snapshot before anything is notified/woken &lt;rdar://problem/8554546&gt;</span></span><br><span class="line">		<span class="comment">// 将tail设置成dg-&gt;dg_notify_tail，然后清空dg-&gt;dg_notify_tail的值</span></span><br><span class="line">		tail = atomic_exchange_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_notify_tail)) _Atomic *)(&amp;(dg)-&gt;dg_notify_tail)), <span class="literal">NULL</span>, memory_order_release);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rval = (<span class="keyword">long</span>)atomic_exchange_explicit(((<span class="keyword">typeof</span>(*(&amp;(dg)-&gt;dg_waiters)) _Atomic *)(&amp;(dg)-&gt;dg_waiters)), <span class="number">0</span>, memory_order_relaxed);</span><br><span class="line">	<span class="keyword">if</span> (rval) &#123;</span><br><span class="line">		<span class="comment">// wake group waiters</span></span><br><span class="line">		_dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">		<span class="comment">// 根据waiters的数量创建相应数量的信号量</span></span><br><span class="line">		_dispatch_sema4_signal(&amp;dg-&gt;dg_sema, rval);</span><br><span class="line">	&#125;</span><br><span class="line">	uint16_t refs = needs_release ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	<span class="keyword">if</span> (head) &#123;</span><br><span class="line">		<span class="comment">// async group notify blocks</span></span><br><span class="line">		<span class="comment">// 异步通知每一个任务</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			next = os_mpsc_pop_snapshot_head(head, tail, do_next);</span><br><span class="line">			<span class="built_in">dispatch_queue_t</span> dsn_queue = (<span class="built_in">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">			_dispatch_continuation_async(dsn_queue, head);</span><br><span class="line">			_dispatch_release(dsn_queue);</span><br><span class="line">		&#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">		refs++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (refs) _dispatch_release_n(dg, refs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-dispatch-source-s"><a href="#2-7-dispatch-source-s" class="headerlink" title="2.7 dispatch_source_s"></a>2.7 dispatch_source_s</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_source_s &#123;</span><br><span class="line">   <span class="keyword">struct</span> dispatch_queue_s _as_dq[<span class="number">0</span>];</span><br><span class="line">	_DISPATCH_QUEUE_HEADER(source) </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> </span><br><span class="line">		ds_is_installed:<span class="number">1</span>, </span><br><span class="line">		dm_needs_mgr:<span class="number">1</span>, </span><br><span class="line">		dm_connect_handler_called:<span class="number">1</span>, </span><br><span class="line">		dm_uninstalled:<span class="number">1</span>, </span><br><span class="line">		dm_cancel_handler_called:<span class="number">1</span>, </span><br><span class="line">		dm_is_xpc:<span class="number">1</span></span><br><span class="line">	uint64_t ds_data DISPATCH_ATOMIC64_ALIGN;</span><br><span class="line">	uint64_t ds_pending_data DISPATCH_ATOMIC64_ALIGN;</span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_source_s</code>继承自<code>dispatch_queue_s</code>，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。GCD提供了六大类调度源：</p>
<blockquote>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
</blockquote>
<p>可以监听12个类型的事件（可以在source.h文件中查看）:</p>
<ul>
<li>DISPATCH_SOURCE_TYPE_DATA_ADD，自定义事件，可以通过dispatch_source_get_data函数获取事件变量数据，在我们自定义的方法中可以调用dispatch_source_merge_data函数向调度源设置数据</li>
<li>DISPATCH_SOURCE_TYPE_DATA_OR，同上</li>
<li>DISPATCH_SOURCE_TYPE_DATA_REPLACE，同上</li>
<li>DISPATCH_SOURCE_TYPE_MACH_SEND，Mach内核端口发送事件</li>
<li>DISPATCH_SOURCE_TYPE_MACH_RECV，Mach内核端口监听事件</li>
<li>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE，内存压力事件，分为三个等级：NORMAL、WARN、CRITICAL</li>
<li>DISPATCH_SOURCE_TYPE_PROC，进程相关事件，如进程退出、创建子线程、收到UNIX信号等事件</li>
<li>DISPATCH_SOURCE_TYPE_READ，IO读操作事件，如文件或socket的读操作</li>
<li>DISPATCH_SOURCE_TYPE_WRITE，IO写操作事件</li>
<li>DISPATCH_SOURCE_TYPE_SIGNAL，进程接收Unix内核信号事件</li>
<li>DISPATCH_SOURCE_TYPE_TIMER，定时器事件</li>
<li>DISPATCH_SOURCE_TYPE_VNODE，文件状态改变事件，如文件移动、删除、重命名等</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/" itemprop="url">OC中Block内存结构以及copy/持有外部变量等操作的实现原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T16:41:54+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/16/OC中Block内存结构以及copy-持有外部变量等操作的实现原理分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近对App中的埋点代码进行了改造（随着项目的增大，散落在系统各处的埋点代码实在不好管理），利用AOP的方式将散布在各个页面中的埋点代码统一起来组成一个独立的模块，从而减少埋点行为对业务代码的侵入。</p>
<p>熟悉iOS AOP编程的同学肯定听过<a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a>这个框架，我们也使用这个框架实现Method Swizzle，通过Method Swizzle给指定的方法添加side-effect，在side-effect中做相应的埋点上报操作。</p>
<p>在学习Aspects源码的过程中，对Runtime以及OC的消息转发机制有了一个深入的了解，写几篇文章记录一下，文章中会穿插一些对于Aspect源码的分析内容，如有错误的地方，欢迎大家斧正。</p>
<h3 id="二、Block-Memory-Layout"><a href="#二、Block-Memory-Layout" class="headerlink" title="二、Block Memory Layout"></a>二、Block Memory Layout</h3><p>Everything hides in the source code: <a href="https://opensource.apple.com/source/libclosure/libclosure-67/" target="_blank" rel="noopener">libclosure-67</a></p>
<p>block的本质可以看做一个函数，这点从它的定义可以看出来（Block_private.h）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">    int32_t reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">    <span class="comment">// 捕获的外部变量，block将外部变量复制到结构体中，因此block内部可以访问到其外部的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_1 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_2 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_3 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>逐条分析： </p>
<ul>
<li><code>void *isa</code>: oc中的所有对象都有该指针，指向其所属的类。oc对象接收到消息后，根据isa指针找到其所属的类，然后获取存储在类中的property_list、method_list等信息，然后进行下一步的操作；</li>
<li><code>volatile int32_t flags</code>: 标识位，block内部操作时会用到，比如copy、dispose等，其中包含了block的reference count、是否heap block等信息；</li>
<li><code>int32_t reserved</code>: 保留变量</li>
<li><code>void (*invoke)(void *, ...)</code>: 函数指针，指向block的实现函数地址；</li>
<li><code>struct Block_descriptor_1 *descriptor</code>: 附加描述信息，存储了一些如block大小、copy/dispose函数指针、签名（用于构造方法签名）等信息。</li>
</ul>
<p><strong>Aspects源码截取：构造blockMethodSignature</strong></p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化desc指针，指向block的descriptor结构体起始地址</span></span><br><span class="line"><span class="keyword">void</span> *desc = layout-&gt;descriptor;</span><br><span class="line"><span class="comment">// 2. 移动指针，跳过reserved、size变量</span></span><br><span class="line">desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 3. 判断是否有copy/dispose信息，如果有，移动desc指针，跳过copy/dispose指针变量</span></span><br><span class="line"><span class="keyword">if</span> (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">	desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 移动后的指针应该指向block的signature信息，判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't has a type signature."</span>, block];</span><br><span class="line">    AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 指针不为空，取出signature指针，构造methodSignature</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br></pre></td></tr></table></figure>
<p>在Block_private.h中还能看到如下信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block_private.h</span></span><br><span class="line"><span class="comment">// the raw data space for runtime classes for blocks</span></span><br><span class="line"><span class="comment">// class+meta used for stack, malloc, and collectable based blocks</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteMallocBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteAutoBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteFinalizingBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteWeakBlockVariable[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"><span class="comment">// declared in Block.h</span></span><br><span class="line"><span class="comment">// BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];</span></span><br><span class="line"><span class="comment">// BLOCK_EXPORT void * _NSConcreteStackBlock[32];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block.h</span></span><br><span class="line"><span class="comment">// Used by the compiler. Do not use these variables yourself.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteGlobalBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteStackBlock[<span class="number">32</span>]</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>
<p>从其命名方式：Global/Stack(栈)/Malloc(堆)可以推测出Block的类型：NSGlobalBlock（全局Block）、NSStackBlock（栈区Block）、NSMallocBlock（堆区Block）。下面结合代码分别分析一下这三种block。</p>
<h4 id="2-1-NSGlobalBlock"><a href="#2-1-NSGlobalBlock" class="headerlink" title="2.1 NSGlobalBlock"></a>2.1 NSGlobalBlock</h4><p>我们知道，程序中的全局变量存储在内存中的数据区（.data区），这块内存中的内容在编译期就已经完全确定了。因此，这种Block无法捕捉任何变量，也无需任何运行时状态来参与运行。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^TestBlock)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *str = <span class="string">@"static test str"</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    TestBlock block = ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"innner block"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block address:%@"</span>, block);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"static string address:%p"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">innner block</span><br><span class="line">block address:&lt;__NSGlobalBlock__: <span class="number">0x10428a080</span>&gt;</span><br><span class="line"><span class="keyword">static</span> string address:<span class="number">0x104290908</span></span><br></pre></td></tr></table></figure>
<p>可以看出，NSGlobalBlock的存储区域与静态变量的地址相近，二者都存储于全局数据区。</p>
<h4 id="2-2-NSStackBlock和NSMallocBlock"><a href="#2-2-NSStackBlock和NSMallocBlock" class="headerlink" title="2.2 NSStackBlock和NSMallocBlock"></a>2.2 NSStackBlock和NSMallocBlock</h4><ul>
<li>MRC下，无论是对于作为函数临时变量的block和对象属性的block，都默认存储在栈区，其生命周期随着变量作用域结束而结束，如果想要保留block，可以显示调用copy方法将block拷贝到堆中。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    TestBlock stackBlock = ^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line">    stackBlock();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"stack block address: %@"</span>, stackBlock);</span><br><span class="line">    </span><br><span class="line">    TestBlock heapBlock = [^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line">    heapBlock();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"heap block address: %@"</span>, heapBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">stack block address: &lt;__NSStackBlock__: <span class="number">0x7ffeeeeeb970</span>&gt;</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">heap block address: &lt;__NSMallocBlock__: <span class="number">0x6000017bbfc0</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>ARC下，由于编译期会隐式地为非全局block添加copy操作，因此所有的非全局block都存储于堆区。这个copy操作属于深拷贝，将block拷贝到堆中，这个拷贝的block对象强引用它捕获的变量，因此ARC下要注意block的隐式copy引起的retain cycle问题。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = %ld"</span>, (<span class="keyword">long</span>)i);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"heap block address: %@"</span>, block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">heap block address: &lt;__NSMallocBlock__: <span class="number">0x60000221eb50</span>&gt;</span><br></pre></td></tr></table></figure>
<p>因此，MRC下block有三种：NSGlobalBlock、NSStackBlock、NSMallocBlock，<br>而ARC下由于编译器隐式添加copy操作，只有两种block：NSGlobalBlock、NSMallocBlock。</p>
<h3 id="三、Block持有外部变量分析"><a href="#三、Block持有外部变量分析" class="headerlink" title="三、Block持有外部变量分析"></a>三、Block持有外部变量分析</h3><p>上一节中说过block结构体中有专门存放捕获的变量的区域，那么block是如何捕获到外部变量的呢？分几种情况分析。</p>
<h4 id="3-1-block持有非-block修饰的基本类型变量"><a href="#3-1-block持有非-block修饰的基本类型变量" class="headerlink" title="3.1 block持有非__block修饰的基本类型变量"></a>3.1 block持有非__block修饰的基本类型变量</h4><p>先看代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, j address: %p"</span>, &amp;j);</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, j address: %p"</span>, &amp;j);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, j address: %p"</span>, &amp;j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">before block, j address: <span class="number">0x7ffee08849bc</span></span><br><span class="line">inner block, j address: <span class="number">0x600000dac080</span></span><br><span class="line">after block, j address: <span class="number">0x7ffee08849bc</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看出，打印变量j的地址，before block和after block的地址相同，且二者与block内部的地址不同。（ARC和MRC下，输出的结果一样）</p>
<h5 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h5><p>使用<code>clang -rewrite-objc</code>命令重写.m文件，只选取关键代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, <span class="keyword">int</span> _j, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> j = __cself-&gt;j; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_1, &amp;j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_0, &amp;j);</span><br><span class="line"></span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, j));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_3e4a38_mi_2, &amp;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>__TestObject__testBlock_block_impl_0</code>是testBlock的实现，包含了一个isa指针（本例中它指向NSConcreteStackBlock, 说明这个block是分配在栈上的）、一个impl函数指针（本例中它指向<code>__TestObject__testBlock_block_func_0</code>）、一个Desc结构体指针，从block的实现来看，捕获到的外部变量会追加到Desc指针后面，使得<code>__TestObject__testBlock_block_impl_0</code>结构体变大。</p>
<p>从<code>__TestObject__testBlock_block_func_0</code>中可以看到：<code>int j = __cself-&gt;j; // bound by copy</code>这样一句代码，block将捕获的外部变量复制一份到其内部，这也说明了为什么block内部打印的变量j的地址与外部不一致。</p>
<h4 id="3-2-block持有-block修饰的基本类型变量"><a href="#3-2-block持有-block修饰的基本类型变量" class="headerlink" title="3.2 block持有__block修饰的基本类型变量"></a>3.2 block持有__block修饰的基本类型变量</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, j address: %p"</span>, &amp;j);</span><br><span class="line">    </span><br><span class="line">    TestBlock block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, j address: %p"</span>, &amp;j);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, j address: %p"</span>, &amp;j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line">before block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line">inner block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line">after block, j address: <span class="number">0x7ffeec8969a8</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line">before block, j address: <span class="number">0x7ffeeea309a8</span></span><br><span class="line">inner block, j address: <span class="number">0x600000c54558</span></span><br><span class="line">after block, j address: <span class="number">0x600000c54558</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看到，MRC下，block前后和block内部打印的变量j的地址都相同，而且都是存在于栈中；ARC下，由于block的隐式copy操作，block内部和block执行后打印变量j的地址是在堆中，而block之前的地址是在栈中。</p>
<h6 id="分析原因-1"><a href="#分析原因-1" class="headerlink" title="分析原因"></a>分析原因</h6><p>使用clang重写oc代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="meta">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_j_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_j_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_j_0 *j; <span class="comment">// by ref</span></span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, __Block_byref_j_0 *_j, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_j_0 *j = __cself-&gt;j; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_1, &amp;(j-&gt;__forwarding-&gt;j));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;j, (<span class="keyword">void</span>*)src-&gt;j, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;j, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_j_0 j = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_j_0 *)&amp;j, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_j_0), <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_0, &amp;(j.__forwarding-&gt;j));</span><br><span class="line"></span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, (__Block_byref_j_0 *)&amp;j, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_f67065_mi_2, &amp;(j.__forwarding-&gt;j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，block内部除了<code>isa</code>指针、<code>impl</code>函数指针、<code>Desc</code>指针外，增加了一个<code>__Block_byref_j_0</code>类型的结构体指针，block捕获的外部变量由该结构体管理，block通过持有该结构体指针实现了对外部变量修改的目的。而且<code>__TestObject__testBlock_block_desc_0</code>中新增了copy和dispose两个函数指针，用于实现对<code>__Block_byref_j_0</code>结构体的内存管理。</p>
<p><code>__Block_byref_j_0</code>结构体中包含了：</p>
<ul>
<li>isa指针: 指向该__block变量的类型，本例中是基本数据类型，因此，isa指针为<code>(void *)0</code>；</li>
<li>forwarding指针: 指向该结构体，用于取值；</li>
<li>flags: 标识位，对于基本数据类型该值为0，对于对象类型该值为3554432；</li>
<li>size: 该结构体的大小；</li>
<li>j: 不同的捕获变量，该值命名类型不同，本例中用于储存捕获的整型变量的值；</li>
</ul>
<p>在block内部和block前后读写变量j的值，都是读取或修改<code>j-&gt;__forwarding-&gt;j</code>或者<code>j.__forwarding-&gt;j</code>的值，由于block内外获取到的<code>__forwarding</code>指针指向同一结构体地址，因此使得block内部修改变量影响到了block外部。</p>
<h4 id="3-3-block持有-block修饰的对象"><a href="#3-3-block持有-block修饰的对象" class="headerlink" title="3.3 block持有__block修饰的对象"></a>3.3 block持有__block修饰的对象</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line">    __block ObjectA *blockObj = [[ObjectA alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, blockObj address: %p, obj pointer address: %p"</span>, blockObj,  &amp;blockObj);</span><br><span class="line">    TestBlock block = ^ &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, blockObj address: %p, obj pointer address: %p"</span>, blockObj, &amp;blockObj);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, blockObj address: %p, obj pointer address: %p"</span>, blockObj, &amp;blockObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line">before block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line">inner block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line">after block, blockObj address: <span class="number">0x60000356ae50</span>, obj pointer address: <span class="number">0x7ffee823b9a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line">before block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x7ffee4d8e9a8</span></span><br><span class="line">inner block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x600002431318</span></span><br><span class="line">after block, blockObj address: <span class="number">0x6000028667c0</span>, obj pointer address: <span class="number">0x600002431318</span></span><br></pre></td></tr></table></figure>
<p>可以看到，无论是MRC或者ARC下，blockObj对象的地址都不变，在堆中；MRC下，blockObj对象的指针地址不变，在栈中；而ARC下，blockObj对象的指针地址在copy之后发生了变化，指针从栈中拷贝到了堆中。</p>
<p><strong>这也说明了block对其持有的对象的copy操作只是浅拷贝，拷贝的是指针，而指针指向的对象始终存在于堆中的某个区域</strong></p>
<h5 id="分析原因-2"><a href="#分析原因-2" class="headerlink" title="分析原因"></a>分析原因</h5><p>使用clang重写</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_blockObj_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockObj_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> ObjectA *blockObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_blockObj_0 *blockObj; <span class="comment">// by ref</span></span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, __Block_byref_blockObj_0 *_blockObj, <span class="keyword">int</span> flags=<span class="number">0</span>) : blockObj(_blockObj-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_blockObj_0 *blockObj = __cself-&gt;blockObj; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_1, &amp;(blockObj-&gt;__forwarding-&gt;blockObj));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;blockObj, (<span class="keyword">void</span>*)src-&gt;blockObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;blockObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_blockObj_0 blockObj = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_blockObj_0 *)&amp;blockObj, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_blockObj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((ObjectA *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((ObjectA *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"ObjectA"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_0, &amp;(blockObj.__forwarding-&gt;blockObj));</span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, (__Block_byref_blockObj_0 *)&amp;blockObj, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_ba14cb_mi_2, &amp;(blockObj.__forwarding-&gt;blockObj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上例的结构基本相同，不同的是<code>__Block_byref_blockObj_0</code>结构体中增加了copy、dispose两个函数指针用于实现block持有对象的内存管理，<code>__Block_byref_blockObj_0</code>持有的是捕获对象的指针。</p>
<h4 id="3-4-block持有类的属性"><a href="#3-4-block持有类的属性" class="headerlink" title="3.4 block持有类的属性"></a>3.4 block持有类的属性</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBlock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, str value: %@"</span>, _str);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"before block, str address: %p"</span>, &amp;_str);</span><br><span class="line">    TestBlock block = ^ &#123;</span><br><span class="line">        _str = <span class="string">@"block str"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, str value: %@"</span>, _str);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"inner block, str address: %p"</span>, &amp;_str);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, str value: %@"</span>, _str);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"after block, str address: %p"</span>, &amp;_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// MRC和ARC</span></span><br><span class="line">before block, str value: init string.</span><br><span class="line">before block, str address: <span class="number">0x6000004c23b8</span></span><br><span class="line">inner block, str value: block str</span><br><span class="line">inner block, str address: <span class="number">0x6000004c23b8</span></span><br><span class="line">after block, str value: block str</span><br><span class="line">after block, str address: <span class="number">0x6000004c23b8</span></span><br></pre></td></tr></table></figure>
<p>MRC和ARC下，block内外打印的对象地址相同，且不需要<code>__block</code>修饰，block也能捕获并修改类的属性。</p>
<h5 id="分析原因-3"><a href="#分析原因-3" class="headerlink" title="分析原因"></a>分析原因</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0* Desc;</span><br><span class="line">  TestObject *<span class="keyword">self</span>;</span><br><span class="line">  __TestObject__testBlock_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 *desc, TestObject *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_func_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0 *__cself) &#123;</span><br><span class="line">  TestObject *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)) = (<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_3;</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_4, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_5, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestObject__testBlock_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*);</span><br><span class="line">&#125; __TestObject__testBlock_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0), __TestObject__testBlock_block_copy_0, __TestObject__testBlock_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObject_testBlock(TestObject * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_1, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_2, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_6, (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_b5_rsv7dqn103b02trb8h2l2dx00000gn_T_TestObject_4b2b3a_mi_7, &amp;(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，构建block结构体时，其内部持有的是该类的实例对象：<code>TestObject *self</code>。而在创建block时，传入的是类的当前的实例对象self：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestBlock block = ((<span class="keyword">void</span> (*)())&amp;__TestObject__testBlock_block_impl_0((<span class="keyword">void</span> *)__TestObject__testBlock_block_func_0, &amp;__TestObject__testBlock_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>
<p>因此，block内部持有的实际上是self，在读取和修改类的属性时，使用的实际上是</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_TestObject$_str))</span><br></pre></td></tr></table></figure>
<p>所以，无需<code>__block</code>修饰，block也能修改类的属性，而且无论在MRC还是ARC下，打印的属性地址都是堆中的某个区域（基本类型的属性不同，是在栈中）。</p>
<h3 id="四、Block-copy过程以及导致retain-cycle的原因分析"><a href="#四、Block-copy过程以及导致retain-cycle的原因分析" class="headerlink" title="四、Block copy过程以及导致retain cycle的原因分析"></a>四、Block copy过程以及导致retain cycle的原因分析</h3><p>ARC下，为了延长分配在栈中block的生命周期，编译期会对非全局block默认加copy操作，将其copy到堆中。对于基本数据类型，copy一份到堆中，对于对象类型变量，copy其指针到堆中。而我们常说的block的循环引用就是这个copy操作导致的，那么为什么block的copy操作会导致某些情况下的循环引用呢？下面通过源码分析一下。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libclosure-67/Block_private.h</span></span><br><span class="line"><span class="comment">// Values for Block_layout-&gt;flags to describe block objects</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libclosure-67/runtime.c</span></span><br><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_layout *aBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            int32_t old_value = aBlock-&gt;flags;</span><br><span class="line">            <span class="keyword">if</span> ((old_value &amp; BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OSAtomicCompareAndSwapInt(old_value, old_value+<span class="number">2</span>, &amp;aBlock-&gt;flags)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="keyword">struct</span> Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);</span><br><span class="line">        <span class="keyword">if</span> (!desc) <span class="keyword">return</span>;</span><br><span class="line">        (*desc-&gt;<span class="keyword">copy</span>)(result, aBlock); <span class="comment">// do fixup</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是在Block_private.h头文件中的一些枚举值，包含了用于描述block对象的一些flags；<br>核心方法是<code>_Block_copy</code>函数，这个函数的流程如下：</p>
<ol>
<li>声明一个<code>Block_layout</code>结构体类型的指针aBlock;</li>
<li>检查传入的参数arg是否为空，为空则return NULL；</li>
<li>将aBlock指针指向arg；</li>
<li>判断block的flags是否包含BLOCK_NEEDS_FREE，如果包含，说明这是一个堆block，将其引用计数+1；</li>
<li>判断是否global block，如果是，直接返回相同的block；</li>
<li>如果是一个栈block，执行以下操作：根据传入的block中的size信息创建一块同样大小的内存空间，并使用result指针指向其起始地址；判断result是否为空，如果为空返回NULL；将aBlock按位拷贝（memmove）到result指向的内存空间中；更新块标识，初始化引用计数为0；设置拷贝的block引用计数为1；如果有辅助copy函数，调用辅助函数；设置result的isa指针指向<code>_NSConcreteMallocBlock</code>，即说明这是一个堆block。</li>
</ol>
<h4 id="block辅助copy-dispose函数"><a href="#block辅助copy-dispose函数" class="headerlink" title="block辅助copy/dispose函数"></a>block辅助copy/dispose函数</h4><p>在上一节的3.2、3.3、3.4例子中可以看到，编译期自动生成了copy、dispose函数并添加到<code>Block_layout</code>中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_copy_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*dst, <span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObject__testBlock_block_dispose_0(<span class="keyword">struct</span> __TestObject__testBlock_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点关注copy函数，<code>__TestObject__testBlock_block_copy_0</code>函数调用了<code>_Block_object_assign</code>函数进行辅助的拷贝操作（主要是对block持有的变量的copy、内存管理等）。<br>源码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block_private.h</span></span><br><span class="line"><span class="comment">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// see function implementation for a more complete description of these fields and combinations</span></span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  <span class="comment">// id, NSObject, __attribute__((NSObject)), block, ...</span></span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  <span class="comment">// a block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>,  <span class="comment">// the on stack structure holding the __block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>,  <span class="comment">// declared __weak, only used in byref copy helpers</span></span><br><span class="line">    BLOCK_BYREF_CALLER      = <span class="number">128</span>, <span class="comment">// called from __block (byref) copy/dispose support routines.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime.c</span></span><br><span class="line"><span class="comment">// When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point</span></span><br><span class="line"><span class="comment">// to do the assignment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destArg, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **dest = (<span class="keyword">const</span> <span class="keyword">void</span> **)destArg;</span><br><span class="line">    <span class="keyword">switch</span> (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        id object = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        _Block_retain_object(object);</span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        void (^object)(void) = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the onstack __block container to the heap</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block ... x;</span></span><br><span class="line"><span class="comment">         __weak __block ... x;</span></span><br><span class="line"><span class="comment">         [^&#123; x; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_byref_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this is MRC unretained __block only. </span></span><br><span class="line"><span class="comment">         // ARC retained __block is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block id object;</span></span><br><span class="line"><span class="comment">         __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __weak __block id object;</span></span><br><span class="line"><span class="comment">         __weak __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程分析：</p>
<ol>
<li>首先是block field有关的一些枚举值，列举了要copy的变量的类型：object/block/byref/caller等；</li>
<li>判断block field，如果是object类型，调用<code>_Block_retain_object</code>函数对object进行一次retain操作；</li>
<li>如果是<code>_Block_byref_copy</code>类型，调用<code>_Block_byref_copy</code>函数进行<code>__Block_byref_</code>结构体的copy操作</li>
<li>其他case，比如<code>__weak __block</code>、<code>__weak __block id</code>或者<code>__weak __block void (^object)(void)</code>类型，不进行copy和retain操作，只是进行指针赋值。</li>
</ol>
<p>看到这里，应该就明白block中循环引用是怎么造成的了吧。<br>结合第三节的<strong>例子3.4</strong>和上述<strong>流程2</strong>可以看出，block持有实例对象的属性（无论是self.xxx或_xxx）时，实际上持有的是当前的实例对象self，而这种情况下在进行copy操作时，调用block的辅助copy函数时，会对self进行一次retain操作，使self的引用计数+1，如果此时实例对象再强引用block的话，就会出现retain cycle，导致对象和block相互引用而无法释放。</p>
<h3 id="五、总结及参考"><a href="#五、总结及参考" class="headerlink" title="五、总结及参考"></a>五、总结及参考</h3><p>通过上述分析，对于block的内存结构和MRC、ARC下block的行为以及block如何持有外部变量、如何copy等有了一个大致的了解。如果对于block的dispose等操作感兴趣的同学，可以去下载官方完整源码阅读：</p>
<p><a href="https://opensource.apple.com/source/libclosure/libclosure-67/" target="_blank" rel="noopener">libclosure-67</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/09/21/Swift内存模型与指针的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/Swift内存模型与指针的使用/" itemprop="url">Swift内存模型与指针的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T16:02:20+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/21/Swift内存模型与指针的使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/09/21/Swift内存模型与指针的使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>我们在编写Objective-C和C代码时经常会用到指针，切换到Swift语言中来，虽然其可以无缝使用C语言指针，但是在语法上与OC和C还是有很大区别的。</p>
<p>Swift本身是内存安全的，只要确保所有变量在使用前都被正确地初始化，我们不必担心内存问题，因此，Apple官方不建议开发者直接操作内存，但是Swift还是为开发者提供了使用指针直接操作内存的方法，Swift中所有的指针类型都带有“Unsafe”前缀，就是为了提示开发者使用指针的行为是危险且不安全的，要慎重。</p>
<p>先来看看Swift中的指针类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">C</th>
<th style="text-align:center">Swift</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">const Type *</td>
<td style="text-align:center">UnsafePointer<type></type></td>
<td style="text-align:center">指针可变，指针指向的内存值不可变</td>
</tr>
<tr>
<td style="text-align:center">Type *</td>
<td style="text-align:center">UnsafeMutablePointer<type></type></td>
<td style="text-align:center">指针可变，指针指向的内存值可变</td>
</tr>
<tr>
<td style="text-align:center">const void *</td>
<td style="text-align:center">UnsafeRawPointer</td>
<td style="text-align:center">指针可变，指针指向的内存区域类型不确定，且内存值不可变</td>
</tr>
<tr>
<td style="text-align:center">void *</td>
<td style="text-align:center">UnsafeMutableRawPointer</td>
<td style="text-align:center">指针可变，指针指向的内存区域类型不确定，且内存值可变</td>
</tr>
<tr>
<td style="text-align:center">StructType *</td>
<td style="text-align:center">OpaquePointer</td>
<td style="text-align:center">C中的一些自定义类型，Swift中无相应的类型，如：sqlite3_stmt结构体</td>
</tr>
<tr>
<td style="text-align:center">ClassType <em> const </em></td>
<td style="text-align:center">UnsafePointer<classtype></classtype></td>
<td style="text-align:center">指向指针的指针，指针不可变，指针指向的类可变</td>
</tr>
<tr>
<td style="text-align:center">ClassType <em> __strong </em></td>
<td style="text-align:center">UnsafeMutablePointer<classtype></classtype></td>
<td style="text-align:center">指向指针的指针，指针可变，指针指向的类可变</td>
</tr>
<tr>
<td style="text-align:center">int8_t a[]</td>
<td style="text-align:center">var x:[Int8] -&gt; UnsafeBufferPointer</td>
<td style="text-align:center">数组指针，指向数组一个元素的地址</td>
</tr>
</tbody>
</table>
<h4 id="二、MemoryLayout"><a href="#二、MemoryLayout" class="headerlink" title="二、MemoryLayout"></a>二、MemoryLayout</h4><p>提到指针就不得不说一下内存模型。Swift的内存分配与C/C++/Objective-C/Java等类似：</p>
<ul>
<li>Stack: 存储值类型变量（如int、float、struct等），函数调用栈，存储引用类型的临时变量指针</li>
<li>Heap: 存储引用类型的实例，比如类的对象</li>
</ul>
<blockquote>
<p>内存对齐：出于对寻址速度、原子操作以及简化CPU和Memory之间接口设计等方面的考虑，现代计算机系统对值类型的合法地址做了一些限制，要求某种数据类型的对象的地址必须是K的整数倍（K通常是2、4、8）。</p>
<p>因此对齐的原则是: <strong>任何K字节的基本对象的地址必须是K的整数倍</strong>。</p>
<p>Tip: 在声明类或者结构体的成员变量时，可以将占用空间大的变量写在前面，将占用空间小的变量写在后面，以达到减少内存占用的目的。</p>
</blockquote>
<p>MemoryLayout是Swift中用来计算数据类型占用内存空间大小的工具，它有三个比较常用的Int类型的属性：</p>
<ul>
<li>size/size(ofValue: T):  T类型的实例占用连续内存字节的大小</li>
<li>alignment/alignment(ofValue: T):  数据类型T的内存对齐原则，在64bit系统下，最大的内存对齐原则是8Byte</li>
<li>stride/stride(ofValue: T): 由于内存对齐的原因，T类型的实例实际消耗的内存空间stride可能比其size大，浪费的内存空间即：stride - size</li>
</ul>
<p>其简单用法如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var count: Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Int&gt;.size              <span class="comment">// 8</span></span><br><span class="line">MemoryLayout.size(ofValue: count)   <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.alignment         <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.stride            <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>我们看下Swift中基本数据类型的MemoryLayout三个属性的值：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test: <span class="built_in">NSObject</span> &#123;&#125;</span><br><span class="line">var count: Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK:- 值类型</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.size          <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.alignment     <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Int&gt;.stride        <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Double&gt;.size       <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Double&gt;.alignment  <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Double&gt;.stride     <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;Float&gt;.size        <span class="comment">// 4</span></span><br><span class="line">MemoryLayout&lt;Float&gt;.alignment   <span class="comment">// 4</span></span><br><span class="line">MemoryLayout&lt;Float&gt;.stride      <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;<span class="built_in">UInt</span>&gt;.size         <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;<span class="built_in">UInt</span>&gt;.alignment    <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;<span class="built_in">UInt</span>&gt;.stride       <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;String&gt;.size       <span class="comment">// 16</span></span><br><span class="line">MemoryLayout&lt;String&gt;.alignment  <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;String&gt;.stride     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: - 引用类型</span></span><br><span class="line">MemoryLayout&lt;Test&gt;.size         <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Test&gt;.alignment    <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;Test&gt;.stride       <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MARK: - 指针类型</span></span><br><span class="line">MemoryLayout&lt;UnsafePointer&lt;Test&gt;&gt;.size      <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;UnsafePointer&lt;Test&gt;&gt;.alignment <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;UnsafePointer&lt;Test&gt;&gt;.stride    <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">MemoryLayout&lt;UnsafeBufferPointer&lt;Test&gt;&gt;.size        <span class="comment">// 16</span></span><br><span class="line">MemoryLayout&lt;UnsafeBufferPointer&lt;Test&gt;&gt;.alignment   <span class="comment">// 8</span></span><br><span class="line">MemoryLayout&lt;UnsafeBufferPointer&lt;Test&gt;&gt;.stride      <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<h4 id="三、Swift指针"><a href="#三、Swift指针" class="headerlink" title="三、Swift指针"></a>三、Swift指针</h4><h5 id="3-1、使用类型指针"><a href="#3-1、使用类型指针" class="headerlink" title="3.1、使用类型指针"></a>3.1、使用类型指针</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 使用类型指针</span></span><br><span class="line">let ptr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line">ptr.initialize(to: <span class="number">1</span>)   <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">ptr              <span class="comment">// 0x6000022c00c0</span></span><br><span class="line">ptr.pointee      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">ptr.pointee = <span class="number">100</span></span><br><span class="line">ptr.pointee      <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">ptr.advanced(by: <span class="number">1</span>).pointee     <span class="comment">// 指针向后移动8Bytes，其指向的内存内容不确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完不要忘记销毁</span></span><br><span class="line">ptr.deallocate()</span><br></pre></td></tr></table></figure>
<h5 id="3-2、使用原生指针"><a href="#3-2、使用原生指针" class="headerlink" title="3.2、使用原生指针"></a>3.2、使用原生指针</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 使用原生指针</span></span><br><span class="line"></span><br><span class="line">let rawPtr = UnsafeMutableRawPointer.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">8</span>)</span><br><span class="line">rawPtr.storeBytes(of: <span class="string">"hello world"</span>, as: String.self)</span><br><span class="line">rawPtr.load(as: String.self)    <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">let bufferRawPtr = UnsafeMutableRawBufferPointer(start: rawPtr, count: <span class="number">16</span>)</span><br><span class="line"><span class="comment">// UnsafeRawBufferPointer类型以一系列字节的形式来读取内存</span></span><br><span class="line"><span class="keyword">for</span> (index, byte) <span class="keyword">in</span> bufferRawPtr.enumerated() &#123;</span><br><span class="line">    print(<span class="string">"byte \(index): \(byte)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、获取实例的bytes"><a href="#3-3、获取实例的bytes" class="headerlink" title="3.3、获取实例的bytes"></a>3.3、获取实例的bytes</h5><p>在Objective-C中我们经常遇到函数接受bytes指针的参数，那么Swift中如何获取bytes指针呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"hello world."</span></span><br><span class="line">withUnsafeBytes(of: str) &#123; bytes <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes &#123;</span><br><span class="line">        print(byte)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：禁止返回指针，如果指针超出withUnsafeBytes作用域，可能会导致意想不到的结果，其他withUnsafeXXX方法同样禁止返回指针</span></span><br><span class="line">    <span class="comment">// return bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4、指针类型转换"><a href="#3-4、指针类型转换" class="headerlink" title="3.4、指针类型转换"></a>3.4、指针类型转换</h5><p>我们操作C函数的时候，经常会遇到需要转换指针类型的情况，比如将指向结构体的指针转换为指向其它不同结构体的指针，这种操作在C语言中是很简单但也十分危险的。而由于Swift指针在创建时即明确了其类型，这就意味着一个UnsafePointer<int8>类型的指针不能用在需要UnsafePointer<uint8>的地方，比如：sqlite3_column_text返回值不能用在String(utf8String: )方法中，这个时候就需要用到指针类型转换了：</uint8></int8></p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let intPtr = UnsafeMutablePointer&lt;Int8&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">intPtr.pointee = <span class="number">-1</span></span><br><span class="line">intPtr.pointee      <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">let _ = intPtr.withMemoryRebound(to: <span class="built_in">UInt8</span>.self, capacity: <span class="number">1</span>) &#123; ptr <span class="keyword">in</span></span><br><span class="line">    ptr.pointee     <span class="comment">// 255</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、实践——通过指针修改Struct类型实例的属性的值"><a href="#四、实践——通过指针修改Struct类型实例的属性的值" class="headerlink" title="四、实践——通过指针修改Struct类型实例的属性的值"></a>四、实践——通过指针修改Struct类型实例的属性的值</h4><p>  先直接上代码：</p>
  <figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> TestStruct &#123;</span><br><span class="line">    var a: Int8 = <span class="number">7</span>             <span class="comment">// 1 bytes</span></span><br><span class="line">    private var b: Int = <span class="number">6</span>      <span class="comment">// 8 bytes</span></span><br><span class="line">    var c: String = <span class="string">"hello"</span>     <span class="comment">// 16 bytes</span></span><br><span class="line">    var d: Int?                 <span class="comment">// 9 bytes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var testStruct = TestStruct()</span><br><span class="line">let rawPtr = withUnsafeMutablePointer(to: &amp;testStruct) &#123;UnsafeMutableRawPointer(mutating: $<span class="number">0</span>)&#125;</span><br><span class="line">let b = rawPtr.load(fromByteOffset: <span class="number">8</span>, as: Int.self)</span><br><span class="line">let bPtr = rawPtr.advanced(by: <span class="number">8</span>).assumingMemoryBound(to: Int.self)</span><br><span class="line">bPtr.pointee        <span class="comment">// 6</span></span><br><span class="line">bPtr.initialize(to: <span class="number">10</span>)</span><br><span class="line">bPtr.pointee        <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>  代码分析：<br>  <code>rawPtr</code>指针是一个<code>void *</code>类型的指针，指向<code>testStruct</code>实例所在内存的第一个字节，我们可以通过移动指针获取<code>testStruct</code>的<code>private</code>属性<code>b</code>。<br>  属性<code>a</code>是<code>Int8</code>类型，占用1个字节，但是由于内存对齐的原因，其所占的内存空间为8个字节，因此需要将<code>rawPtr</code>向后移动8个字节才能获取到属性<code>b</code>的起始地址：<code>rawPtr.advanced(by: 8).assumingMemoryBound(to: Int.self)</code>。</p>
<blockquote>
<p>assumingMemoryBound(to:)</p>
</blockquote>
<blockquote>
<p>Returns a typed pointer to the memory referenced by this pointer, assuming that the memory is already bound to the specified type.</p>
</blockquote>
<p>  因此，将<code>rawPtr</code>向后移动8bytes后通过<code>assumingMemoryBound(to: Int.self)</code>方法，可以得到指向属性<code>b</code>的指针<code>bPtr</code>。之后通过<code>initialize(to: 10)</code>方法重新初始化属性b的内存区域，为其重新赋值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/" itemprop="url">从一个BUG谈起，剖析objc_msgSend函数的底层实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T19:46:12+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS开发/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、引出问题"><a href="#一、引出问题" class="headerlink" title="一、引出问题"></a>一、引出问题</h3><hr>
<p>前段时间开发FLEX+Relative库（使用Category和Runtime实现将<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a>库扩展出可以查看UIView相对间距的功能）。开发完成后遇到了一个奇怪的BUG，模拟器与真机调试时行为不一致，模拟器上可以正常实现预期功能，但是在真机上却出现问题：程序展示的视图与实际选中的视图不一致。先看问题代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateRelativeViewsForSelectionPoint:(<span class="built_in">CGPoint</span>)selectionPointInWindow &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeAndClearRelativeLines];</span><br><span class="line">    <span class="built_in">UIView</span> *selectedView = objc_msgSend(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewForSelectionAtPoint:), selectionPointInWindow);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.relativeViews containsObject:selectedView]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.relativeViews removeObject:selectedView];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.relativeViews addObject:selectedView];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.relativeViews.count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.relativeViews removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> updateRelativeDimensionLines];</span><br><span class="line">    [<span class="keyword">self</span>.view bringSubviewToFront:(<span class="built_in">UIView</span> *)[<span class="keyword">self</span> valueForKey:<span class="string">@"explorerToolbar"</span>]];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(updateButtonStates)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调试，定位到问题出现在objc_msgSend函数调用这一行，这行代码的作用是调用FLEX库的viewForSelectionAtPoint:方法返回用户点击的UIView，入参为用户点击的坐标。调试过程中发现，通过objc_msgSend函数调用时，传入viewForSelectionAtPoint:方法的坐标发生了变化（x和y值发生了互换，在模拟器上正常）。</p>
<p>我们知道objc_msgSend是OC中的核心函数，所有的方法调用最终都会转化成objc_msgSend函数调用，Apple为了优化其性能，该函数内部使用汇编语言实现，而且不同平台对应不同的汇编文件，你可以在这里<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/" target="_blank" rel="noopener">objc_msgSend汇编源码</a>查阅相关源代码。objc_msgSend中使用了cache，而且为了实现极致的性能优化，该函数使用了ldp指令、编译内存屏障（Compile Memory Barrier）、内存垃圾回收等技术代替锁来解决多线程环境下的读写竞争和死锁问题。</p>
<p>通过查阅资料发现，objc_msgSend函数与正常的C函数不同，调用时要准确地指定其返回值、入参等的类型：</p>
<blockquote>
<p>This unusual casting situation arises because objc_msgSend is not intended to be called like a normal C function. It is (and must be) implemented in assembly, and just jumps to a target C function after fiddling with a few registers. In particular, there is no consistent way to refer to any argument past the first two from within objc_msgSend. Another case where just calling objc_msgSend straight wouldn’t work is a method that returns an NSRect, say, because objc_msgSend is not used in that case, objc_msgSend_stret is. In the underlying C function for a method that returns an NSRect, the first argument is actually a pointer to an out value NSRect, and the function itself actually returns void. You must match this convention when calling because it’s what the called method will assume. Further, the circumstances in which objc_msgSend_stret is used differ between architectures. There is also an objc_msgSend_fpret, which should be used for methods that return certain floating point types on certain architectures.</p>
</blockquote>
<p>因此，修改objc_msgSend函数调用后，问题得到解决：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *selectedView = ((<span class="built_in">UIView</span>* (*)(<span class="keyword">id</span>, SEL, <span class="built_in">CGPoint</span> p))objc_msgSend)(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewForSelectionAtPoint:), selectionPointInWindow);</span><br></pre></td></tr></table></figure>
<h3 id="二、问题定位"><a href="#二、问题定位" class="headerlink" title="二、问题定位"></a>二、问题定位</h3><hr>
<p>以下分析均以ARM64架构为例</p>
<h4 id="2-1-预备知识"><a href="#2-1-预备知识" class="headerlink" title="2.1 预备知识"></a>2.1 预备知识</h4><p>开始之前，我们先了解一下ARM架构下程序的内存分配和汇编指令的相关知识。</p>
<h5 id="2-1-1-内存分配与管理"><a href="#2-1-1-内存分配与管理" class="headerlink" title="2.1.1 内存分配与管理"></a>2.1.1 内存分配与管理</h5><p>我们知道，任何指令的执行都离不开内存的操作，而根据用途的不同内存又被划分为堆(heap)、栈(stack)、常量区、全局（静态）区、代码区等。代码区存放可执行文件的指令，可以看做是可执行文件在内存中的镜像（只读）；全局区存放静态变量和全局变量；常量区，顾名思义，存放的是常量。这里重点介绍栈和堆。</p>
<p><img src="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/2.jpeg" alt="内存区域说明"></p>
<ul>
<li>堆：堆区是一块不连续的内存区域，由开发者分配和释放，我们开发时创建的一些对象等都是在堆中存储的，堆是由内存的低地址向高地址扩展的。</li>
<li>栈：栈区是一块连续的内存区域，由编译器进行分配和释放，其中的内存随着函数的运行和结束而分配和释放，由系统自动完成。栈的大小是有限制的，如果申请的内存大于栈区的剩余内存（如：快速排序递归层级过多时），程序会crash并报Stack Overflow错误。OS X和iOS系统中，子线程的最大栈空间默认为512KB，而对于主线程的最大栈空间，二者有所不同，OS X默认为8MB，iOS默认为1MB。</li>
</ul>
<p><img src="/2018/08/14/从一个BUG谈起，剖析objc-msgSend函数的底层实现/1.jpeg" alt="Apple堆栈大小说明"></p>
<h5 id="2-1-2-ARM汇编指令介绍"><a href="#2-1-2-ARM汇编指令介绍" class="headerlink" title="2.1.2 ARM汇编指令介绍"></a>2.1.2 ARM汇编指令介绍</h5><p>ARM64有32个长度为64bit的通用寄存器：x0~x30和sp，可以只使用其中的32bit：w0~w30，其中，前8个寄存器x0~x7用于函数调用时传参，同时，x0寄存器也可以作为函数返回值的寄存器。x8寄存器用于间接寻址（当函数返回的内容&gt;16Bytes时，该返回内容会被放入到内存中，然后将该内存地址存入x8寄存器）。</p>
<ul>
<li>sp寄存器指向当前frame的栈顶（低地址），可以通过移动sp的位置为栈分配或释放内存空间；</li>
<li>x29通常作为fp寄存器，指向当前frame的栈底（高地址）；</li>
<li>x30通常作为lr寄存器，它有两个作用：1、保存子程序的返回地址，2、当异常发生时，用来保存异常的返回地址；</li>
<li>pc，程序计数器，指向下一条指令。</li>
</ul>
<p>stp/ldp指令结合sp、x29、x30寄存器，保证了函数调用结束后的正确返回。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, sp, <span class="meta">#0x50</span></span><br><span class="line">stp    x29, x30, [sp, <span class="meta">#0x40]</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ldp    x29, x30, [sp, <span class="meta">#0x40]</span></span><br><span class="line">add    sp, sp, <span class="meta">#0x50</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>一些常用的汇编指令：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MOV X1, X0  ;寄存器X0的值传给X1</span><br><span class="line">ADD X0, X1, X2  ;寄存器X1和X2的值相加后给X0</span><br><span class="line">SUB X0, X1, X2  ;寄存器X1和X2的值相减后给X0</span><br><span class="line"></span><br><span class="line">AND X0, X0, <span class="meta">#0xF    ;X0和0xF相与后的值给X0</span></span><br><span class="line">ORR X0, X0, <span class="meta">#0x10   ;X0和0x10相或后的值给X0</span></span><br><span class="line">EOR X0, X0, <span class="meta">#0x11   ;X0和0x11相异或后的值给X0</span></span><br><span class="line"></span><br><span class="line">LDR(LDUR) X5, [X6, <span class="meta">#0x8]  ;X6寄存器的值(地址)加0x8的地址内的值给X5</span></span><br><span class="line">STR(STUR) X0, [SP, <span class="meta">#0x8]  ;X0的值给(SP+0x8)地址指向的空间</span></span><br><span class="line"></span><br><span class="line">STP X29, X30, [SP, <span class="meta">#0x1]    ;入栈操作</span></span><br><span class="line">LDP X29, X30, [SP, <span class="meta">#0x1]    ;出栈操作</span></span><br><span class="line"></span><br><span class="line">CBZ     比较，如果结果为<span class="number">0</span>，就跳转到后面的指令</span><br><span class="line">CBNZ    比较，如果结果非<span class="number">0</span>，就跳转到后面的指令</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMP</span>     比较指令，结果影响CSPR状态</span><br><span class="line"></span><br><span class="line">B/BL    绝对跳转,无返回值/绝对跳转,返回值地址保存到LR(X30)</span><br><span class="line">RET     子程序返回，返回地址保存到LR(X30)</span><br><span class="line"></span><br><span class="line">ADRP    用来定位数据段中的数据, 因为ASLR会导致代码及数据的地址随机化, 用ADRP来根据PC做辅助定位</span><br></pre></td></tr></table></figure>
<h4 id="2-2-定位问题"><a href="#2-2-定位问题" class="headerlink" title="2.2 定位问题"></a>2.2 定位问题</h4><p>开启XCode的Always Show Disassembly，并在updateRelativeViewsForSelectionPoint:方法中的调用objc_msgSend代码处加断点，程序执行到断点处，XCode输出反汇编代码如下:</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GWMovie`-[FLEXExplorerViewController(Relative) updateRelativeViewsForSelectionPoint:]:</span><br><span class="line">    <span class="number">0x1007dd3a0</span> &lt;+<span class="number">0</span>&gt;:   sub    sp, sp, <span class="meta">#0x50             ; =0x50        // 移动sp，分配0x50大小的空间，sp指向当前栈的栈顶</span></span><br><span class="line">    <span class="number">0x1007dd3a4</span> &lt;+<span class="number">4</span>&gt;:   stp    x29, x30, [sp, <span class="meta">#0x40]                    // 开始执行方法之前，将fp、lr寄存器入栈，状态保存到sp+0x40地址</span></span><br><span class="line">    <span class="number">0x1007dd3a8</span> &lt;+<span class="number">8</span>&gt;:   add    x29, sp, <span class="meta">#0x40            ; =0x40        // fp寄存器指向sp+0x40地址，fp指向当前frame的栈底</span></span><br><span class="line">    <span class="number">0x1007dd3ac</span> &lt;+<span class="number">12</span>&gt;:  stur   d0, [x29, <span class="meta">#-0x10]   // 将d0寄存器（存储浮点类型数据）的内容存到fp-0x10地址指向的空间</span></span><br><span class="line">    <span class="number">0x1007dd3b0</span> &lt;+<span class="number">16</span>&gt;:  stur   d1, [x29, <span class="meta">#-0x8]    // 将d1寄存器的内容存入fp-0x8地址指向的空间，d0和d1寄存器中存储的是CGPoint结构体的x、y值</span></span><br><span class="line">    <span class="number">0x1007dd3b4</span> &lt;+<span class="number">20</span>&gt;:  stur   x0, [x29, <span class="meta">#-0x18]</span></span><br><span class="line">    <span class="number">0x1007dd3b8</span> &lt;+<span class="number">24</span>&gt;:  str    x1, [sp, <span class="meta">#0x20]</span></span><br><span class="line">    <span class="number">0x1007dd3bc</span> &lt;+<span class="number">28</span>&gt;:  ldur   x0, [x29, <span class="meta">#-0x18]</span></span><br><span class="line">    <span class="number">0x1007dd3c0</span> &lt;+<span class="number">32</span>&gt;:  adrp   x1, <span class="number">8156</span></span><br><span class="line">    <span class="number">0x1007dd3c4</span> &lt;+<span class="number">36</span>&gt;:  ldr    x1, [x1, <span class="meta">#0x810]</span></span><br><span class="line">    <span class="number">0x1007dd3c8</span> &lt;+<span class="number">40</span>&gt;:  bl     <span class="number">0x101f86fa8</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend</span><br><span class="line">    <span class="comment">// 这句开始到bl指令之前，是编译器根据calling convention为objc_msgSend的函数调用设置寄存器、栈帧的数据和状态，但是由于未明确指定objc_msgSend函数的原型，导致了calling convention mismatch，这里取的数据和之前存的数据不一致，从而引起了程序的异常行为。</span></span><br><span class="line">-&gt;  <span class="number">0x1007dd3cc</span> &lt;+<span class="number">44</span>&gt;:  ldur   x0, [x29, <span class="meta">#-0x18]    // 将fp-0x18地址的内容存入x0，即：x0中存储的为消息的receiver，在该方法中为self</span></span><br><span class="line">    <span class="number">0x1007dd3d0</span> &lt;+<span class="number">48</span>&gt;:  adrp   x1, <span class="number">8153</span></span><br><span class="line">    <span class="number">0x1007dd3d4</span> &lt;+<span class="number">52</span>&gt;:  ldr    x1, [x1, <span class="meta">#0xf28]     // 将selector存入x1寄存器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题所在，这两句ldr指令将上文存储的d1的数据加载进d0，将d0的数据加载进了d1，从而导致了CGPoint结构体中x、y值的互换</span></span><br><span class="line">    <span class="number">0x1007dd3d8</span> &lt;+<span class="number">56</span>&gt;:  ldur   d0, [x29, <span class="meta">#-0x8]     // 将fp-0x8地址（存储了d1的值）的值给d0</span></span><br><span class="line">    <span class="number">0x1007dd3dc</span> &lt;+<span class="number">60</span>&gt;:  ldur   d1, [x29, <span class="meta">#-0x10]    // 将fp-0x10地址（存储了d0的值）的值给d1</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0x1007dd3e0</span> &lt;+<span class="number">64</span>&gt;:  mov    x30, sp</span><br><span class="line">    <span class="number">0x1007dd3e4</span> &lt;+<span class="number">68</span>&gt;:  str    d0, [x30, <span class="meta">#0x8]</span></span><br><span class="line">    <span class="number">0x1007dd3e8</span> &lt;+<span class="number">72</span>&gt;:  str    d1, [x30]</span><br><span class="line">    <span class="number">0x1007dd3ec</span> &lt;+<span class="number">76</span>&gt;:  bl     <span class="number">0x101f86fa8</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSend</span><br><span class="line">    <span class="number">0x1007dd3f0</span> &lt;+<span class="number">80</span>&gt;:  mov    x29, x29</span><br><span class="line">    <span class="number">0x1007dd3f4</span> &lt;+<span class="number">84</span>&gt;:  bl     <span class="number">0x101f87008</span>               ; symbol stub <span class="keyword">for</span>: objc_retainAutoreleasedReturnValue</span><br><span class="line">    <span class="number">0x1007dd3f8</span> &lt;+<span class="number">88</span>&gt;:  mov    x1, <span class="meta">#0x0</span></span><br><span class="line">    <span class="number">0x1007dd3fc</span> &lt;+<span class="number">92</span>&gt;:  add    x30, sp, <span class="meta">#0x18            ; =0x18 </span></span><br><span class="line">    <span class="number">0x1007dd400</span> &lt;+<span class="number">96</span>&gt;:  str    x0, [sp, <span class="meta">#0x18]</span></span><br><span class="line">    <span class="number">0x1007dd404</span> &lt;+<span class="number">100</span>&gt;: mov    x0, x30</span><br><span class="line">    <span class="number">0x1007dd408</span> &lt;+<span class="number">104</span>&gt;: bl     <span class="number">0x101f87068</span>               ; symbol stub <span class="keyword">for</span>: objc_storeStrong</span><br><span class="line">    <span class="number">0x1007dd40c</span> &lt;+<span class="number">108</span>&gt;: ldp    x29, x30, [sp, <span class="meta">#0x40]    // 恢复到该方法调用之前的状态</span></span><br><span class="line">    <span class="number">0x1007dd410</span> &lt;+<span class="number">112</span>&gt;: add    sp, sp, <span class="meta">#0x50             ; =0x50    // 方法结束，释放空间</span></span><br><span class="line">    <span class="number">0x1007dd414</span> &lt;+<span class="number">116</span>&gt;: ret                 <span class="comment">// 返回，这一步直接执行lr的指令</span></span><br></pre></td></tr></table></figure>
<p>从反汇编代码中可以看出，输入objc_msgSend函数的CGPoint参数与实际传入updateRelativeViewsForSelectionPoint:方法中的CGPoint参数的x、y值出现了互换：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stur   d0, [x29, <span class="meta">#-0x10]</span></span><br><span class="line">stur   d1, [x29, <span class="meta">#-0x8]</span></span><br><span class="line">...</span><br><span class="line">ldur   d0, [x29, <span class="meta">#-0x8]</span></span><br><span class="line">ldur   d1, [x29, <span class="meta">#-0x10]</span></span><br></pre></td></tr></table></figure>
<p>定位到问题出现在objc_msgSend函数的调用上，通过明确指定函数的入参类型和返回值类型，解决该问题。</p>
<h3 id="三、刨根问底——objc-msgSend函数分析"><a href="#三、刨根问底——objc-msgSend函数分析" class="headerlink" title="三、刨根问底——objc_msgSend函数分析"></a>三、刨根问底——objc_msgSend函数分析</h3><hr>
<p>那么为什么会出现这种奇怪的BUG呢？实际上，这个问题早在苹果发布的<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaTouch64BitGuide/ConvertingYourAppto64-Bit/ConvertingYourAppto64-Bit.html#//apple_ref/doc/uid/TP40013501-CH3-SW26" target="_blank" rel="noopener">64-Bit Transition Guide for Cocoa Touch</a>中提到：</p>
<blockquote>
<p>Test your app on actual 64-bit hardware. iOS Simulator can also be helpful during development, but some changes, such as the function calling conventions, are visible only when your app is running on a device.</p>
</blockquote>
<p>出现这个问题的原因是，在64-bit runtime下，ARM的调用约定（calling conventions）比32-bit更加严格。消息函数并不与runtime调用的方法函数共享同一个原型（prototype）,因此，当没有指定消息函数的原型时，runtime会直接调用该方法的函数实现，这样就导致了调用约定不匹配（calling convention mismatch）。以objc_msgSend函数为例，它被设计成一个通用的函数，通过calling convention来满足不同入参和不同返回值类型的函数调用，但是，当发生calling convention mismatch时，函数调用者会将参数放到非objc_msgSend函数期望的地方，这样一来，当objc_msgSend函数取值时，可能会取到错误的值，从而导致程序crash或异常行为。</p>
<blockquote>
<p>An exception to the casting rule described above is when you are calling the objc_msgSend function or any other similar functions in the Objective-C runtime that send messages. Although the prototype for the message functions has a variadic form, the method function that is called by the Objective-C runtime does not share the same prototype. The Objective-C runtime directly dispatches to the function that implements the method, so the calling conventions are mismatched, as described previously. Therefore you must cast the objc_msgSend function to a prototype that matches the method function being called.</p>
</blockquote>
<blockquote>
<p>If you pass a function pointer in your code, its calling conventions must stay consistent. It should always take the same set of parameters. Never cast a variadic function to a function that takes a fixed number of parameters (or vice versa). Listing 2-13 is an example of a problematic piece function call. Because the function pointer was cast to use a different set of calling conventions, a caller is going to place the parameters in a place that the called function is not expecting. This mismatch may cause your app to crash or to exhibit other unpredictable behaviors.</p>
</blockquote>
<h4 id="什么是Calling-Convention？"><a href="#什么是Calling-Convention？" class="headerlink" title="什么是Calling Convention？"></a>什么是Calling Convention？</h4><p>顾名思义，Calling Convention（调用约定）即一个函数调用另一个函数时的约定，包括了参数如何传递、如何从函数返回结果等，编译器必须严格遵循调用约定进行代码编译，这样才能保证生成的代码能够正确地运行。想了解更多有关Calling Convention的内容，请戳这里：<a href="https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html#//apple_ref/doc/uid/TP40013702-SW1" target="_blank" rel="noopener">ARM64 Function Calling Conventions</a></p>
<p>其实，objc_msgSend函数之所以用汇编实现，不仅仅是出于性能的考虑，我们知道objc_msgSend是一个特殊的函数，它被设计可以接收任意数量和类型的参数并可以返回任意类型的值，比如：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> b = [array containsObject:obj];</span><br><span class="line"><span class="built_in">NSUInteger</span> n = [array count];</span><br><span class="line"><span class="comment">// 上述代码会被转换成以下函数调用</span></span><br><span class="line"><span class="built_in">BOOL</span> b = (<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))objc_msgSend(array, <span class="keyword">@selector</span>(containsObject), obj);</span><br><span class="line"><span class="built_in">NSUInteger</span> n = (<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))objc_msgSend(array, <span class="keyword">@selector</span>(containsObject));</span><br></pre></td></tr></table></figure>
<p>当objc_msgSend通过selector找到对应的IMP后，只需要通过传入的参数和相应的IMP函数指针调用即可。Objective-C中有各种参数类型、数量的方法调用，objc_msgSend就必须支持任意参数类型、数量和任意返回值的函数调用，如果用C语言实现，就必须加很多switch分支，把所有的参数类型、数量的组合全都覆盖到，这显然是不可能实现的。</p>
<p>Apple的解决办法是，通过不同的Calling Convention，将objc_msgSend开始执行时所需要的栈帧（stack frame）的状态，各寄存器的参数、组合形式和状态设置等都交给编译器来设置，这样就保证了调用objc_msgSend函数时，栈和各个寄存器中的数据、状态正是调用具体函数时所需要的。</p>
<blockquote>
<p>当objc_msgSend找到要调用的函数实现IMP后，只需要把所有的对栈、寄存器的操作“倒”回到objc_msgSend执行开始的状态（类似于函数执行完成return返回前，做的“收尾处理”工作一样，即epilogue），直接jump/call到IMP函数指针对应的地址，执行指令即可，因为所有的参数已经被设置好了。</p>
</blockquote>
<blockquote>
<p>同时，当IMP执行完成后，返回值也被正确的设置好了（在x86平台上，返回值被设置到了指定的寄存器eax/rax里，在arm上，则是r0寄存器），所以，我们也不必担心不同类型的返回值问题了。</p>
</blockquote>
<h4 id="objc-msgSend函数汇编源码分析"><a href="#objc-msgSend函数汇编源码分析" class="headerlink" title="objc_msgSend函数汇编源码分析"></a>objc_msgSend函数汇编源码分析</h4><p>objc_msgSend函数的主要作用是：</p>
<ol>
<li>根据传入的对象，获取其isa指针，并根据isa指针找到对象所属的类</li>
<li>获取类的方法缓存，并根据selector从缓存中查找对应的IMP</li>
<li>如果从缓存中找到IMP，直接调用</li>
<li>如果没有从缓存中找到，调用C函数（__class_lookupMethodAndLoadCache3）继续查询，并将查询结果存入类的方法缓存</li>
</ol>
<p>首先看下objc_msgSend的完整指令（在lldb中输入disassemble -n objc_msgSend -c 100 -b命令）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718900</span> &lt;+<span class="number">0</span>&gt;:   <span class="number">0xf100001f</span>   cmp    x0, <span class="meta">#0x0                  ; =0x0 </span></span><br><span class="line"><span class="number">0x180718904</span> &lt;+<span class="number">4</span>&gt;:   <span class="number">0x5400034d</span>   b.le   <span class="number">0x18071896c</span>               ; &lt;+<span class="number">108</span>&gt;</span><br><span class="line"><span class="number">0x180718908</span> &lt;+<span class="number">8</span>&gt;:   <span class="number">0xf940000d</span>   ldr    x13, [x0]</span><br><span class="line"><span class="number">0x18071890c</span> &lt;+<span class="number">12</span>&gt;:  <span class="number">0x927d81b0</span>   and    x16, x13, <span class="meta">#0xffffffff8</span></span><br><span class="line"><span class="number">0x180718910</span> &lt;+<span class="number">16</span>&gt;:  <span class="number">0xa9412e0a</span>   ldp    x10, x11, [x16, <span class="meta">#0x10]</span></span><br><span class="line"><span class="number">0x180718914</span> &lt;+<span class="number">20</span>&gt;:  <span class="number">0x0a0b002c</span>   and    w12, w1, w11</span><br><span class="line"><span class="number">0x180718918</span> &lt;+<span class="number">24</span>&gt;:  <span class="number">0x8b0c114c</span>   add    x12, x10, x12, lsl <span class="meta">#4</span></span><br><span class="line"><span class="number">0x18071891c</span> &lt;+<span class="number">28</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br><span class="line"><span class="number">0x180718920</span> &lt;+<span class="number">32</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x180718924</span> &lt;+<span class="number">36</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x18071892c</span>               ; &lt;+<span class="number">44</span>&gt;</span><br><span class="line"><span class="number">0x180718928</span> &lt;+<span class="number">40</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x18071892c</span> &lt;+<span class="number">44</span>&gt;:  <span class="number">0xb40016a9</span>   cbz    x9, <span class="number">0x180718c00</span>           ; _objc_msgSend_uncached</span><br><span class="line"><span class="number">0x180718930</span> &lt;+<span class="number">48</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x180718934</span> &lt;+<span class="number">52</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718940</span>               ; &lt;+<span class="number">64</span>&gt;</span><br><span class="line"><span class="number">0x180718938</span> &lt;+<span class="number">56</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x18071893c</span> &lt;+<span class="number">60</span>&gt;:  <span class="number">0x17fffff9</span>   b      <span class="number">0x180718920</span>               ; &lt;+<span class="number">32</span>&gt;</span><br><span class="line"><span class="number">0x180718940</span> &lt;+<span class="number">64</span>&gt;:  <span class="number">0x8b2b518c</span>   add    x12, x12, w11, uxtw <span class="meta">#4</span></span><br><span class="line"><span class="number">0x180718944</span> &lt;+<span class="number">68</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br><span class="line"><span class="number">0x180718948</span> &lt;+<span class="number">72</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x18071894c</span> &lt;+<span class="number">76</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x180718954</span>               ; &lt;+<span class="number">84</span>&gt;</span><br><span class="line"><span class="number">0x180718950</span> &lt;+<span class="number">80</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x180718954</span> &lt;+<span class="number">84</span>&gt;:  <span class="number">0xb4001569</span>   cbz    x9, <span class="number">0x180718c00</span>           ; _objc_msgSend_uncached</span><br><span class="line"><span class="number">0x180718958</span> &lt;+<span class="number">88</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x18071895c</span> &lt;+<span class="number">92</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718968</span>               ; &lt;+<span class="number">104</span>&gt;</span><br><span class="line"><span class="number">0x180718960</span> &lt;+<span class="number">96</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x180718964</span> &lt;+<span class="number">100</span>&gt;: <span class="number">0x17fffff9</span>   b      <span class="number">0x180718948</span>               ; &lt;+<span class="number">72</span>&gt;</span><br><span class="line"><span class="number">0x180718968</span> &lt;+<span class="number">104</span>&gt;: <span class="number">0x140000a6</span>   b      <span class="number">0x180718c00</span>               ; _objc_msgSend_uncached</span><br><span class="line"><span class="number">0x18071896c</span> &lt;+<span class="number">108</span>&gt;: <span class="number">0x540001c0</span>   b.eq   <span class="number">0x1807189a4</span>               ; &lt;+<span class="number">164</span>&gt;</span><br><span class="line"><span class="number">0x180718970</span> &lt;+<span class="number">112</span>&gt;: <span class="number">0xd2fe000a</span>   mov    x10, <span class="meta">#-0x1000000000000000</span></span><br><span class="line"><span class="number">0x180718974</span> &lt;+<span class="number">116</span>&gt;: <span class="number">0xeb0a001f</span>   cmp    x0, x10</span><br><span class="line"><span class="number">0x180718978</span> &lt;+<span class="number">120</span>&gt;: <span class="number">0x540000c2</span>   b.hs   <span class="number">0x180718990</span>               ; &lt;+<span class="number">144</span>&gt;</span><br><span class="line"><span class="number">0x18071897c</span> &lt;+<span class="number">124</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718980</span> &lt;+<span class="number">128</span>&gt;: <span class="number">0x9109c14a</span>   add    x10, x10, <span class="meta">#0x270          ; =0x270 </span></span><br><span class="line"><span class="number">0x180718984</span> &lt;+<span class="number">132</span>&gt;: <span class="number">0xd37cfc0b</span>   lsr    x11, x0, <span class="meta">#60</span></span><br><span class="line"><span class="number">0x180718988</span> &lt;+<span class="number">136</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x18071898c</span> &lt;+<span class="number">140</span>&gt;: <span class="number">0x17ffffe1</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br><span class="line"><span class="number">0x180718990</span> &lt;+<span class="number">144</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718994</span> &lt;+<span class="number">148</span>&gt;: <span class="number">0x910bc14a</span>   add    x10, x10, <span class="meta">#0x2f0          ; =0x2f0 </span></span><br><span class="line"><span class="number">0x180718998</span> &lt;+<span class="number">152</span>&gt;: <span class="number">0xd374ec0b</span>   ubfx   x11, x0, <span class="meta">#52, #8</span></span><br><span class="line"><span class="number">0x18071899c</span> &lt;+<span class="number">156</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x1807189a0</span> &lt;+<span class="number">160</span>&gt;: <span class="number">0x17ffffdc</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br><span class="line"><span class="number">0x1807189a4</span> &lt;+<span class="number">164</span>&gt;: <span class="number">0xd2800001</span>   mov    x1, <span class="meta">#0x0</span></span><br><span class="line"><span class="number">0x1807189a8</span> &lt;+<span class="number">168</span>&gt;: <span class="number">0x2f00e400</span>   movi   d0, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189ac</span> &lt;+<span class="number">172</span>&gt;: <span class="number">0x2f00e401</span>   movi   d1, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b0</span> &lt;+<span class="number">176</span>&gt;: <span class="number">0x2f00e402</span>   movi   d2, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b4</span> &lt;+<span class="number">180</span>&gt;: <span class="number">0x2f00e403</span>   movi   d3, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b8</span> &lt;+<span class="number">184</span>&gt;: <span class="number">0xd65f03c0</span>   ret    </span><br><span class="line"><span class="number">0x1807189bc</span> &lt;+<span class="number">188</span>&gt;: <span class="number">0xd503201f</span>   nop</span><br></pre></td></tr></table></figure>
<p>完整的objc_msgSend流程包括了对receiver为空、<a href="https://juejin.im/post/58fe0c6561ff4b006671e789" target="_blank" rel="noopener">Tagged Pointer</a>、正常对象的判断，方法缓存命中、非命中等不同情况的处理，我们先从正常的情况开始分析，即：receiver非nil且非Tagged Pointer对象、并且在类的方法缓存中查找到对应的实现。</p>
<h5 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718900</span> &lt;+<span class="number">0</span>&gt;:   <span class="number">0xf100001f</span>   cmp    x0, <span class="meta">#0x0                  ; =0x0 </span></span><br><span class="line"><span class="number">0x180718904</span> &lt;+<span class="number">4</span>&gt;:   <span class="number">0x5400034d</span>   b.le   <span class="number">0x18071896c</span>               ; &lt;+<span class="number">108</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这两个指令是对存储在x0寄存器中的receiver与0进行比较，如果receiver小于等于0，跳转到第108行指令处，执行receiver == nil || Tagged Pointer流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718908</span> &lt;+<span class="number">8</span>&gt;:   <span class="number">0xf940000d</span>   ldr    x13, [x0]</span><br></pre></td></tr></table></figure>
<p>这条指令是加载receiver的第一个64bit(ARM64架构下)指针到x13寄存器。由于所有继承自NSObject的类实例化后的对象都会包含一个类型为isa_t的结构体（即，isa指针），该指针存在对象的第一个字中，因此，x13中保存的即是receiver的isa指针。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071890c</span> &lt;+<span class="number">12</span>&gt;:  <span class="number">0x927d81b0</span>   and    x16, x13, <span class="meta">#0xffffffff8</span></span><br></pre></td></tr></table></figure>
<p>由于ARM64可以使用非指针的isa(比如Tagged Pointer对象)，通常情况下，对象的isa指针指向的是对象的类，但是Tagged Pointer的isa利用了备用的bit位（比如，正常的OC对象地址的最高位为0，如果为1则表示对象是Tagged Pointer对象，而如果对象地址的最高4位位0xf，则代表该对象是用户自定义的Tagged Pointer对象，否则是系统自带的Tagged Pointer对象，如NSNumber、NSDate等），因此，这里通过isa指针与0xffffffff8得到receiver所属的Class对象obj_class，并将其保存到x16寄存器。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718910</span> &lt;+<span class="number">16</span>&gt;:  <span class="number">0xa9412e0a</span>   ldp    x10, x11, [x16, <span class="meta">#0x10]</span></span><br></pre></td></tr></table></figure>
<p>这个指令是从Class对象偏移16的地址处加载数据到x10,x11两个寄存器中，我们看下obj_class结构体的构成：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class对象首地址偏移16刚好指向cache_t,因此这条指令是将类的方法缓存加载到寄存器中，具体来说就是将_buckets加载到x10中，将_mask加载到x11的低32位，将_occupied加载到x11的高32位。cache_t的结构如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint32_t mask_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">    SEL selector;   <span class="comment">// selector</span></span><br><span class="line">    IMP imp;        <span class="comment">// 方法实现对应的函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;  <span class="comment">//缓存方法的哈希桶数组指针，桶的数量 = mask + 1</span></span><br><span class="line">    mask_t _mask;  <span class="comment">//描述了哈希表的尺寸，方便用于与运算的掩码。它的值总是一个2的幂减一，用二进制的方法描述看起来就像是000000001111111，末尾是可变数量的1。通过这个值可以知道selector的查找索引，并在查找表的时候包裹着结尾。</span></span><br><span class="line">    mask_t _occupied;           <span class="comment">//哈希表中的条目。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718914</span> &lt;+<span class="number">20</span>&gt;:  <span class="number">0x0a0b002c</span>   and    w12, w1, w11</span><br></pre></td></tr></table></figure>
<p>从上文介绍的内容知道，x1中存储的是selector，而w1代表了x1寄存器的低32位，w11位x11寄存器的低32位，因此这条指令将selector的低32位与上面提到的_mask进行与运算并将结果放入x12寄存器的低32位，结果相当于是计算selector % table_size，但是避免了开销很大的模运算。这条指令的作用是计算selector的起始哈希表的索引</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718918</span> &lt;+<span class="number">24</span>&gt;:  <span class="number">0x8b0c114c</span>   add    x12, x10, x12, lsl <span class="meta">#4</span></span><br></pre></td></tr></table></figure>
<p>有了索引，再取得地址我们就可以从哈希表中加载数据了。这条指令通过_buckets的地址结合上面得到的索引取得要查找的bucket地址。lsl #4是逻辑左移，相当于乘以16，由于每个bucket的大小是16Bytes，此时x12中刚好保存了第一个要查找的bucket的地址。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071891c</span> &lt;+<span class="number">28</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure>
<p>这条指令将当前bucket的selector加载到x9，将IMP加载到x17中。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718920</span> &lt;+<span class="number">32</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x180718924</span> &lt;+<span class="number">36</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x18071892c</span>               ; &lt;+<span class="number">44</span>&gt;</span><br><span class="line"><span class="number">0x180718928</span> &lt;+<span class="number">40</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x18071892c</span> &lt;+<span class="number">44</span>&gt;:  <span class="number">0xb40016a9</span>   cbz    x9, <span class="number">0x180718c00</span>           ;</span><br></pre></td></tr></table></figure>
<p>将当前receiver的selector与从bucket找到的selector进行比较，如果二者相等，则无条件跳转到x17,执行目标函数，至此，objc_msgSend的FAST_EXIT结束。<br>如果二者不相等，跳转到第44个指令，这条指令先是用当前查找的bucket的selector和0作比较，如果等于0则跳转到<strong>objc_msgSend_uncached。这说明这是一个空的bucket，并且意味着这次查找失败了。目标方法不在缓存中，这时候会回到C代码(</strong>objc_msgSend_uncached)，执行更详细的查找。否则就说明bucket不是空的，只是没有匹配，则继续查找。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718930</span> &lt;+<span class="number">48</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x180718934</span> &lt;+<span class="number">52</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718940</span>               ; &lt;+<span class="number">64</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>FLAG：</strong>将x12中的bucket地址与x10中的哈希表起始地址作比较，如果不相等，继续执行下面的指令，</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718938</span> &lt;+<span class="number">56</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x18071893c</span> &lt;+<span class="number">60</span>&gt;:  <span class="number">0x17fffff9</span>   b      <span class="number">0x180718920</span>               ; &lt;+<span class="number">32</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里可以看到一个循环，不断地从哈希表中取出新的bucket，执行第32条指令，直到找到匹配的bucket或者空的bucket或者命中表的开头。这条指令中，地址引用末尾的感叹号是一个有趣的特性。这指定一个寄存器进行回写，意思就是寄存器会更新为计算后的值。</p>
<p>如果<strong>FLAG</strong>处的比较结果相同，执行以下指令</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718940</span> &lt;+<span class="number">64</span>&gt;:  <span class="number">0x8b2b518c</span>   add    x12, x12, w11, uxtw <span class="meta">#4</span></span><br><span class="line"><span class="number">0x180718944</span> &lt;+<span class="number">68</span>&gt;:  <span class="number">0xa9404589</span>   ldp    x9, x17, [x12]</span><br><span class="line"><span class="number">0x180718948</span> &lt;+<span class="number">72</span>&gt;:  <span class="number">0xeb01013f</span>   cmp    x9, x1</span><br><span class="line"><span class="number">0x18071894c</span> &lt;+<span class="number">76</span>&gt;:  <span class="number">0x54000041</span>   b.ne   <span class="number">0x180718954</span>               ; &lt;+<span class="number">84</span>&gt;</span><br><span class="line"><span class="number">0x180718950</span> &lt;+<span class="number">80</span>&gt;:  <span class="number">0xd61f0220</span>   br     x17</span><br><span class="line"><span class="number">0x180718954</span> &lt;+<span class="number">84</span>&gt;:  <span class="number">0xb4001569</span>   cbz    x9, <span class="number">0x180718c00</span>           ; _objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>x12包含了当前bucket的指针，此时x12指向的是第一个bucket。w11包含了表的掩码，即表的大小。这里将两个值做了相加，同时将w11左移4位。现在x12中的结果是指向表的末尾，并且从这里可以恢复查找。然后执行ldp指令加载一个新的bucket到x9和x17寄存器，并检查该bucket是否与receiver的selector匹配，如果匹配，跳转到x17执行IMP，否则判断当前bucke是否为空bucket，如果为空，执行_objc_msgSend_uncached流程。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718958</span> &lt;+<span class="number">88</span>&gt;:  <span class="number">0xeb0a019f</span>   cmp    x12, x10</span><br><span class="line"><span class="number">0x18071895c</span> &lt;+<span class="number">92</span>&gt;:  <span class="number">0x54000060</span>   b.eq   <span class="number">0x180718968</span>               ; &lt;+<span class="number">104</span>&gt;</span><br><span class="line"><span class="number">0x180718960</span> &lt;+<span class="number">96</span>&gt;:  <span class="number">0xa9ff4589</span>   ldp    x9, x17, [x12, <span class="meta">#-0x10]!</span></span><br><span class="line"><span class="number">0x180718964</span> &lt;+<span class="number">100</span>&gt;: <span class="number">0x17fffff9</span>   b      <span class="number">0x180718948</span>               ; &lt;+<span class="number">72</span>&gt;</span><br><span class="line"><span class="number">0x180718968</span> &lt;+<span class="number">104</span>&gt;: <span class="number">0x140000a6</span>   b      <span class="number">0x180718c00</span>               ; _objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>再一次检查是否已到哈希表的表头，如果没有到表头，则重复上述步骤继续查找bucket；如果再次命中表头，跳转到104行指令处执行_objc_msgSend_uncached流程，调用C函数进行全面查找（SLOW_EXIT）。</p>
<blockquote>
<p>额外的二次扫描检查是为了在遇到内存被破坏或者无效对象时，防止陷入无限循环而榨干性能。举个例子，堆损坏能够在缓存中塞满非0的数据，或者设置缓存的掩码为0，缓存不命中就会一直循环执行缓存扫描。额外的检查可以停止循环，将问题转变为崩溃日志。</p>
</blockquote>
<blockquote>
<p>还有一种情况，当有另一个线程同时修改缓存时会引起这个线程即不命中也不miss。C代码做了额外的工作来解决竞争。之前一个版本的objc_msgSend的做法是错误的，它会立即终止，而不是回到C代码，这样做的话运气不好的时候会发生罕见的崩溃。</p>
</blockquote>
<h5 id="receiver为nil时"><a href="#receiver为nil时" class="headerlink" title="receiver为nil时"></a>receiver为nil时</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071896c</span> &lt;+<span class="number">108</span>&gt;: <span class="number">0x540001c0</span>   b.eq   <span class="number">0x1807189a4</span>               ; &lt;+<span class="number">164</span>&gt;</span><br><span class="line"><span class="number">0x1807189a4</span> &lt;+<span class="number">164</span>&gt;: <span class="number">0xd2800001</span>   mov    x1, <span class="meta">#0x0</span></span><br><span class="line"><span class="number">0x1807189a8</span> &lt;+<span class="number">168</span>&gt;: <span class="number">0x2f00e400</span>   movi   d0, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189ac</span> &lt;+<span class="number">172</span>&gt;: <span class="number">0x2f00e401</span>   movi   d1, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b0</span> &lt;+<span class="number">176</span>&gt;: <span class="number">0x2f00e402</span>   movi   d2, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b4</span> &lt;+<span class="number">180</span>&gt;: <span class="number">0x2f00e403</span>   movi   d3, <span class="meta">#0000000000000000</span></span><br><span class="line"><span class="number">0x1807189b8</span> &lt;+<span class="number">184</span>&gt;: <span class="number">0xd65f03c0</span>   ret</span><br></pre></td></tr></table></figure>
<p>当receiver为nil时，仅仅是将x0、x1、d0~d3寄存器的值设置为0（整型的返回值被保存在x0、x1中，浮点数返回值被保存在向量寄存器v0~v3中），然后返回给调用者。不清除x0是因为此时receiver为nil，x0中本来就是0。</p>
<h5 id="receiver为Tagged-Pointer时"><a href="#receiver为Tagged-Pointer时" class="headerlink" title="receiver为Tagged Pointer时"></a>receiver为Tagged Pointer时</h5><blockquote>
<p>简单讨论下tagged pointer是如何工作的。tagged pointer支持多个类。tagged pointer的前四位（ARM 64上）指明对象的类是哪个。本质上就是tagged pointer的isa。当然4位不够保存一个类的指针。实际上，有一张特殊的表存储了可用的tagged pointer的类。这个对象的类的查找是通过搜索这张表中的索引，是否对应于这个tagged pointer的前4位。</p>
</blockquote>
<blockquote>
<p>tagged pointer（至少在AMR64上）也支持扩展类。当前四位都设置为1，接下去的8位用于索引tagged pointer扩展类的表。减少存储他们的代价，就允许运行时能够支持更多的tagged pointer类。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718970</span> &lt;+<span class="number">112</span>&gt;: <span class="number">0xd2fe000a</span>   mov    x10, <span class="meta">#-0x1000000000000000</span></span><br><span class="line"><span class="number">0x180718974</span> &lt;+<span class="number">116</span>&gt;: <span class="number">0xeb0a001f</span>   cmp    x0, x10</span><br><span class="line"><span class="number">0x180718978</span> &lt;+<span class="number">120</span>&gt;: <span class="number">0x540000c2</span>   b.hs   <span class="number">0x180718990</span>               ; &lt;+<span class="number">144</span>&gt;</span><br></pre></td></tr></table></figure>
<p>x10被设置成一个整型值，只有前4位被设置为1，其余位都为0。x10被用作掩码从receiver中提取标志位，检查是否用户扩展的Tagged Pointer，如果receiver大于等于x10，则表示当前receiver为扩展的Tagged Pointer，跳转到144条指令处进行处理。否则说明receiver是系统自带的Tagged Pointer类型对象。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18071897c</span> &lt;+<span class="number">124</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718980</span> &lt;+<span class="number">128</span>&gt;: <span class="number">0x9109c14a</span>   add    x10, x10, <span class="meta">#0x270          ; =0x270</span></span><br></pre></td></tr></table></figure>
<p>1、系统自带Tagged Pointer类型对象的流程， 这里加载了系统Tagged Pointer主表到x10。</p>
<blockquote>
<p>ARM64需要两条指令来加载一个符号的地址。这是RISC样架构上的一个标准技术。AMR64上的指针是64位宽的，指令是32位宽。所以一个指令无法保存一个完整的指针。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718984</span> &lt;+<span class="number">132</span>&gt;: <span class="number">0xd37cfc0b</span>   lsr    x11, x0, <span class="meta">#60</span></span><br><span class="line"><span class="number">0x180718988</span> &lt;+<span class="number">136</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x18071898c</span> &lt;+<span class="number">140</span>&gt;: <span class="number">0x17ffffe1</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br></pre></td></tr></table></figure>
<p>由于系统自带的Tagged Pointer对象的索引保存在对象地址的60~63位，这里将receiver的地址右移60位取得索引并保存到x11中，然后根据该索引从x10的系统Tagged Pointer主表中获取到对象的isa指针并存入x16寄存器，然后跳转到第16条指令处执行后续的方法缓存查找等流程。</p>
<p>2、用户扩展的Tagged Pointer对象的执行流程也是类似的</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x180718990</span> &lt;+<span class="number">144</span>&gt;: <span class="number">0xb0198daa</span>   adrp   x10, <span class="number">209333</span></span><br><span class="line"><span class="number">0x180718994</span> &lt;+<span class="number">148</span>&gt;: <span class="number">0x910bc14a</span>   add    x10, x10, <span class="meta">#0x2f0          ; =0x2f0 </span></span><br><span class="line"><span class="number">0x180718998</span> &lt;+<span class="number">152</span>&gt;: <span class="number">0xd374ec0b</span>   ubfx   x11, x0, <span class="meta">#52, #8</span></span><br><span class="line"><span class="number">0x18071899c</span> &lt;+<span class="number">156</span>&gt;: <span class="number">0xf86b7950</span>   ldr    x16, [x10, x11, lsl <span class="meta">#3]</span></span><br><span class="line"><span class="number">0x1807189a0</span> &lt;+<span class="number">160</span>&gt;: <span class="number">0x17ffffdc</span>   b      <span class="number">0x180718910</span>               ; &lt;+<span class="number">16</span>&gt;</span><br></pre></td></tr></table></figure>
<p>不同的是扩展的Tagged Pointer对象的索引保存在对象地址的52~59位，这里用了一个位域提取指令ubfx提取对象地址的52~59位作为索引存入x11寄存器中，然后通过索引取得对象的isa指针，并进行后续的方法缓存查找等流程。</p>
<h3 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h3><hr>
<p>以上就是objc_msgSend函数的汇编分析的所有内容。理解objc_msgSend的实现原理，有助于我们深入理解Runtime机制、定位程序BUG等。<br>这篇文章只是浅显地分析了objc_msgSend函数的汇编实现，其中用到的的诸如Calling Convention、使用Compiler Memory Barrier（编译内存屏障）实现方法缓存的无锁读写同步的技术、使用享元设计模式从Tagged Pointer对象中获取isa等等都值得我们更深入地研究。</p>
<p><strong>参考文章</strong></p>
<ul>
<li><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm64.s.auto.html" target="_blank" rel="noopener">objc-msg-arm64.s源码</a></li>
<li><a href="https://draveness.me/isa" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html#//apple_ref/doc/uid/TP40013702-SW1" target="_blank" rel="noopener">iOS ABI Function Call Guide</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaTouch64BitGuide/ConvertingYourAppto64-Bit/ConvertingYourAppto64-Bit.html#//apple_ref/doc/uid/TP40013501-CH3-SW26" target="_blank" rel="noopener">64-Bit Transition Guide for Cocoa Touch</a></li>
<li><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf" target="_blank" rel="noopener">Procedure Call Standard for the ARM 64-bit Architecture</a></li>
<li><a href="http://www.arigrant.com/blog/2014/2/12/why-objcmsgsend-must-be-written-in-assembly" target="_blank" rel="noopener">Why objc_msgSend Must be Written in Assembly</a></li>
<li><a href="https://www.jianshu.com/p/df6629ec9a25" target="_blank" rel="noopener">深入解构objc_msgSend函数的实现</a></li>
<li><a href="http://www.cocoachina.com/ios/20170802/20102.html" target="_blank" rel="noopener">剖析ARM64下的objc_msgSend</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chy305chy.github.io/2018/06/03/最长回文子串的4种解法（swift实现）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cui Lanqing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔岚清的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/最长回文子串的4种解法（swift实现）/" itemprop="url">最长回文子串的4种解法（swift实现）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T15:59:02+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法-LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">算法, LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/03/最长回文子串的4种解法（swift实现）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/03/最长回文子串的4种解法（swift实现）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h3><p>子串：原字符串中任意个连续字符组成的子序列，长度小于等于原字符串<br>回文：形如：”abba”, “abcdcba”等中间字符对称的文法<br>最长回文子串：某个字符串中满足回文特性的最长子串</p>
<h3 id="二、解法"><a href="#二、解法" class="headerlink" title="二、解法"></a>二、解法</h3><h4 id="2-1-暴力查找"><a href="#2-1-暴力查找" class="headerlink" title="2.1 暴力查找"></a>2.1 暴力查找</h4><p>最先也最容易想到的解决办法，由于用到了三重for循环，时间复杂度为O(N^3)，空间复杂度为O(1)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindrome_Normal</span><span class="params">(str: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxPalindromLength: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> longestPalindrome: [<span class="type">String</span>] = [<span class="type">String</span>]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; str.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span> ..&lt; str.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> len: <span class="type">Int</span> = j-i</span><br><span class="line">                <span class="keyword">var</span> subArray = [<span class="type">String</span>]()</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> i ..&lt; j+<span class="number">1</span> &#123;</span><br><span class="line">                    subArray.append(str[k])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> isPalindrome(candidateStr: subArray) &#123;</span><br><span class="line">                    <span class="keyword">if</span> maxPalindromLength &lt; len &#123;</span><br><span class="line">                        maxPalindromLength = len</span><br><span class="line">                        longestPalindrome = subArray</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestPalindrome.joined()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断是否回文字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(candidateStr: [String])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; candidateStr.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="type">String</span>(candidateStr[i]) != <span class="type">String</span>(candidateStr[candidateStr.<span class="built_in">count</span>-<span class="number">1</span>-i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-动态规划法"><a href="#2-2-动态规划法" class="headerlink" title="2.2 动态规划法"></a>2.2 动态规划法</h4><p>对于字符串str, 假设dp[i,j] == 1表示str[i…j]是回文子串，那么必定存在str[i+1,j-1] == 1，依次类推，最长回文子串就能分解成一系列的子问题，可以使用DP求解。</p>
<p>首先构建状态转移方程：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str[i] != str[j]) &#123;</span><br><span class="line">    dp[i,j] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i,j] = dp[i+<span class="number">1</span>,j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先设定初始状态：</p>
<ul>
<li>dp[i][i] = 1，即单个字符是回文串</li>
<li>if(str[i] == str[i+1]) dp[i][i+1] = 1，即连续两个相同的字符是回文串</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindrome_DP</span><span class="params">(str: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> longestPalindromeString = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> dp = [[<span class="type">Int</span>]](repeating: [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: str.<span class="built_in">count</span>), <span class="built_in">count</span>: str.<span class="built_in">count</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单个字符是回文串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; str.<span class="built_in">count</span> &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个连续相同的字符也是回文串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; str.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> str[i] == str [i+<span class="number">1</span>] &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                maxLen = <span class="number">2</span></span><br><span class="line">                <span class="keyword">var</span> tmp = [<span class="type">String</span>]()</span><br><span class="line">                tmp.append(str[i])</span><br><span class="line">                tmp.append(str[i+<span class="number">1</span>])</span><br><span class="line">                longestPalindromeString = tmp.joined()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找出三个字符的回文串并以此类推</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">3</span> ... str.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... str.<span class="built_in">count</span> - k &#123;</span><br><span class="line">                <span class="keyword">let</span> j = i + k - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> str[i] == str [j] &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> dp[i][j] == <span class="number">1</span> &amp;&amp; maxLen &lt; k &#123;</span><br><span class="line">                        maxLen = k</span><br><span class="line">                        <span class="keyword">var</span> tmp = [<span class="type">String</span>]()</span><br><span class="line">                        <span class="keyword">for</span> m <span class="keyword">in</span> i ..&lt; j+<span class="number">1</span> &#123;</span><br><span class="line">                            tmp.append(str[m])</span><br><span class="line">                        &#125;</span><br><span class="line">                        longestPalindromeString = tmp.joined()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longestPalindromeString</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>dp是存储状态的二维数组，很明显dp是一个上三角矩阵，但是swift中没有对应的数据结构，使用二维数组代替。<br>时间复杂度：O(N^2)，空间复杂度：O(N^2)</p>
<h4 id="2-3-中心扩展法"><a href="#2-3-中心扩展法" class="headerlink" title="2.3 中心扩展法"></a>2.3 中心扩展法</h4><p>由于回文串具有对称性，因此，回文可以从它的中心展开，并且只有2n-1个这样的中心。</p>
<blockquote>
<p>为什么会是 2n−1 个，而不是 n 个中心？<br>原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba”的中心在两个‘b’ 之间）。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLongestPalindrome_CenterExpand</span><span class="params">(str: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; str.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> len1 = <span class="keyword">self</span>.expandAroundCenter(strArray: str, <span class="keyword">left</span>: i, <span class="keyword">right</span>: i)</span><br><span class="line">            <span class="keyword">let</span> len2 = <span class="keyword">self</span>.expandAroundCenter(strArray: str, <span class="keyword">left</span>: i, <span class="keyword">right</span>: i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">let</span> len = <span class="built_in">max</span>(len1, len2)</span><br><span class="line">            <span class="keyword">if</span> len &gt; end - start &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                end = i + len / <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> tmp = [<span class="type">String</span>]()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> start ... end &#123;</span><br><span class="line">            tmp.append(str[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp.joined()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandAroundCenter</span><span class="params">(strArray: [String], <span class="keyword">left</span>: Int, <span class="keyword">right</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="type">L</span> = <span class="keyword">left</span></span><br><span class="line">        <span class="keyword">var</span> <span class="type">R</span> = <span class="keyword">right</span></span><br><span class="line">        <span class="keyword">while</span> <span class="type">L</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="type">R</span> &lt; strArray.<span class="built_in">count</span> &amp;&amp; strArray[<span class="type">L</span>] == strArray[<span class="type">R</span>] &#123;</span><br><span class="line">            <span class="type">L</span> = <span class="type">L</span> - <span class="number">1</span></span><br><span class="line">            <span class="type">R</span> = <span class="type">R</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">R</span> - <span class="type">L</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于遍历字符串耗去O(N)，围绕中心扩展回文串耗去O(N)，因此时间复杂度为：O(N^2);<br>算法中没有使用额外的存储空间，空间复杂度为：O(1)。</p>
<h4 id="2-4-Manacher"><a href="#2-4-Manacher" class="headerlink" title="2.4 Manacher"></a>2.4 Manacher</h4><p>Manacher算法使用了一个非常巧妙技巧，只需扫描一遍字符串即可得到最长回文子串，其时间复杂度为O(N)，这里不详细介绍了，感兴趣的同学可以去这里<a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">Manacher算法</a>详细了解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Cui Lanqing</p>
              <p class="site-description motion-element" itemprop="description">一枚有梦想的程序猿</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cui Lanqing</span>

  
</div>


  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'WCdYKBzVHyUAmYLBFSD0S1EM-gzGzoHsz',
        appKey: 'TeFriUwpGPw3n0GaJ9PSdzEh',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
